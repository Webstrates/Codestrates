{"version":3,"sources":["webpack:///transformer.min.js","webpack:///webpack/bootstrap 6a0a827eb8ecc1c115ca","webpack:///./src/utils/matrix.js","webpack:///./src/utils/point.js","webpack:///./src/transforms/transform.js","webpack:///./src/transforms/translate-transform.js","webpack:///./src/transforms/rotate-transform.js","webpack:///./src/transforms/scale-transform.js","webpack:///./src/transforms/transform-group.js","webpack:///./src/transformer.js","webpack:///./src/extensions/bind.js","webpack:///./src/index.js","webpack:///./src/extensions/hammerize.js","webpack:///external \"hammerjs\""],"names":["window","modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","length","descriptor","writable","key","_createClass","protoProps","staticProps","value","default","Matrix","M","this","Array","isArray","Error","matrix","tx","ty","truncate","arguments","undefined","multiply","angle","rad","Math","PI","costheta","cos","sintheta","sin","sx","sy","degX","degY","radX","radY","x","tan","y","rows","columns","m1","m2","j","sum","k","parseFloat","toFixed","JSON","parse","stringify","fixed","getFixedValue","row","column","equals","identity","a","b","concat","a1","b1","c1","d1","a2","b2","c2","d2","a3","b3","c3","d3","a4","b4","c4","d4","set","_matrix","_rows","_columns","atan2","ii","dim","e","I","C","json","M1","M2","mRow","col","element","rawTransform","SVGElement","getAttribute","style","transform","nodeType","getComputedStyle","regEx","indexOf","exec","Point","_interopRequireDefault","obj","_point","Transform","_centerPoint","centerPointMatrix","translate","multiplyBy","inverse","constructor","_typeof","Symbol","iterator","_possibleConstructorReturn","self","ReferenceError","_get","receiver","Function","desc","getOwnPropertyDescriptor","parent","getPrototypeOf","_inherits","subClass","superClass","create","setPrototypeOf","__proto__","_transform","TranslateTransform","_Transform","_this","from","update","RotateTransform","ScaleTransform","sqrt","pow","TransformGroup","transforms","push","contains","idx","splice","type","forEach","_ref","unapply","apply","slice","reverse","_ref2","_ref3","reset","map","_ref4","toString","join","_translateTransform","_rotateTransform","_scaleTransform","_transformGroup","Transformer","callback","debug","parentElement","transformer","updateInProgress","getTransformMatrix","transformGroup","add","_transforms","visualTransformOrigin","querySelector","document","createElement","setAttribute","insertBefore","firstElementChild","updateElementsTransform","renderTransform","elementMatrix","updateElement","Promise","resolve","reject","refreshTransforms","requestAnimationFrame","updateElementTransform","elementTransform","toCss","setCssTransform","cssTransform","position","transformOrigin","removeAttribute","webkitTransform","mozTransform","msTransform","oTransform","allTransformers","body","getTransformHierarchy","point","ancestor","getAncesterElementWithoutTransformer","_ancestor$getBounding","getBoundingClientRect","left","top","applyToGlobalTransform","unapplyFromGlobalTransform","_ancestor$getBounding2","deltaPoint","allTransforms","applyToLocalTransform","scaleX","scaleY","scale","bind","_transformer","setTimeout","reapplyTransforms","then","_bind","_hammerize","hammerize","options","Hammer","assign","pan","rotate","pinch","enabled","hammerManager","Manager","_destroy","destroy","Pan","threshold","pointers","Rotate","recognizeWith","Pinch","scaleTransform","rotateTransform","translateTransform","isEnabled","isValidEvent","event","consumeEvent","srcEvent","stopPropagation","adjustCenterPoint","fromGlobalToLocal","prevPoint","prevScale","angleOffset","prevAngle","on","isFinal","complete","deltaX","deltaY","fromGlobalToLocalDelta","newX","newY","rotation","centerPoint","center","deltaAngle","mouseWheelManipulated","addEventListener","preventDefault","stopImmediatePropagation","wheel","wheelDelta","manipulationFactor","exp","clientX","clientY","ctrlKey","newScale"],"mappings":"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","file":"transformer.min.js","sourcesContent":["window[\"Transformer\"] =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 9);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * The matrix class provides convenient functions for affine transformations, e.g., translate, rotate,\n * and scale. It also offers functions like matrix multiplication or creating an inverse matrix.\n * \n * @class Matrix\n */\nvar Matrix =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Creates an instance of Matrix. The matrix needs to be a two-dimensional array. The first index will\n   * be rows and the second index will be columns. The array needs to be in a n x m format. For example,\n   * an array [[1, 2, 3], [4, 5, 6], [7, 8 ,9]] will result in the following matrix:\n   * \n   * 1   2   3\n   * 4   5   6\n   * 7   8   9\n   * \n   * @param {any} M A two-dimensional array.\n   * \n   * @memberOf Matrix\n   */\n  function Matrix(M) {\n    _classCallCheck(this, Matrix);\n\n    if (typeof M === 'undefined' || !Array.isArray(M)) {\n      throw new Error(\"first parameter needs to be a two-dimensional array\");\n    }\n\n    this.matrix = M;\n  }\n  /**\n   * Sets the matrix. The matrix needs to be a two-dimensional array. The first index will be rows and\n   * the second index will be columns. The array needs to be in a n x m format.\n   * \n   * @memberOf Matrix\n   */\n\n\n  _createClass(Matrix, [{\n    key: \"translate\",\n\n    /**\n     * Translates the matrix by tx and ty.\n     * \n     * @param {Number} tx The translation value in x.\n     * @param {Number} ty The translation value in y.\n     * \n     * @memberOf Matrix\n     */\n    value: function translate(tx, ty) {\n      var truncate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var M = this.multiply(new Matrix([[1, 0, tx], [0, 1, ty], [0, 0, 1]]), truncate).matrix;\n      this.matrix = M;\n    }\n    /**\n     * Rotates the matrix by angle. The rotation value has to be in degrees.\n     * \n     * @param {Number} angle The rotation value in degrees.\n     * \n     * @memberOf Matrix\n     */\n\n  }, {\n    key: \"rotate\",\n    value: function rotate(angle) {\n      var truncate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var rad = angle * (Math.PI / 180);\n      var costheta = Math.cos(rad);\n      var sintheta = Math.sin(rad);\n      var M = this.multiply(new Matrix([[costheta, -sintheta, 0], [sintheta, costheta, 0], [0, 0, 1]]), truncate).matrix;\n      this.matrix = M;\n    }\n    /**\n     * Scales the matrix by sx and sy.\n     * \n     * @param {Number} sx The scale value in x.\n     * @param {Number} sy The scale value in y.\n     * \n     * @memberOf Matrix\n     */\n\n  }, {\n    key: \"scale\",\n    value: function scale(sx, sy) {\n      var truncate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var M = this.multiply(new Matrix([[sx, 0, 0], [0, sy, 0], [0, 0, 1]]), truncate).matrix;\n      this.matrix = M;\n    }\n    /**\n     * Skwes the matrix in degX and degY.\n     * \n     * @param {Number} degX The skew value in x in degrees.\n     * @param {Number} degY The skew value in y in degrees.\n     * \n     * @memberOf Matrix\n     */\n\n  }, {\n    key: \"skew\",\n    value: function skew(degX, degY) {\n      var truncate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var radX = degX * (Math.PI / 180);\n      var radY = degY * (Math.PI / 180);\n      var x = Math.tan(radX);\n      var y = Math.tan(radY);\n      var M = this.multiply(new Matrix([[1, x, 0], [y, 1, 0], [0, 0, 1]]), truncate).matrix;\n      this.matrix = M;\n    }\n    /**\n     * Multiplies a given matrix with this matrix and returns the result as new matrix instance. In order\n     * to perform the matrix multiplication, rows of matrix M1 need to match columns of matrix M2 as well\n     * as columns of matrix M1 need to match rows of matrix M2.\n     * \n     * @param {any} M The matrix used to multiply with this matrix.\n     * @returns The multipied matrix.\n     * \n     * @memberOf Matrix\n     */\n\n  }, {\n    key: \"multiply\",\n    value: function multiply(M) {\n      var truncate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      if (this.rows !== M.columns || this.columns !== M.rows) {\n        throw new Error(\"cannot multiply because matrix dimensions do not match (n*m !== m*n)\");\n      }\n\n      var m = [];\n      var m1 = this.matrix;\n      var m2 = M.matrix;\n\n      for (var i = 0; i < m1.length; i++) {\n        m[i] = [];\n\n        for (var j = 0; j < m2[0].length; j++) {\n          var sum = 0;\n\n          for (var k = 0; k < m1[0].length; k++) {\n            sum += m1[i][k] * m2[k][j];\n          } // m[i][j] = sum;\n\n\n          m[i][j] = truncate ? parseFloat(sum.toFixed(3)) : sum;\n        }\n      }\n\n      return new Matrix(m);\n    }\n    /**\n     * Multiplies this matrix by the given matrix and replaces this matrix by the resulting matrix.\n     * \n     * @param {any} The matrix used to multiply with this matrix.\n     * \n     * @memberOf Matrix\n     */\n\n  }, {\n    key: \"multiplyBy\",\n    value: function multiplyBy(M) {\n      // const m = this.multiply(M).matrix;\n      var m = M.multiply(this).matrix;\n      this.matrix = m;\n    }\n    /**\n     * Creates a copy of the matrix.\n     * \n     * @returns The copy of this matrix.\n     * \n     * @memberOf Matrix\n     */\n\n  }, {\n    key: \"copy\",\n    value: function copy() {\n      var m = this.matrix;\n      var copyM = JSON.parse(JSON.stringify(m));\n      return new Matrix(copyM);\n    }\n    /**\n     * Returns the inverse matrix of this matrix.\n     * \n     * http://blog.acipo.com/matrix-inversion-in-javascript/\n     * \n     * @readonly\n     * \n     * @memberOf Matrix\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return JSON.stringify(this.matrix);\n    }\n  }, {\n    key: \"toCss\",\n\n    /**\n     * Converts the matrix to a CSS matrix transform. It respects whether the matrix should be a\n     * CSS matrix() or CSS matrix3d().\n     * \n     * @returns The CSS transform.\n     * \n     * @memberOf Matrix\n     */\n    value: function toCss() {\n      var fixed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      var M = this.matrix;\n\n      var getFixedValue = function getFixedValue(row, column) {\n        if (fixed) {\n          return parseFloat(M[row][column].toFixed(3));\n        }\n\n        return M[row][column];\n      };\n\n      if (this.rows === 3 && this.columns === 3) {\n        if (this.equals(Matrix.identity(3))) {\n          return \"none\";\n        }\n\n        var a = getFixedValue(0, 0);\n        var b = getFixedValue(1, 0);\n        var c = getFixedValue(0, 1);\n        var d = getFixedValue(1, 1);\n        var tx = getFixedValue(0, 2);\n        var ty = getFixedValue(1, 2);\n        return \"matrix(\".concat(a, \", \").concat(b, \", \").concat(c, \", \").concat(d, \", \").concat(tx, \", \").concat(ty, \")\");\n      }\n\n      if (this.equals(Matrix.identity(4))) {\n        return \"none\";\n      }\n\n      var a1 = getFixedValue(0, 0);\n      var b1 = getFixedValue(1, 0);\n      var c1 = getFixedValue(2, 0);\n      var d1 = getFixedValue(3, 0);\n      var a2 = getFixedValue(0, 1);\n      var b2 = getFixedValue(1, 1);\n      var c2 = getFixedValue(2, 1);\n      var d2 = getFixedValue(3, 1);\n      var a3 = getFixedValue(0, 2);\n      var b3 = getFixedValue(1, 2);\n      var c3 = getFixedValue(2, 2);\n      var d3 = getFixedValue(3, 2);\n      var a4 = getFixedValue(0, 3);\n      var b4 = getFixedValue(1, 3);\n      var c4 = getFixedValue(2, 3);\n      var d4 = getFixedValue(3, 3);\n      return \"matrix3d(\".concat(a1, \", \").concat(b1, \", \").concat(c1, \", \").concat(d1, \", \").concat(a2, \", \").concat(b2, \", \").concat(c2, \", \").concat(d2, \", \").concat(a3, \", \").concat(b3, \", \").concat(c3, \", \").concat(d3, \", \").concat(a4, \", \").concat(b4, \", \").concat(c4, \", \").concat(d4, \")\");\n    }\n    /**\n     * Returns true if matrix M equals to this matrix.\n     * \n     * @param {any} M A matrix to compare to.\n     * @returns True if this matrix and matrix M are equal.\n     * \n     * @memberOf Matrix\n     */\n\n  }, {\n    key: \"equals\",\n    value: function equals(M) {\n      return Matrix.equals(this, M);\n    }\n    /**\n     * Returns true if both matrix have the same matrix values, false otherwise.\n     * \n     * @static\n     * @param {any} M1 Matrix 1.\n     * @param {any} M2 Matrix 2.\n     * @returns True if matrix M1 and M2 are equal.\n     * \n     * @memberOf Matrix\n     */\n\n  }, {\n    key: \"toString\",\n\n    /**\n     * Returns the matrix in a human readable format. \n     * \n     * @returns The matrix in string format.\n     * \n     * @memberOf Matrix\n     */\n    value: function toString() {\n      return \"Matrix [rows=\".concat(this.rows, \",columns=\").concat(this.columns, \",matrix=\").concat(JSON.stringify(this.matrix), \"]\");\n    }\n  }, {\n    key: \"matrix\",\n    set: function set(matrix) {\n      this._matrix = matrix;\n      this._rows = matrix.length;\n      this._columns = matrix[0].length;\n    }\n    /**\n     * Returns the matrix as a two-dimensional array.\n     * \n     * @memberOf Matrix\n     */\n    ,\n    get: function get() {\n      return this._matrix;\n    }\n    /**\n     * Returns number of rows of matrix.\n     * \n     * @readonly\n     * \n     * @memberOf Matrix\n     */\n\n  }, {\n    key: \"rows\",\n    get: function get() {\n      return this._rows;\n    }\n    /**\n     * Returns number of columns of matrix.\n     * \n     * @readonly\n     * \n     * @memberOf Matrix\n     */\n\n  }, {\n    key: \"columns\",\n    get: function get() {\n      return this._columns;\n    }\n  }, {\n    key: \"a\",\n    get: function get() {\n      return this.matrix[0][0];\n    }\n  }, {\n    key: \"b\",\n    get: function get() {\n      return this.matrix[1][0];\n    }\n  }, {\n    key: \"c\",\n    get: function get() {\n      return this.matrix[0][1];\n    }\n  }, {\n    key: \"d\",\n    get: function get() {\n      return this.matrix[1][1];\n    }\n  }, {\n    key: \"tx\",\n    get: function get() {\n      return this.matrix[0][2];\n    }\n  }, {\n    key: \"ty\",\n    get: function get() {\n      return this.matrix[1][2];\n    }\n  }, {\n    key: \"angle\",\n    get: function get() {\n      var rad = Math.atan2(this.b, this.a);\n      return rad * 180 / Math.PI;\n    }\n  }, {\n    key: \"scaleX\",\n    get: function get() {\n      return this.a;\n    }\n  }, {\n    key: \"scaleY\",\n    get: function get() {\n      return this.d;\n    }\n  }, {\n    key: \"inverse\",\n    get: function get() {\n      // I use Guassian Elimination to calculate the inverse:\n      // (1) 'augment' the matrix (left) by the identity (on the right)\n      // (2) Turn the matrix on the left into the identity by elemetry row ops\n      // (3) The matrix on the right is the inverse (was the identity matrix)\n      // There are 3 elemtary row ops: (I combine b and c in my code)\n      // (a) Swap 2 rows\n      // (b) Multiply a row by a scalar\n      // (c) Add 2 rows\n      var M = this.matrix; //if the matrix isn't square: exit (error)\n\n      if (M.length !== M[0].length) {\n        throw new Error(\"matrix is not squared\");\n      } //create the identity matrix (I), and a copy (C) of the original\n\n\n      var i = 0,\n          ii = 0,\n          j = 0,\n          dim = M.length,\n          e = 0; // t = 0;\n\n      var I = [],\n          C = [];\n\n      for (i = 0; i < dim; i += 1) {\n        // Create the row\n        I[I.length] = [];\n        C[C.length] = [];\n\n        for (j = 0; j < dim; j += 1) {\n          //if we're on the diagonal, put a 1 (for identity)\n          if (i == j) {\n            I[i][j] = 1;\n          } else {\n            I[i][j] = 0;\n          } // Also, make the copy of the original\n\n\n          C[i][j] = M[i][j];\n        }\n      } // Perform elementary row operations\n\n\n      for (i = 0; i < dim; i += 1) {\n        // get the element e on the diagonal\n        e = C[i][i]; // if we have a 0 on the diagonal (we'll need to swap with a lower row)\n\n        if (e == 0) {\n          //look through every row below the i'th row\n          for (ii = i + 1; ii < dim; ii += 1) {\n            //if the ii'th row has a non-0 in the i'th col\n            if (C[ii][i] != 0) {\n              //it would make the diagonal have a non-0 so swap it\n              for (j = 0; j < dim; j++) {\n                e = C[i][j]; //temp store i'th row\n\n                C[i][j] = C[ii][j]; //replace i'th row by ii'th\n\n                C[ii][j] = e; //repace ii'th by temp\n\n                e = I[i][j]; //temp store i'th row\n\n                I[i][j] = I[ii][j]; //replace i'th row by ii'th\n\n                I[ii][j] = e; //repace ii'th by temp\n              } //don't bother checking other rows since we've swapped\n\n\n              break;\n            }\n          } //get the new diagonal\n\n\n          e = C[i][i]; //if it's still 0, not invertable (error)\n\n          if (e == 0) {\n            throw new Error(\"matrix is not invertable\");\n          }\n        } // Scale this row down by e (so we have a 1 on the diagonal)\n\n\n        for (j = 0; j < dim; j++) {\n          C[i][j] = C[i][j] / e; //apply to original matrix\n\n          I[i][j] = I[i][j] / e; //apply to identity\n        } // Subtract this row (scaled appropriately for each row) from ALL of\n        // the other rows so that there will be 0's in this column in the\n        // rows above and below this one\n\n\n        for (ii = 0; ii < dim; ii++) {\n          // Only apply to other rows (we want a 1 on the diagonal)\n          if (ii == i) {\n            continue;\n          } // We want to change this element to 0\n\n\n          e = C[ii][i]; // Subtract (the row above(or below) scaled by e) from (the\n          // current row) but start at the i'th column and assume all the\n          // stuff left of diagonal is 0 (which it should be if we made this\n          // algorithm correctly)\n\n          for (j = 0; j < dim; j++) {\n            C[ii][j] -= e * C[i][j]; //apply to original matrix\n\n            I[ii][j] -= e * I[i][j]; //apply to identity\n          }\n        }\n      } //we've done all operations, C should be the identity\n      //matrix I should be the inverse:\n\n\n      return new Matrix(I);\n    }\n  }], [{\n    key: \"fromJSON\",\n    value: function fromJSON(json) {\n      var matrix = JSON.parse(json);\n      return new Matrix(matrix);\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(M1, M2) {\n      return JSON.stringify(M1.matrix) === JSON.stringify(M2.matrix);\n    }\n    /**\n     * Creates an n x n identity matrix.\n     * \n     * @static\n     * @param {any} n The number of rows and columns to create this n x n identity matrix.\n     * @returns The identity matrix.\n     * \n     * @memberOf Matrix\n     */\n\n  }, {\n    key: \"identity\",\n    value: function identity(n) {\n      var m = [];\n\n      for (var row = 0; row < n; row++) {\n        var mRow = m[row] = [];\n\n        for (var col = 0; col < n; col++) {\n          mRow[col] = col === row ? 1 : 0;\n        }\n      }\n\n      return new Matrix(m);\n    }\n    /**\n     * Creates a matrix from a DOM element (e.g., a HTMLElement or a SVGElement).\n     * \n     * @static\n     * @param {any} element A DOM element from which the matrix is created from.\n     * @returns The matrix.\n     * \n     * @memberOf Matrix\n     */\n\n  }, {\n    key: \"from\",\n    value: function from(element) {\n      var rawTransform = \"none\";\n\n      if (element instanceof SVGElement) {\n        rawTransform = element.getAttribute(\"transform\"); // SAFARI does not return a proper transform with window.getComputedStyle for SVGElement.\n        // TODO This is a nasty workaround.\n\n        if (!rawTransform || rawTransform === \"\") {\n          rawTransform = element.style.transform;\n        }\n      } else if (element.nodeType === 1) {\n        rawTransform = window.getComputedStyle(element).transform;\n      }\n\n      if (rawTransform === \"\" || rawTransform === \"none\") {\n        return Matrix.identity(3);\n      } else {\n        var regEx = /([-+]?[\\d\\.]+)/g; // console.log('rawTransform %o', rawTransform);\n\n        if (rawTransform.indexOf(\"matrix3d\") > -1) {\n          // throw new Error(`matrix3d transformation not yet supported`);\n          // https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/matrix3d\n          var a1 = parseFloat(regEx.exec(rawTransform)[0]);\n          var b1 = parseFloat(regEx.exec(rawTransform)[0]);\n          var c1 = parseFloat(regEx.exec(rawTransform)[0]);\n          var d1 = parseFloat(regEx.exec(rawTransform)[0]);\n          var a2 = parseFloat(regEx.exec(rawTransform)[0]);\n          var b2 = parseFloat(regEx.exec(rawTransform)[0]);\n          var c2 = parseFloat(regEx.exec(rawTransform)[0]);\n          var d2 = parseFloat(regEx.exec(rawTransform)[0]);\n          var a3 = parseFloat(regEx.exec(rawTransform)[0]);\n          var b3 = parseFloat(regEx.exec(rawTransform)[0]);\n          var c3 = parseFloat(regEx.exec(rawTransform)[0]);\n          var d3 = parseFloat(regEx.exec(rawTransform)[0]);\n          var a4 = parseFloat(regEx.exec(rawTransform)[0]);\n          var b4 = parseFloat(regEx.exec(rawTransform)[0]);\n          var c4 = parseFloat(regEx.exec(rawTransform)[0]);\n          var d4 = parseFloat(regEx.exec(rawTransform)[0]);\n          return new Matrix([[a1, a2, a3, a4], [b1, b2, b3, b4], [c1, c2, c3, c4], [d1, d2, d3, d4]]);\n        } else {\n          // https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/matrix\n          var a = parseFloat(regEx.exec(rawTransform)[0]);\n          var b = parseFloat(regEx.exec(rawTransform)[0]);\n          var c = parseFloat(regEx.exec(rawTransform)[0]);\n          var d = parseFloat(regEx.exec(rawTransform)[0]);\n          var tx = parseFloat(regEx.exec(rawTransform)[0]);\n          var ty = parseFloat(regEx.exec(rawTransform)[0]);\n          return new Matrix([[a, c, tx], [b, d, ty], [0, 0, 1]]);\n        }\n      }\n    }\n  }]);\n\n  return Matrix;\n}();\n\nexports.default = Matrix;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * A simple point class.\n * \n * @class Point\n */\nvar Point =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Creates an instance of Point.\n   * \n   * @param {any} x The x value.\n   * @param {any} y The y value.\n   * \n   * @memberOf Point\n   */\n  function Point(x, y) {\n    _classCallCheck(this, Point);\n\n    this.x = x;\n    this.y = y;\n  }\n  /**\n   * Returns the string representation of the point.\n   * \n   * @returns The string representation of the point.\n   * \n   * @memberOf Point\n   */\n\n\n  _createClass(Point, [{\n    key: \"toString\",\n    value: function toString() {\n      return \"\".concat(Point.name, \" [x=\").concat(this.x, \",y=\").concat(this.y, \"]\");\n    }\n  }]);\n\n  return Point;\n}();\n\nexports.default = Point;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _point = _interopRequireDefault(__webpack_require__(1));\n\nvar _matrix = _interopRequireDefault(__webpack_require__(0));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * The base class for a transforms.\n * \n * @class Transform\n */\nvar Transform =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Creates an instance of Transform. It will create an instance with a default identity matrix.\n   * \n   * @memberOf Transform\n   */\n  function Transform() {\n    _classCallCheck(this, Transform);\n\n    this.matrix = _matrix.default.identity(3);\n    this._centerPoint = new _point.default(0, 0);\n  }\n\n  _createClass(Transform, [{\n    key: \"apply\",\n\n    /**\n     * Applies this transform to the matrix given as parameter.\n     * \n     * @param {any} matrix The matrix to which this transform will be applied.\n     * \n     * @memberOf Transform\n     */\n    value: function apply(matrix) {\n      var centerPointMatrix = _matrix.default.identity(3);\n\n      centerPointMatrix.translate(this._centerPoint.x, this._centerPoint.y);\n      matrix.multiplyBy(centerPointMatrix.inverse);\n      matrix.multiplyBy(this.matrix);\n      matrix.multiplyBy(centerPointMatrix);\n    }\n    /**\n     * Unapplies this transformation from the matrix given as paramter.\n     * \n     * @param {any} matrix The matrix from which this transform will be unapplied.\n     * \n     * @memberOf Transform\n     */\n\n  }, {\n    key: \"unapply\",\n    value: function unapply(matrix) {\n      var centerPointMatrix = _matrix.default.identity(3);\n\n      centerPointMatrix.translate(this._centerPoint.x, this._centerPoint.y);\n      matrix.multiplyBy(centerPointMatrix.inverse); // console.log('matrix1 %o', this.matrix.toString());\n\n      matrix.multiplyBy(this.matrix.inverse); // console.log('matrix2 %o', this.matrix.toString());\n\n      matrix.multiplyBy(centerPointMatrix);\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this._centerPoint.x = 0;\n      this._centerPoint.y = 0;\n    }\n    /* jshint ignore:start */\n\n  }, {\n    key: \"centerPoint\",\n    get: function get() {\n      return this._centerPoint;\n    }\n  }, {\n    key: \"inverse\",\n    get: function get() {\n      throw new Error(\"inverse not implemented for \".concat(this.constructor.name));\n    }\n  }], [{\n    key: \"from\",\n    value: function from(matrix) {\n      throw new Error(\"inverse not implemented for transform\");\n    }\n    /* jshint ignore:end */\n\n  }]);\n\n  return Transform;\n}();\n\nexports.default = Transform;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _matrix = _interopRequireDefault(__webpack_require__(0));\n\nvar _transform = _interopRequireDefault(__webpack_require__(2));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return _get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * The translate transform.\n * \n * @class TranslateTransform\n * @extends {Transform}\n */\nvar TranslateTransform =\n/*#__PURE__*/\nfunction (_Transform) {\n  _inherits(TranslateTransform, _Transform);\n\n  /**\n   * Creates an instance of TranslateTransform. It will translate a matrix by tx and ty.\n   * \n   * @param {any} tx The translate value in x.\n   * @param {any} ty The translate value in y.\n   * \n   * @memberOf TranslateTransform\n   */\n  function TranslateTransform() {\n    var _this;\n\n    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n    _classCallCheck(this, TranslateTransform);\n\n    _this = _possibleConstructorReturn(this, (TranslateTransform.__proto__ || Object.getPrototypeOf(TranslateTransform)).call(this));\n\n    _this.set(x, y);\n\n    return _this;\n  }\n\n  _createClass(TranslateTransform, [{\n    key: \"set\",\n    value: function set(x, y) {\n      this.x = x;\n      this.y = y;\n      this.matrix = new _matrix.default([[1, 0, x], [0, 1, y], [0, 0, 1]]);\n    }\n  }, {\n    key: \"update\",\n    value: function update(matrix) {\n      if (!(matrix instanceof _matrix.default)) {\n        throw new Error(\"matrix needs to be of type \".concat(_matrix.default.name));\n      }\n\n      var M = matrix; // http://math.stackexchange.com/questions/13150/extracting-rotation-scale-values-from-2d-transformation-matrix\n\n      var tx = M.tx;\n      var ty = M.ty;\n      this.set(tx, ty);\n    }\n    /**\n     * Reset translate transform.\n     * \n     * @memberOf TranslateTransform\n     */\n\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this.set(0, 0);\n\n      _get(TranslateTransform.prototype.__proto__ || Object.getPrototypeOf(TranslateTransform.prototype), \"reset\", this).call(this);\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"\".concat(this.constructor.name, \" [x=\").concat(this.x, \",y=\").concat(this.y, \"]\");\n    }\n  }, {\n    key: \"inverse\",\n    get: function get() {\n      return TranslateTransform.from(this.matrix.inverse);\n    }\n  }], [{\n    key: \"from\",\n    value: function from(matrix) {\n      var transform = new TranslateTransform();\n      transform.update(matrix);\n      return transform;\n    }\n  }]);\n\n  return TranslateTransform;\n}(_transform.default);\n\nexports.default = TranslateTransform;\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _matrix = _interopRequireDefault(__webpack_require__(0));\n\nvar _transform = _interopRequireDefault(__webpack_require__(2));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return _get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * The rotate transform.\n * \n * @class RotateTransform\n * @extends {Transform}\n */\nvar RotateTransform =\n/*#__PURE__*/\nfunction (_Transform) {\n  _inherits(RotateTransform, _Transform);\n\n  /**\n   * Creates an instance of RotateTransform. It will rotate a matrix by an angle [in degrees].\n   * \n   * @param {any} deg The rotate value in degrees.\n   * \n   * @memberOf RotateTransform\n   */\n  function RotateTransform() {\n    var _this;\n\n    var angle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n    _classCallCheck(this, RotateTransform);\n\n    _this = _possibleConstructorReturn(this, (RotateTransform.__proto__ || Object.getPrototypeOf(RotateTransform)).call(this));\n\n    _this.set(angle);\n\n    return _this;\n  }\n\n  _createClass(RotateTransform, [{\n    key: \"set\",\n    value: function set(angle) {\n      this.angle = angle;\n      var rad = angle * (Math.PI / 180);\n      var costheta = Math.cos(rad);\n      var sintheta = Math.sin(rad);\n      this.matrix = new _matrix.default([[costheta, -sintheta, 0], [sintheta, costheta, 0], [0, 0, 1]]);\n    }\n  }, {\n    key: \"update\",\n    value: function update(matrix) {\n      if (!(matrix instanceof _matrix.default)) {\n        throw new Error(\"matrix needs to be of type \".concat(_matrix.default.name));\n      }\n\n      var M = matrix; // http://math.stackexchange.com/questions/13150/extracting-rotation-scale-values-from-2d-transformation-matrix\n      // const psi1 = Math.atan2(-M.b, M.a);\n      // const psi2 = Math.atan2(M.c, M.d);\n      // if (psi1 !== psi2) {\n      //     throw new Error(`matrix error ${psi1} !== ${psi2}`);\n      // }\n      // const angle = (psi2 * 180) / Math.PI;\n\n      var rad = Math.atan2(M.b, M.a);\n      var angle = rad * 180 / Math.PI;\n      this.set(angle);\n    }\n    /**\n     * Reset rotate transform.\n     * \n     * @memberOf RotateTransform\n     */\n\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this.set(0);\n\n      _get(RotateTransform.prototype.__proto__ || Object.getPrototypeOf(RotateTransform.prototype), \"reset\", this).call(this);\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"\".concat(this.constructor.name, \" [angle=\").concat(this.angle, \"]\");\n    }\n  }, {\n    key: \"inverse\",\n    get: function get() {\n      return RotateTransform.from(this.matrix.inverse);\n    }\n  }], [{\n    key: \"from\",\n    value: function from(matrix) {\n      var transform = new RotateTransform();\n      transform.update(matrix);\n      return transform;\n    }\n  }]);\n\n  return RotateTransform;\n}(_transform.default);\n\nexports.default = RotateTransform;\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _matrix = _interopRequireDefault(__webpack_require__(0));\n\nvar _transform = _interopRequireDefault(__webpack_require__(2));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return _get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * The scale transform.\n * \n * @class ScaleTransform\n * @extends {Transform}\n */\nvar ScaleTransform =\n/*#__PURE__*/\nfunction (_Transform) {\n  _inherits(ScaleTransform, _Transform);\n\n  /**\n   * Creates an instance of ScaleTransform. It will scale a matrix by x and y.\n   * \n   * @param {any} x The scale factor in x.\n   * @param {any} y The scale factor in y.\n   * \n   * @memberOf ScaleTransform\n   */\n  function ScaleTransform() {\n    var _this;\n\n    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1.0;\n    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1.0;\n\n    _classCallCheck(this, ScaleTransform);\n\n    _this = _possibleConstructorReturn(this, (ScaleTransform.__proto__ || Object.getPrototypeOf(ScaleTransform)).call(this));\n\n    _this.set(x, y);\n\n    return _this;\n  }\n\n  _createClass(ScaleTransform, [{\n    key: \"set\",\n    value: function set(x, y) {\n      this.x = x;\n      this.y = y;\n      this.matrix = new _matrix.default([[x, 0, 0], [0, y, 0], [0, 0, 1]]);\n    }\n  }, {\n    key: \"update\",\n    value: function update(matrix) {\n      if (!(matrix instanceof _matrix.default)) {\n        throw new Error(\"matrix needs to be of type \".concat(_matrix.default.name));\n      }\n\n      var M = matrix; // http://math.stackexchange.com/questions/13150/extracting-rotation-scale-values-from-2d-transformation-matrix\n      // const sx = Math.sign(M.a) * Math.sqrt(Math.pow(M.a, 2) + Math.pow(M.b, 2));\n      // const sy = Math.sign(M.d) * Math.sqrt(Math.pow(M.c, 2) + Math.pow(M.d, 2));\n\n      var sx = Math.sqrt(Math.pow(M.a, 2) + Math.pow(M.b, 2));\n      var sy = Math.sqrt(Math.pow(M.c, 2) + Math.pow(M.d, 2));\n      this.set(sx, sy);\n    }\n    /**\n     * Reset scale transform.\n     * \n     * @memberOf ScaleTransform\n     */\n\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this.set(1, 1);\n\n      _get(ScaleTransform.prototype.__proto__ || Object.getPrototypeOf(ScaleTransform.prototype), \"reset\", this).call(this);\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"\".concat(this.constructor.name, \" [x=\").concat(this.x, \",y=\").concat(this.y, \"]\");\n    }\n  }, {\n    key: \"inverse\",\n    get: function get() {\n      return ScaleTransform.from(this.matrix.inverse);\n    }\n  }], [{\n    key: \"from\",\n    value: function from(matrix) {\n      var transform = new ScaleTransform();\n      transform.update(matrix);\n      return transform;\n    }\n  }]);\n\n  return ScaleTransform;\n}(_transform.default);\n\nexports.default = ScaleTransform;\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _transform = _interopRequireDefault(__webpack_require__(2));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * The transform group can hold multiple transform of type TranslateTransform, RotateTransform,\n * ScaleTransform, or even another TransformGroup. When the apply function is called, it will apply all\n * added transform in the exact order in which they have been added to the transform group. The unapply\n * function will unapply all transform in the reverse order in which they have been added to the\n * transform group.\n * \n * @class TransformGroup\n * @extends {Transform}\n */\nvar TransformGroup =\n/*#__PURE__*/\nfunction (_Transform) {\n  _inherits(TransformGroup, _Transform);\n\n  /**\n   * Creates an instance of TransformGroup.\n   * \n   * @memberOf TransformGroup\n   */\n  function TransformGroup() {\n    var _this;\n\n    _classCallCheck(this, TransformGroup);\n\n    _this = _possibleConstructorReturn(this, (TransformGroup.__proto__ || Object.getPrototypeOf(TransformGroup)).call(this));\n    _this.transforms = [];\n    return _this;\n  }\n  /**\n   * Add a transform (e.g., TranslateTransform, RotateTransform, or ScaleTransform) to the transform\n   * group. All transforms will be applied in the order they were added to the transform group. If a\n   * transform group is unapplied, it will unapply all transforms in reverse order.\n   * \n   * @param {Transform} transform A transform of type Transform (e.g., TranslateTransform, RotateTransform,\n   * or ScaleTransform). Eventually, a TransformGroup can also be added.\n   * \n   * @throws {Error} Throws an error if transform is not of type Transform.\n   * \n   * @memberOf TransformGroup\n   */\n\n\n  _createClass(TransformGroup, [{\n    key: \"add\",\n    value: function add(transform) {\n      var inverse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      // Check if transform is of proper type.\n      if (!(transform instanceof _transform.default)) {\n        throw new Error(\"transform needs to be of type \".concat(_transform.default.name));\n      } // Add transform to transforms.\n\n\n      this.transforms.push({\n        inverse: inverse,\n        transform: transform\n      });\n    }\n    /**\n     * Remove a transform from this transform group. The transform has to be part of the transform group,\n     * otherwise an error will be thrown.\n     * \n     * @param {Transform} transform\n     * \n     * @throws {Error} Throws an error if transform is not of type Transform and if transform is not part\n     * of transform group.\n     * \n     * @memberOf TransformGroup\n     */\n\n  }, {\n    key: \"remove\",\n    value: function remove(transform) {\n      // Check if transform is of proper type.\n      if (!(transform instanceof _transform.default)) {\n        throw new Error(\"transform needs to be of type \".concat(_transform.default.name));\n      } // Check if transform is part of transform group.\n\n\n      if (!this.transforms.contains(transform)) {\n        throw new Error(\"transform is not part of this transform group\");\n      } // Remove transform from transform group.\n\n\n      var idx = this.transforms.indexOf(transform);\n      this.transforms.splice(idx, 1);\n    }\n    /**\n     * Applies all transforms in the order in which they have been added to this transform group. The\n     * TransformGroup#apply function is specified in Transform ({@see Transform#apply}).\n     * \n     * @param {any} matrix The matrix to which transforms are applied.\n     * \n     * @memberOf TransformGroup\n     */\n\n  }, {\n    key: \"apply\",\n    value: function apply(matrix) {\n      var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      // Apply each transform to the matrix.\n      this.transforms.forEach(function (_ref) {\n        var transform = _ref.transform,\n            inverse = _ref.inverse;\n\n        if (type && !(transform instanceof type) && !(transform instanceof TransformGroup)) {\n          return;\n        } // console.log('apply inverse=%o transform=%o', inverse, transform.toString());\n\n\n        inverse ? transform.unapply(matrix, type) : transform.apply(matrix, type);\n      });\n    }\n    /**\n     * Unapplies all transforms in reverse order in which they have been added to this transform group. The\n     * TransformGroup#unapply function is specified in Transform ({@see Transform#unapply}).\n     * \n     * @param {any} matrix The matrix from which the transforms are unapplied.\n     * \n     * @memberOf TransformGroup\n     */\n\n  }, {\n    key: \"unapply\",\n    value: function unapply(matrix) {\n      var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      // Unapply each transform from the matrix in reverse order.\n      this.transforms.slice().reverse().forEach(function (_ref2) {\n        var transform = _ref2.transform,\n            inverse = _ref2.inverse;\n\n        if (type && !(transform instanceof type) && !(transform instanceof TransformGroup)) {\n          return;\n        } // console.log('unapply inverse=%o transform=%o', inverse, transform.toString());\n\n\n        inverse ? transform.apply(matrix, type) : transform.unapply(matrix, type);\n      });\n    }\n    /**\n     * Reset transform group.\n     * \n     * @memberOf TransformGroup\n     */\n\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this.transforms.forEach(function (_ref3) {\n        var transform = _ref3.transform;\n        transform.reset();\n      });\n    }\n    /**\n     * Transform group to string.\n     * \n     * @returns Transform group in string representation.\n     * \n     * @memberOf TransformGroup\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"\".concat(this.constructor.name, \" [transforms=[\").concat(this.transforms.map(function (_ref4) {\n        var transform = _ref4.transform,\n            inverse = _ref4.inverse;\n        return inverse ? transform.inverse.toString() : transform.toString();\n      }).join(\", \"), \"]]\");\n    }\n  }]);\n\n  return TransformGroup;\n}(_transform.default);\n\nexports.default = TransformGroup;\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _point = _interopRequireDefault(__webpack_require__(1));\n\nvar _matrix = _interopRequireDefault(__webpack_require__(0));\n\nvar _translateTransform = _interopRequireDefault(__webpack_require__(3));\n\nvar _rotateTransform = _interopRequireDefault(__webpack_require__(4));\n\nvar _scaleTransform = _interopRequireDefault(__webpack_require__(5));\n\nvar _transformGroup = _interopRequireDefault(__webpack_require__(6));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * The transform stack builds the base object responsible for transforming a DOM element. It takes an\n * element as constructor parameter and binds itself to this element. The transform stack allows push\n * and pop of transforms. A transform is immediately applied on the element and poping will immediately\n * unapply the transform from the element.\n * \n * @class Transformer\n */\nvar Transformer =\n/*#__PURE__*/\nfunction () {\n  _createClass(Transformer, null, [{\n    key: \"version\",\n\n    /**\n     * @private\n     * @const {string}\n     */\n    get: function get() {\n      return '{{PKG_VERSION}}';\n    }\n  }]);\n\n  /**\n   * Creates an instance of Transformer. It takes a DOM element as contstructor parameter to which\n   * this transform stack will bind itself. The transform stack will receive the elements current \n   * transform as matrix, which will be used to apply transforms.\n   * \n   * @param {any} element A DOM element to which transforms will be applied. \n   * \n   * @memberOf Transformer\n   */\n  function Transformer(element, callback) {\n    var debug = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n    _classCallCheck(this, Transformer);\n\n    // Element needs to be in DOM to get its clientWidth and clientHeight.\n    if (!element.parentElement) {\n      throw new Error(\"Element has no parent element. Is the element in the DOM?\");\n    } // Check if callback is set and if it is a function.\n\n\n    if (callback && typeof callback !== \"function\") {\n      throw new Error(\"callback needs to be a function\");\n    }\n\n    this.element = element;\n    this.element.transformer = this;\n    this.callback = callback;\n    this.updateInProgress = false;\n    var matrix = this.getTransformMatrix();\n    this._scaleTransform = _scaleTransform.default.from(matrix);\n    this._rotateTransform = _rotateTransform.default.from(matrix);\n    this._translateTransform = _translateTransform.default.from(matrix);\n    var transformGroup = new _transformGroup.default();\n    transformGroup.add(this._rotateTransform);\n    transformGroup.add(this._scaleTransform);\n    transformGroup.add(this._translateTransform);\n    this._transforms = transformGroup;\n\n    if (debug) {\n      var visualTransformOrigin = this.element.querySelector(':scope > .transform-origin-point');\n\n      if (!visualTransformOrigin) {\n        // Create visual transform origin\n        visualTransformOrigin = document.createElement(\"transient\");\n        visualTransformOrigin.setAttribute(\"class\", \"transform-origin-point\"); // append debug element as first child of element\n\n        element.insertBefore(visualTransformOrigin, element.firstElementChild);\n      }\n    }\n  }\n  /**\n   * Get transform matrix from element transform.\n   * \n   * @returns Element transform matrix.\n   * \n   * @memberOf Transformer\n   */\n\n\n  _createClass(Transformer, [{\n    key: \"getTransformMatrix\",\n    value: function getTransformMatrix() {\n      return _matrix.default.from(this.element);\n    }\n    /**\n     * Refresh transfroms from element transform.\n     * \n     * @memberOf Transformer\n     */\n\n  }, {\n    key: \"refreshTransforms\",\n    value: function refreshTransforms() {\n      var matrix = this.getTransformMatrix();\n\n      this._translateTransform.update(matrix);\n\n      this._rotateTransform.update(matrix);\n\n      this._scaleTransform.update(matrix);\n    }\n    /**\n     * Reapplies all transforms again. This function should be used when any of the transforms in the transform\n     * chain changed.\n     * \n     * @memberOf TransformStack\n     */\n\n  }, {\n    key: \"reapplyTransforms\",\n    value: function reapplyTransforms() {\n      var updateElementsTransform = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n      var matrix = _matrix.default.identity(3);\n\n      if (this.element.renderTransform) {\n        this.element.renderTransform.apply(matrix);\n      }\n\n      this._transforms.apply(matrix);\n\n      this.elementMatrix = matrix;\n\n      if (updateElementsTransform) {\n        // Update element transform.\n        return this.updateElement();\n      } else {\n        return new Promise(function (resolve, reject) {\n          resolve();\n        });\n      }\n    }\n    /**\n     * Merge render transform to main transform and reset\n     * render transform on success.\n     * \n     * @memberOf Transformer\n     */\n\n  }, {\n    key: \"complete\",\n    value: function complete() {\n      if (this.element.renderTransform) {\n        this.refreshTransforms();\n        this.element.renderTransform.reset();\n      }\n    }\n    /**\n     * Updates the element's transform matrix.\n     * \n     * @returns A promise resolved when element updated successfully.\n     * \n     * @memberOf TransformStack\n     */\n\n  }, {\n    key: \"updateElement\",\n    value: function updateElement() {\n      var _this = this;\n\n      return new Promise(function (resolve, reject) {\n        if (_this.updateInProgress) {\n          // reject(`update already in progress`);\n          // resolve(this.elementMatrix);\n          return;\n        }\n\n        window.requestAnimationFrame(function () {\n          var updateElementTransform = function updateElementTransform() {\n            var elementTransform = _this.elementMatrix.toCss();\n\n            _this.setCssTransform(elementTransform);\n          };\n\n          if (typeof _this.callback === 'function') {\n            if (_this.callback.call(_this, _this.elementMatrix)) {\n              updateElementTransform();\n            }\n          } else {\n            updateElementTransform();\n          }\n\n          _this.updateInProgress = false;\n          resolve(_this.elementMatrix);\n        });\n        _this.updateInProgress = true;\n      });\n    }\n    /**\n     * Sets the element's transform also compensating for various vendor prefixes.\n     * \n     * @param {any} cssTansform The CSS transform.\n     * \n     * @memberOf TransformStack\n     */\n\n  }, {\n    key: \"setCssTransform\",\n    value: function setCssTransform(cssTransform) {\n      // Make sure the element is positioned absolute and its origin is at point (0, 0, 0).\n      this.element.style.position = \"absolute\";\n      this.element.style.transformOrigin = \"0 0 0\";\n\n      if (this.element instanceof SVGElement) {\n        cssTransform === \"none\" ? this.element.removeAttribute(\"transform\") : this.element.setAttribute(\"transform\", cssTransform);\n      } else if (this.element.nodeType === 1) {\n        this.element.style.webkitTransform = cssTransform;\n        this.element.style.mozTransform = cssTransform;\n        this.element.style.msTransform = cssTransform;\n        this.element.style.oTransform = cssTransform;\n        this.element.style.transform = cssTransform;\n      }\n    }\n    /**\n     * tbd.\n     * \n     * @returns\n     * \n     * @memberOf Transformer\n     */\n\n  }, {\n    key: \"getTransformHierarchy\",\n    value: function getTransformHierarchy() {\n      var allTransformers = []; // Also collect transforms of parents.\n\n      var parent = this.element;\n\n      do {\n        if (parent.transformer) {\n          allTransformers.push({\n            transformer: parent.transformer,\n            renderTransform: parent.renderTransform\n          });\n        }\n      } while ((parent = parent.parentElement) !== null); // Reverse transform order to start with root transform.\n\n\n      allTransformers.reverse();\n      return allTransformers;\n    }\n    /**\n     * tbd.\n     * \n     * @returns\n     *\n     * @memberOf Transformer\n     */\n\n  }, {\n    key: \"getAncesterElementWithoutTransformer\",\n    value: function getAncesterElementWithoutTransformer() {\n      var parent = this.element;\n\n      do {\n        if (!parent.transformer) {\n          return parent;\n        }\n      } while ((parent = parent.parentElement) !== null);\n\n      return window.document.body;\n    }\n    /**\n     * tbd.\n     * \n     * @param {any} m\n     * \n     * @memberOf Transformer\n     */\n\n  }, {\n    key: \"applyToLocalTransform\",\n    value: function applyToLocalTransform(m) {\n      var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n      this._transforms.apply(m, type);\n\n      if (this.element.renderTransform) {\n        this.element.renderTransform.apply(m, type);\n      }\n    }\n    /**\n     * tbd.\n     * \n     * @param {any} m\n     * \n     * @memberOf Transformer\n     */\n\n  }, {\n    key: \"applyToGlobalTransform\",\n    value: function applyToGlobalTransform(m) {\n      var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var allTransformers = this.getTransformHierarchy();\n      allTransformers.forEach(function (_ref) {\n        var transformer = _ref.transformer,\n            renderTransform = _ref.renderTransform;\n\n        // Undo main transforms.\n        if (transformer) {\n          transformer._transforms.unapply(m, type);\n        } // Undo render transforms.\n\n\n        if (renderTransform) {\n          renderTransform.unapply(m, type);\n        }\n      });\n    }\n    /**\n     * tbd.\n     * \n     * @param {any} m\n     * \n     * @memberOf Transformer\n     */\n\n  }, {\n    key: \"unapplyFromGlobalTransform\",\n    value: function unapplyFromGlobalTransform(m) {\n      var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var allTransformers = this.getTransformHierarchy();\n      allTransformers.forEach(function (_ref2) {\n        var transformer = _ref2.transformer,\n            renderTransform = _ref2.renderTransform;\n\n        // Apply render transforms.\n        if (renderTransform) {\n          renderTransform.apply(m, type);\n        } // Apply main transforms.\n\n\n        if (transformer) {\n          transformer._transforms.apply(m, type);\n        }\n      });\n    }\n    /**\n     * Converts a point from global coordinates to local coordinates.\n     * \n     * @param {Point} point The point with global x- and y-coordinates.\n     * @returns The point with local x- and y-coordinates.\n     * \n     * @memberOf TransformStack\n     */\n\n  }, {\n    key: \"fromGlobalToLocal\",\n    value: function fromGlobalToLocal(point) {\n      if (!(point instanceof _point.default)) {\n        throw new Error(\"point needs to be of instance \".concat(_point.default.name));\n      } // adjust x and y according to ancestor element offset\n\n\n      var ancestor = this.getAncesterElementWithoutTransformer();\n\n      var _ancestor$getBounding = ancestor.getBoundingClientRect(),\n          left = _ancestor$getBounding.left,\n          top = _ancestor$getBounding.top;\n\n      var x = left ? point.x - left : point.x;\n      var y = top ? point.y - top : point.y;\n\n      var m = _matrix.default.identity(3);\n\n      m.translate(x, y);\n      this.applyToGlobalTransform(m);\n      return new _point.default(m.tx, m.ty);\n    }\n    /**\n     * Converts a point from local coordinates to global coordinates.\n     * \n     * @param {any} point The point with local x- and y-coordinates.\n     * @returns The point with global x- and y-coordinates.\n     * \n     * @memberOf TransformStack\n     */\n\n  }, {\n    key: \"fromLocalToGlobal\",\n    value: function fromLocalToGlobal(point) {\n      if (!(point instanceof _point.default)) {\n        throw new Error(\"point needs to be of instance \".concat(_point.default.name));\n      }\n\n      var m = _matrix.default.identity(3);\n\n      m.translate(point.x, point.y);\n      this.unapplyFromGlobalTransform(m); // adjust x and y according to ancestor element offset\n\n      var ancestor = this.getAncesterElementWithoutTransformer();\n\n      var _ancestor$getBounding2 = ancestor.getBoundingClientRect(),\n          left = _ancestor$getBounding2.left,\n          top = _ancestor$getBounding2.top;\n\n      var x = left ? m.tx + left : m.tx;\n      var y = top ? m.ty + top : m.ty;\n      return new _point.default(x, y);\n    }\n    /**\n     * Converts a delta point from global coordinates to local coordinates.\n     * \n     * @param {any} point The delta point with global x- and y-coordinates.\n     * @returns The delta point with local x- and y-coordinates.\n     * \n     * @memberOf TransformStack\n     * \n     * @see TransformStack#fromGlobalToLocal\n     */\n\n  }, {\n    key: \"fromGlobalToLocalDelta\",\n    value: function fromGlobalToLocalDelta(deltaPoint) {\n      if (!(deltaPoint instanceof _point.default)) {\n        throw new Error(\"delta point needs to be of instance \".concat(_point.default.name));\n      }\n\n      var allTransforms = this.getTransformHierarchy();\n\n      var m = _matrix.default.identity(3);\n\n      m.translate(deltaPoint.x, deltaPoint.y);\n      allTransforms.forEach(function (_ref3) {\n        var transformer = _ref3.transformer,\n            renderTransform = _ref3.renderTransform;\n\n        // Undo main transforms.\n        if (transformer) {\n          transformer._transforms.unapply(m, _scaleTransform.default);\n\n          transformer._transforms.unapply(m, _rotateTransform.default);\n        }\n      });\n      return new _point.default(m.tx, m.ty);\n    }\n    /**\n     * tbd.\n     * \n     * @readonly\n     * \n     * @memberOf Transformer\n     */\n\n  }, {\n    key: \"destroy\",\n\n    /**\n     * tbd.\n     * \n     * @memberOf Transformer\n     */\n    value: function destroy() {\n      delete this._scaleTransform;\n      delete this._rotateTransform;\n      delete this._translateTransform;\n      delete this._transforms;\n    }\n  }, {\n    key: \"localRotation\",\n    get: function get() {\n      var m = _matrix.default.identity(3);\n\n      this.applyToLocalTransform(m, _rotateTransform.default);\n      return m.angle;\n    }\n    /**\n     * tbd.\n     * \n     * @readonly\n     * \n     * @memberOf Transformer\n     */\n\n  }, {\n    key: \"globalRotation\",\n    get: function get() {\n      var m = _matrix.default.identity(3);\n\n      this.applyToGlobalTransform(m, _rotateTransform.default);\n      return m.angle;\n    }\n    /**\n     * tbd.\n     * \n     * @readonly\n     * \n     * @memberOf Transformer\n     */\n\n  }, {\n    key: \"localScale\",\n    get: function get() {\n      var m = _matrix.default.identity(3);\n\n      this.applyToLocalTransform(m, _scaleTransform.default);\n      return new _point.default(m.scaleX, m.scaleY);\n    }\n    /**\n     * tbd.\n     * \n     * @readonly\n     * \n     * @memberOf Transformer\n     */\n\n  }, {\n    key: \"globalScale\",\n    get: function get() {\n      var m = _matrix.default.identity(3);\n\n      this.applyToGlobalTransform(m, _scaleTransform.default);\n      return new _point.default(m.scaleX, m.scaleY);\n    }\n    /**\n     * tbd.\n     * \n     * @readonly\n     * \n     * @memberOf Transformer\n     */\n\n  }, {\n    key: \"globalScaleTest\",\n    get: function get() {\n      var m = _matrix.default.identity(3);\n\n      m.scale(1, 1);\n      var allTransformers = []; // Also collect transforms of parents.\n\n      var parent = this.element;\n\n      do {\n        if (parent.transformer) {\n          allTransformers.push({\n            transformer: parent.transformer,\n            renderTransform: parent.renderTransform\n          });\n        }\n      } while ((parent = parent.parentElement) !== null); // Apply all transforms in reverse order.\n\n\n      allTransformers.reverse().forEach(function (_ref4) {\n        var transformer = _ref4.transformer,\n            renderTransform = _ref4.renderTransform;\n\n        // Undo main transforms.\n        if (transformer) {\n          transformer._transforms.apply(m, _scaleTransform.default);\n        } // Undo render transforms.\n\n\n        if (renderTransform) {\n          renderTransform.apply(m, _scaleTransform.default);\n        }\n      });\n      var scaleX = m.a;\n      var scaleY = m.d;\n      return new _point.default(scaleX, scaleY);\n    }\n  }]);\n\n  return Transformer;\n}();\n\nexports.default = Transformer;\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.bind = void 0;\n\nvar _transformer = _interopRequireDefault(__webpack_require__(7));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar bind = function bind(element, callback, debug) {\n  // check for Promise support\n  if (!(\"Promise\" in window)) {\n    throw new Error(\"transformer.js requires Promise\");\n  }\n\n  return new Promise(function (resolve, reject) {\n    // return immediately if element already has transformer object\n    if (element.transformer) {\n      return resolve(element.transformer);\n    } // create transformer in next tick to make sure that all styles have been applied to\n    // the receiving element, e.g., wait till width and height of the element are set\n    // correctly\n\n\n    setTimeout(function () {\n      var transformer = new _transformer.default(element, callback, debug);\n      transformer.reapplyTransforms().then(function () {\n        resolve(transformer);\n      });\n    }, 0);\n  });\n};\n\nexports.bind = bind;\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"Point\", {\n  enumerable: true,\n  get: function get() {\n    return _point.default;\n  }\n});\nObject.defineProperty(exports, \"Matrix\", {\n  enumerable: true,\n  get: function get() {\n    return _matrix.default;\n  }\n});\nObject.defineProperty(exports, \"TranslateTransform\", {\n  enumerable: true,\n  get: function get() {\n    return _translateTransform.default;\n  }\n});\nObject.defineProperty(exports, \"RotateTransform\", {\n  enumerable: true,\n  get: function get() {\n    return _rotateTransform.default;\n  }\n});\nObject.defineProperty(exports, \"ScaleTransform\", {\n  enumerable: true,\n  get: function get() {\n    return _scaleTransform.default;\n  }\n});\nObject.defineProperty(exports, \"TransformGroup\", {\n  enumerable: true,\n  get: function get() {\n    return _transformGroup.default;\n  }\n});\nObject.defineProperty(exports, \"bind\", {\n  enumerable: true,\n  get: function get() {\n    return _bind.bind;\n  }\n});\nObject.defineProperty(exports, \"hammerize\", {\n  enumerable: true,\n  get: function get() {\n    return _hammerize.hammerize;\n  }\n});\n\nvar _point = _interopRequireDefault(__webpack_require__(1));\n\nvar _matrix = _interopRequireDefault(__webpack_require__(0));\n\nvar _translateTransform = _interopRequireDefault(__webpack_require__(3));\n\nvar _rotateTransform = _interopRequireDefault(__webpack_require__(4));\n\nvar _scaleTransform = _interopRequireDefault(__webpack_require__(5));\n\nvar _transformGroup = _interopRequireDefault(__webpack_require__(6));\n\nvar _transformer = _interopRequireDefault(__webpack_require__(7));\n\nvar _bind = __webpack_require__(8);\n\nvar _hammerize = __webpack_require__(10);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.hammerize = void 0;\n\nvar _point = _interopRequireDefault(__webpack_require__(1));\n\nvar _translateTransform = _interopRequireDefault(__webpack_require__(3));\n\nvar _rotateTransform = _interopRequireDefault(__webpack_require__(4));\n\nvar _scaleTransform = _interopRequireDefault(__webpack_require__(5));\n\nvar _transformGroup = _interopRequireDefault(__webpack_require__(6));\n\nvar _bind = __webpack_require__(8);\n\nvar _hammerjs = _interopRequireDefault(__webpack_require__(11));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar hammerize = function hammerize(obj, options) {\n  return new Promise(function (resolve, reject) {\n    var Hammer = window.Hammer;\n    options = Object.assign({\n      pan: true,\n      rotate: true,\n      pinch: true,\n      callback: undefined,\n      enabled: true,\n      // boolean or function that returns boolean\n      debug: false\n    }, options);\n    (0, _bind.bind)(obj, options.callback, options.debug).then(function (transformer) {\n      // // Alternatively, the transformer API binds the transformer object to the element.\n      // const transformer = obj.transformer;\n      var hammerManager = new Hammer.Manager(obj); // override destroy function to also destroy hammer manager\n\n      var _destroy = transformer.destroy;\n\n      transformer.destroy = function () {\n        hammerManager.destroy();\n\n        _destroy.call(this);\n      }; // Details on hammer.js can be found here: http://hammerjs.github.io\n\n\n      hammerManager.add(new Hammer.Pan({\n        threshold: 0,\n        pointers: 0\n      }));\n      hammerManager.add(new Hammer.Rotate({\n        threshold: 0\n      })).recognizeWith(hammerManager.get('pan'));\n      hammerManager.add(new Hammer.Pinch({\n        threshold: 0\n      })).recognizeWith([hammerManager.get('pan'), hammerManager.get('rotate')]); // Create custom render transform for element.\n      // !!! Changing any of this code or re-order will effect rendering of element after manipulation.\n\n      var renderTransform = new _transformGroup.default();\n      var scaleTransform = obj.scaleTransform = new _scaleTransform.default();\n      var rotateTransform = obj.rotateTransform = new _rotateTransform.default();\n      var translateTransform = obj.translateTransform = new _translateTransform.default();\n      renderTransform.add(scaleTransform);\n      renderTransform.add(rotateTransform);\n      renderTransform.add(translateTransform);\n      obj.renderTransform = renderTransform;\n      /**\n       * Returns true if interactions should be allowed, otherwise false.\n       */\n\n      var isEnabled = function isEnabled() {\n        if (typeof options.enabled === 'function') {\n          return options.enabled.call(transformer);\n        }\n\n        return options.enabled;\n      };\n      /**\n       * Check if event is a valid event.\n       *\n       * @param {any} event\n       * @returns\n       */\n\n\n      var isValidEvent = function isValidEvent(event) {\n        var parent = event.target;\n\n        do {\n          if (parent.transformer) {\n            return parent === obj;\n          }\n        } while ((parent = parent.parentElement) !== null);\n\n        return false;\n      }; // Consume event, so it does not get further propagated.\n\n\n      var consumeEvent = function consumeEvent(event) {\n        event.srcEvent.stopPropagation();\n      }; // The center point, which is returned by hammer.js, is in screen coordinates. The following function\n      // will transform these screen coordinates to canvas coordinates and with respect to an element's transform\n      // and if necessary according to an element's transform hierarchy.\n\n\n      var adjustCenterPoint = function adjustCenterPoint(point) {\n        var p = new _point.default(point.x, point.y);\n        return obj.transformer.fromGlobalToLocal(p);\n      }; // Temporary variables.\n\n\n      var prevPoint = {\n        x: 0,\n        y: 0\n      };\n      var prevScale = 1.0;\n      var angleOffset = 0;\n      var prevAngle = 0;\n      hammerManager.on(\"hammer.input\", function (event) {\n        if (!isEnabled()) return;\n        if (!isValidEvent(event)) return;\n        consumeEvent(event);\n\n        if (event.isFinal) {\n          transformer.complete();\n        }\n      }); // pan handler\n\n      hammerManager.on('panstart panmove', function (event) {\n        if (!isEnabled()) return;\n        if (!options.pan) return;\n\n        if (event.type === \"panstart\") {\n          prevPoint.x = 0;\n          prevPoint.y = 0;\n          return;\n        }\n\n        var deltaPoint = new _point.default(event.deltaX, event.deltaY);\n        deltaPoint = transformer.fromGlobalToLocalDelta(deltaPoint);\n        var newX = translateTransform.x - prevPoint.x + deltaPoint.x;\n        var newY = translateTransform.y - prevPoint.y + deltaPoint.y;\n        translateTransform.set(newX, newY);\n        transformer.reapplyTransforms(); // update previous point for next panmove\n\n        prevPoint.x = deltaPoint.x;\n        prevPoint.y = deltaPoint.y;\n      }); // rotate handler\n\n      hammerManager.on(\"rotatestart rotatemove\", function (event) {\n        if (!isEnabled()) return;\n        if (!options.rotate) return;\n\n        if (event.type === \"rotatestart\") {\n          angleOffset = event.rotation;\n          prevAngle = 0;\n          var centerPoint = adjustCenterPoint(event.center);\n          rotateTransform.centerPoint.x = centerPoint.x;\n          rotateTransform.centerPoint.y = centerPoint.y;\n          return;\n        } // correct angle offset\n\n\n        event.rotation -= angleOffset;\n        var deltaAngle = rotateTransform.angle - prevAngle + event.rotation;\n        prevAngle = event.rotation;\n        rotateTransform.set(deltaAngle);\n        transformer.reapplyTransforms();\n      }); // scale handler\n\n      hammerManager.on(\"pinchstart pinchmove\", function (event) {\n        if (!isEnabled()) return;\n        if (!options.pinch) return;\n\n        if (event.type === \"pinchstart\") {\n          prevScale = event.scale;\n          var centerPoint = adjustCenterPoint(event.center);\n          scaleTransform.centerPoint.x = centerPoint.x;\n          scaleTransform.centerPoint.y = centerPoint.y;\n          return;\n        }\n\n        var scaleX = scaleTransform.x / prevScale * event.scale;\n        var scaleY = scaleTransform.y / prevScale * event.scale;\n        prevScale = event.scale;\n        scaleTransform.set(scaleX, scaleY);\n        transformer.reapplyTransforms();\n      });\n      var mouseWheelManipulated = false; // This is a workaround to complete last transform started by a mousewheel interaction.\n\n      obj.addEventListener(\"mousemove\", function () {\n        if (mouseWheelManipulated) {\n          transformer.complete();\n          mouseWheelManipulated = false;\n        }\n      }); // Also allow object manipulation using mousewheel interaction. Hold down the ctrl key to\n      // scale an element and hold down the alt/option key to rotate an element.\n\n      obj.addEventListener(\"mousewheel\", function (event) {\n        if (!isEnabled()) return;\n        event.preventDefault();\n        event.stopPropagation();\n        event.stopImmediatePropagation();\n        mouseWheelManipulated = true; // Normalize wheel to +1 or -1.\n\n        var wheel = event.wheelDelta / 120; // Manipulation factor.\n\n        var manipulationFactor = Math.exp(wheel * 0.02); // Adjust translate transform to fit zoom point.\n\n        var centerPoint = {\n          x: event.clientX,\n          y: event.clientY\n        };\n        centerPoint = adjustCenterPoint(centerPoint);\n\n        if (event.ctrlKey) {\n          if (!options.rotate) return;\n          var deltaAngle = -(manipulationFactor - 1) * 50;\n          var angle = (rotateTransform.angle - deltaAngle) % 360;\n          rotateTransform.set(angle);\n          rotateTransform.centerPoint.x = centerPoint.x;\n          rotateTransform.centerPoint.y = centerPoint.y;\n          transformer.reapplyTransforms();\n          return;\n        }\n\n        if (!options.pinch) return;\n        var newScale = scaleTransform.x * manipulationFactor;\n        scaleTransform.set(newScale, newScale);\n        scaleTransform.centerPoint.x = centerPoint.x;\n        scaleTransform.centerPoint.y = centerPoint.y;\n        transformer.reapplyTransforms();\n      }, false); // return modified transformer\n\n      resolve(transformer);\n    });\n  });\n};\n\nexports.hammerize = hammerize;\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports) {\n\n(function() { module.exports = window[\"hammerjs\"]; }());\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// transformer.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 9);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 6a0a827eb8ecc1c115ca","/**\n * The matrix class provides convenient functions for affine transformations, e.g., translate, rotate,\n * and scale. It also offers functions like matrix multiplication or creating an inverse matrix.\n * \n * @class Matrix\n */\nexport default class Matrix {\n\n    /**\n     * Creates an instance of Matrix. The matrix needs to be a two-dimensional array. The first index will\n     * be rows and the second index will be columns. The array needs to be in a n x m format. For example,\n     * an array [[1, 2, 3], [4, 5, 6], [7, 8 ,9]] will result in the following matrix:\n     * \n     * 1   2   3\n     * 4   5   6\n     * 7   8   9\n     * \n     * @param {any} M A two-dimensional array.\n     * \n     * @memberOf Matrix\n     */\n    constructor(M) {\n\n        if (typeof M === 'undefined' || !Array.isArray(M)) {\n            throw new Error(`first parameter needs to be a two-dimensional array`);\n        }\n        this.matrix = M;\n    }\n\n    /**\n     * Sets the matrix. The matrix needs to be a two-dimensional array. The first index will be rows and\n     * the second index will be columns. The array needs to be in a n x m format.\n     * \n     * @memberOf Matrix\n     */\n    set matrix(matrix) {\n        this._matrix = matrix;\n        this._rows = matrix.length;\n        this._columns = matrix[0].length;\n    }\n\n    /**\n     * Returns the matrix as a two-dimensional array.\n     * \n     * @memberOf Matrix\n     */\n    get matrix() {\n        return this._matrix;\n    }\n\n    /**\n     * Returns number of rows of matrix.\n     * \n     * @readonly\n     * \n     * @memberOf Matrix\n     */\n    get rows() {\n        return this._rows;\n    }\n\n    /**\n     * Returns number of columns of matrix.\n     * \n     * @readonly\n     * \n     * @memberOf Matrix\n     */\n    get columns() {\n        return this._columns;\n    }\n\n    get a() {\n        return this.matrix[0][0];\n    }\n\n    get b() {\n        return this.matrix[1][0];\n    }\n\n    get c() {\n        return this.matrix[0][1];\n    }\n\n    get d() {\n        return this.matrix[1][1];\n    }\n\n    get tx() {\n        return this.matrix[0][2];\n    }\n\n    get ty() {\n        return this.matrix[1][2];\n    }\n\n    get angle() {\n        const rad = Math.atan2(this.b, this.a);\n        return (rad * 180) / Math.PI;\n    }\n\n    get scaleX() {\n        return this.a;\n    }\n\n    get scaleY() {\n        return this.d;\n    }\n\n    /**\n     * Translates the matrix by tx and ty.\n     * \n     * @param {Number} tx The translation value in x.\n     * @param {Number} ty The translation value in y.\n     * \n     * @memberOf Matrix\n     */\n    translate(tx, ty, truncate = true) {\n        const M = this.multiply(new Matrix([\n            [1, 0, tx],\n            [0, 1, ty],\n            [0, 0, 1],\n        ]), truncate).matrix;\n\n        this.matrix = M;\n    }\n\n    /**\n     * Rotates the matrix by angle. The rotation value has to be in degrees.\n     * \n     * @param {Number} angle The rotation value in degrees.\n     * \n     * @memberOf Matrix\n     */\n    rotate(angle, truncate = true) {\n        const rad = angle * (Math.PI / 180);\n        const costheta = Math.cos(rad);\n        const sintheta = Math.sin(rad);\n\n        const M = this.multiply(new Matrix([\n            [costheta, -sintheta, 0],\n            [sintheta, costheta, 0],\n            [0, 0, 1],\n        ]), truncate).matrix;\n\n        this.matrix = M;\n    }\n\n    /**\n     * Scales the matrix by sx and sy.\n     * \n     * @param {Number} sx The scale value in x.\n     * @param {Number} sy The scale value in y.\n     * \n     * @memberOf Matrix\n     */\n    scale(sx, sy, truncate = true) {\n        const M = this.multiply(new Matrix([\n            [sx, 0, 0],\n            [0, sy, 0],\n            [0, 0, 1],\n        ]), truncate).matrix;\n\n        this.matrix = M;\n    }\n\n    /**\n     * Skwes the matrix in degX and degY.\n     * \n     * @param {Number} degX The skew value in x in degrees.\n     * @param {Number} degY The skew value in y in degrees.\n     * \n     * @memberOf Matrix\n     */\n    skew(degX, degY, truncate = true) {\n        const radX = degX * (Math.PI / 180);\n        const radY = degY * (Math.PI / 180);\n        const x = Math.tan(radX);\n        const y = Math.tan(radY);\n\n        const M = this.multiply(new Matrix([\n            [1, x, 0],\n            [y, 1, 0],\n            [0, 0, 1],\n        ]), truncate).matrix;\n\n        this.matrix = M;\n    }\n\n    /**\n     * Multiplies a given matrix with this matrix and returns the result as new matrix instance. In order\n     * to perform the matrix multiplication, rows of matrix M1 need to match columns of matrix M2 as well\n     * as columns of matrix M1 need to match rows of matrix M2.\n     * \n     * @param {any} M The matrix used to multiply with this matrix.\n     * @returns The multipied matrix.\n     * \n     * @memberOf Matrix\n     */\n    multiply(M, truncate = true) {\n\n        if (this.rows !== M.columns || this.columns !== M.rows) {\n            throw new Error(`cannot multiply because matrix dimensions do not match (n*m !== m*n)`);\n        }\n\n        const m = [];\n        const m1 = this.matrix;\n        const m2 = M.matrix;\n        for (let i = 0; i < m1.length; i++) {\n            m[i] = [];\n            for (let j = 0; j < m2[0].length; j++) {\n                let sum = 0;\n                for (let k = 0; k < m1[0].length; k++) {\n                    sum += m1[i][k] * m2[k][j];\n                }\n                // m[i][j] = sum;\n                m[i][j] = truncate ? parseFloat(sum.toFixed(3)) : sum;\n            }\n        }\n\n        return new Matrix(m);\n    }\n\n    /**\n     * Multiplies this matrix by the given matrix and replaces this matrix by the resulting matrix.\n     * \n     * @param {any} The matrix used to multiply with this matrix.\n     * \n     * @memberOf Matrix\n     */\n    multiplyBy(M) {\n        // const m = this.multiply(M).matrix;\n        const m = M.multiply(this).matrix;\n        this.matrix = m;\n    }\n\n    /**\n     * Creates a copy of the matrix.\n     * \n     * @returns The copy of this matrix.\n     * \n     * @memberOf Matrix\n     */\n    copy() {\n        const m = this.matrix;\n        const copyM = JSON.parse(JSON.stringify(m));\n        return new Matrix(copyM);\n    }\n\n    /**\n     * Returns the inverse matrix of this matrix.\n     * \n     * http://blog.acipo.com/matrix-inversion-in-javascript/\n     * \n     * @readonly\n     * \n     * @memberOf Matrix\n     */\n    get inverse() {\n        // I use Guassian Elimination to calculate the inverse:\n        // (1) 'augment' the matrix (left) by the identity (on the right)\n        // (2) Turn the matrix on the left into the identity by elemetry row ops\n        // (3) The matrix on the right is the inverse (was the identity matrix)\n        // There are 3 elemtary row ops: (I combine b and c in my code)\n        // (a) Swap 2 rows\n        // (b) Multiply a row by a scalar\n        // (c) Add 2 rows\n\n        const M = this.matrix;\n\n        //if the matrix isn't square: exit (error)\n        if (M.length !== M[0].length) {\n            throw new Error(`matrix is not squared`);\n        }\n\n        //create the identity matrix (I), and a copy (C) of the original\n        var i = 0,\n            ii = 0,\n            j = 0,\n            dim = M.length,\n            e = 0;\n            // t = 0;\n        var I = [],\n            C = [];\n        for (i = 0; i < dim; i += 1) {\n            // Create the row\n            I[I.length] = [];\n            C[C.length] = [];\n            for (j = 0; j < dim; j += 1) {\n\n                //if we're on the diagonal, put a 1 (for identity)\n                if (i == j) {\n                    I[i][j] = 1;\n                } else {\n                    I[i][j] = 0;\n                }\n\n                // Also, make the copy of the original\n                C[i][j] = M[i][j];\n            }\n        }\n\n        // Perform elementary row operations\n        for (i = 0; i < dim; i += 1) {\n            // get the element e on the diagonal\n            e = C[i][i];\n\n            // if we have a 0 on the diagonal (we'll need to swap with a lower row)\n            if (e == 0) {\n                //look through every row below the i'th row\n                for (ii = i + 1; ii < dim; ii += 1) {\n                    //if the ii'th row has a non-0 in the i'th col\n                    if (C[ii][i] != 0) {\n                        //it would make the diagonal have a non-0 so swap it\n                        for (j = 0; j < dim; j++) {\n                            e = C[i][j]; //temp store i'th row\n                            C[i][j] = C[ii][j]; //replace i'th row by ii'th\n                            C[ii][j] = e; //repace ii'th by temp\n                            e = I[i][j]; //temp store i'th row\n                            I[i][j] = I[ii][j]; //replace i'th row by ii'th\n                            I[ii][j] = e; //repace ii'th by temp\n                        }\n                        //don't bother checking other rows since we've swapped\n                        break;\n                    }\n                }\n                //get the new diagonal\n                e = C[i][i];\n                //if it's still 0, not invertable (error)\n                if (e == 0) {\n                    throw new Error(`matrix is not invertable`);\n                }\n            }\n\n            // Scale this row down by e (so we have a 1 on the diagonal)\n            for (j = 0; j < dim; j++) {\n                C[i][j] = C[i][j] / e; //apply to original matrix\n                I[i][j] = I[i][j] / e; //apply to identity\n            }\n\n            // Subtract this row (scaled appropriately for each row) from ALL of\n            // the other rows so that there will be 0's in this column in the\n            // rows above and below this one\n            for (ii = 0; ii < dim; ii++) {\n                // Only apply to other rows (we want a 1 on the diagonal)\n                if (ii == i) {\n                    continue;\n                }\n\n                // We want to change this element to 0\n                e = C[ii][i];\n\n                // Subtract (the row above(or below) scaled by e) from (the\n                // current row) but start at the i'th column and assume all the\n                // stuff left of diagonal is 0 (which it should be if we made this\n                // algorithm correctly)\n                for (j = 0; j < dim; j++) {\n                    C[ii][j] -= e * C[i][j]; //apply to original matrix\n                    I[ii][j] -= e * I[i][j]; //apply to identity\n                }\n            }\n        }\n\n        //we've done all operations, C should be the identity\n        //matrix I should be the inverse:\n        return new Matrix(I);\n    }\n\n    toJSON() {\n        return JSON.stringify(this.matrix);\n    }\n\n    static fromJSON(json) {\n        const matrix = JSON.parse(json);\n        return new Matrix(matrix);\n    }\n\n    /**\n     * Converts the matrix to a CSS matrix transform. It respects whether the matrix should be a\n     * CSS matrix() or CSS matrix3d().\n     * \n     * @returns The CSS transform.\n     * \n     * @memberOf Matrix\n     */\n    toCss(fixed = true) {\n\n        const M = this.matrix;\n\n        const getFixedValue = (row, column) => {\n            if (fixed) {\n                return parseFloat(M[row][column].toFixed(3));\n            }\n            return M[row][column];\n        };\n\n        if (this.rows === 3 && this.columns === 3) {\n            if (this.equals(Matrix.identity(3))) {\n                return \"none\";\n            }\n\n            const a = getFixedValue(0, 0);\n            const b = getFixedValue(1, 0);\n            const c = getFixedValue(0, 1);\n            const d = getFixedValue(1, 1);\n            const tx = getFixedValue(0, 2);\n            const ty = getFixedValue(1, 2);\n\n            return `matrix(${a}, ${b}, ${c}, ${d}, ${tx}, ${ty})`;\n        }\n\n        if (this.equals(Matrix.identity(4))) {\n            return \"none\";\n        }\n\n        const a1 = getFixedValue(0, 0);\n        const b1 = getFixedValue(1, 0);\n        const c1 = getFixedValue(2, 0);\n        const d1 = getFixedValue(3, 0);\n        const a2 = getFixedValue(0, 1);\n        const b2 = getFixedValue(1, 1);\n        const c2 = getFixedValue(2, 1);\n        const d2 = getFixedValue(3, 1);\n        const a3 = getFixedValue(0, 2);\n        const b3 = getFixedValue(1, 2);\n        const c3 = getFixedValue(2, 2);\n        const d3 = getFixedValue(3, 2);\n        const a4 = getFixedValue(0, 3);\n        const b4 = getFixedValue(1, 3);\n        const c4 = getFixedValue(2, 3);\n        const d4 = getFixedValue(3, 3);\n\n        return `matrix3d(${a1}, ${b1}, ${c1}, ${d1}, ${a2}, ${b2}, ${c2}, ${d2}, ${a3}, ${b3}, ${c3}, ${d3}, ${a4}, ${b4}, ${c4}, ${d4})`;\n    }\n\n    /**\n     * Returns true if matrix M equals to this matrix.\n     * \n     * @param {any} M A matrix to compare to.\n     * @returns True if this matrix and matrix M are equal.\n     * \n     * @memberOf Matrix\n     */\n    equals(M) {\n        return Matrix.equals(this, M);\n    }\n\n    /**\n     * Returns true if both matrix have the same matrix values, false otherwise.\n     * \n     * @static\n     * @param {any} M1 Matrix 1.\n     * @param {any} M2 Matrix 2.\n     * @returns True if matrix M1 and M2 are equal.\n     * \n     * @memberOf Matrix\n     */\n    static equals(M1, M2) {\n        return JSON.stringify(M1.matrix) === JSON.stringify(M2.matrix);\n    }\n\n    /**\n     * Creates an n x n identity matrix.\n     * \n     * @static\n     * @param {any} n The number of rows and columns to create this n x n identity matrix.\n     * @returns The identity matrix.\n     * \n     * @memberOf Matrix\n     */\n    static identity(n) {\n\n        let m = [];\n        for (let row = 0; row < n; row++) {\n            let mRow = m[row] = [];\n\n            for (let col = 0; col < n; col++) {\n                mRow[col] = col === row ? 1 : 0;\n            }\n        }\n\n        return new Matrix(m);\n    }\n\n    /**\n     * Creates a matrix from a DOM element (e.g., a HTMLElement or a SVGElement).\n     * \n     * @static\n     * @param {any} element A DOM element from which the matrix is created from.\n     * @returns The matrix.\n     * \n     * @memberOf Matrix\n     */\n    static from(element) {\n\n        let rawTransform = \"none\";\n\n        if (element instanceof SVGElement) {\n            rawTransform = element.getAttribute(\"transform\");\n\n            // SAFARI does not return a proper transform with window.getComputedStyle for SVGElement.\n            // TODO This is a nasty workaround.\n            if (!rawTransform || rawTransform === \"\") {\n                rawTransform = element.style.transform;\n            }\n        } else if (element.nodeType === 1) {\n            rawTransform = window.getComputedStyle(element).transform;\n        }\n\n        if (rawTransform === \"\" || rawTransform === \"none\") {\n            return Matrix.identity(3);\n        } else {\n            const regEx = /([-+]?[\\d\\.]+)/g;\n\n            // console.log('rawTransform %o', rawTransform);\n\n            if (rawTransform.indexOf(\"matrix3d\") > -1) {\n                // throw new Error(`matrix3d transformation not yet supported`);\n\n                // https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/matrix3d\n                const a1 = parseFloat(regEx.exec(rawTransform)[0]);\n                const b1 = parseFloat(regEx.exec(rawTransform)[0]);\n                const c1 = parseFloat(regEx.exec(rawTransform)[0]);\n                const d1 = parseFloat(regEx.exec(rawTransform)[0]);\n                const a2 = parseFloat(regEx.exec(rawTransform)[0]);\n                const b2 = parseFloat(regEx.exec(rawTransform)[0]);\n                const c2 = parseFloat(regEx.exec(rawTransform)[0]);\n                const d2 = parseFloat(regEx.exec(rawTransform)[0]);\n                const a3 = parseFloat(regEx.exec(rawTransform)[0]);\n                const b3 = parseFloat(regEx.exec(rawTransform)[0]);\n                const c3 = parseFloat(regEx.exec(rawTransform)[0]);\n                const d3 = parseFloat(regEx.exec(rawTransform)[0]);\n                const a4 = parseFloat(regEx.exec(rawTransform)[0]);\n                const b4 = parseFloat(regEx.exec(rawTransform)[0]);\n                const c4 = parseFloat(regEx.exec(rawTransform)[0]);\n                const d4 = parseFloat(regEx.exec(rawTransform)[0]);\n\n                return new Matrix([\n                    [a1, a2, a3, a4],\n                    [b1, b2, b3, b4],\n                    [c1, c2, c3, c4],\n                    [d1, d2, d3, d4]\n                ]);\n            } else {\n\n                // https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/matrix\n                const a = parseFloat(regEx.exec(rawTransform)[0]);\n                const b = parseFloat(regEx.exec(rawTransform)[0]);\n                const c = parseFloat(regEx.exec(rawTransform)[0]);\n                const d = parseFloat(regEx.exec(rawTransform)[0]);\n                const tx = parseFloat(regEx.exec(rawTransform)[0]);\n                const ty = parseFloat(regEx.exec(rawTransform)[0]);\n\n                return new Matrix([\n                    [a, c, tx],\n                    [b, d, ty],\n                    [0, 0, 1]\n                ]);\n            }\n        }\n    }\n\n    /**\n     * Returns the matrix in a human readable format. \n     * \n     * @returns The matrix in string format.\n     * \n     * @memberOf Matrix\n     */\n    toString() {\n        return `Matrix [rows=${this.rows},columns=${this.columns},matrix=${JSON.stringify(this.matrix)}]`;\n    }\n}\n\n\n// WEBPACK FOOTER //\n// ./src/utils/matrix.js","/**\n * A simple point class.\n * \n * @class Point\n */\nexport default class Point {\n\n    /**\n     * Creates an instance of Point.\n     * \n     * @param {any} x The x value.\n     * @param {any} y The y value.\n     * \n     * @memberOf Point\n     */\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    /**\n     * Returns the string representation of the point.\n     * \n     * @returns The string representation of the point.\n     * \n     * @memberOf Point\n     */\n    toString() {\n        return `${Point.name} [x=${this.x},y=${this.y}]`;\n    }\n}\n\n\n// WEBPACK FOOTER //\n// ./src/utils/point.js","import Point from '../utils/point';\nimport Matrix from '../utils/matrix';\n\n/**\n * The base class for a transforms.\n * \n * @class Transform\n */\nexport default class Transform {\n\n    /**\n     * Creates an instance of Transform. It will create an instance with a default identity matrix.\n     * \n     * @memberOf Transform\n     */\n    constructor() {\n        this.matrix = Matrix.identity(3);\n        this._centerPoint = new Point(0, 0);\n    }\n\n    get centerPoint() {\n        return this._centerPoint;\n    }\n\n    /**\n     * Applies this transform to the matrix given as parameter.\n     * \n     * @param {any} matrix The matrix to which this transform will be applied.\n     * \n     * @memberOf Transform\n     */\n    apply(matrix) {\n        const centerPointMatrix = Matrix.identity(3);\n        centerPointMatrix.translate(this._centerPoint.x, this._centerPoint.y);\n\n        matrix.multiplyBy(centerPointMatrix.inverse);\n        matrix.multiplyBy(this.matrix);\n        matrix.multiplyBy(centerPointMatrix);\n    }\n\n    /**\n     * Unapplies this transformation from the matrix given as paramter.\n     * \n     * @param {any} matrix The matrix from which this transform will be unapplied.\n     * \n     * @memberOf Transform\n     */\n    unapply(matrix) {\n        const centerPointMatrix = Matrix.identity(3);\n        centerPointMatrix.translate(this._centerPoint.x, this._centerPoint.y);\n\n        matrix.multiplyBy(centerPointMatrix.inverse);\n        // console.log('matrix1 %o', this.matrix.toString());\n        matrix.multiplyBy(this.matrix.inverse);\n        // console.log('matrix2 %o', this.matrix.toString());\n        matrix.multiplyBy(centerPointMatrix);\n    }\n\n    get inverse() {\n        throw new Error(`inverse not implemented for ${this.constructor.name}`);\n    }\n\n    reset() {\n        this._centerPoint.x = 0;\n        this._centerPoint.y = 0;\n    }\n\n    /* jshint ignore:start */\n    static from(matrix) {\n        throw new Error(`inverse not implemented for transform`);\n    }\n    /* jshint ignore:end */\n}\n\n\n// WEBPACK FOOTER //\n// ./src/transforms/transform.js","import Matrix from '../utils/matrix';\nimport Transform from './transform';\n\n/**\n * The translate transform.\n * \n * @class TranslateTransform\n * @extends {Transform}\n */\nexport default class TranslateTransform extends Transform {\n\n    /**\n     * Creates an instance of TranslateTransform. It will translate a matrix by tx and ty.\n     * \n     * @param {any} tx The translate value in x.\n     * @param {any} ty The translate value in y.\n     * \n     * @memberOf TranslateTransform\n     */\n    constructor(x = 0, y = 0) {\n        super();\n        this.set(x, y);\n    }\n\n    set(x, y) {\n        this.x = x;\n        this.y = y;\n\n        this.matrix = new Matrix([\n            [1, 0, x],\n            [0, 1, y],\n            [0, 0, 1]\n        ]);\n    }\n\n    get inverse() {\n        return TranslateTransform.from(this.matrix.inverse);\n    }\n\n    update(matrix) {\n\n        if (!(matrix instanceof Matrix)) {\n            throw new Error(`matrix needs to be of type ${Matrix.name}`);\n        }\n\n        const M = matrix;\n\n        // http://math.stackexchange.com/questions/13150/extracting-rotation-scale-values-from-2d-transformation-matrix\n        const tx = M.tx;\n        const ty = M.ty;\n\n        this.set(tx, ty);\n    }\n\n    /**\n     * Reset translate transform.\n     * \n     * @memberOf TranslateTransform\n     */\n    reset() {\n        this.set(0, 0);\n        super.reset();\n    }\n\n    static from(matrix) {\n        const transform = new TranslateTransform();\n        transform.update(matrix);\n        return transform;\n    }\n\n    toString() {\n        return `${this.constructor.name} [x=${this.x},y=${this.y}]`;\n    }\n}\n\n\n// WEBPACK FOOTER //\n// ./src/transforms/translate-transform.js","import Matrix from '../utils/matrix';\nimport Transform from './transform';\n\n/**\n * The rotate transform.\n * \n * @class RotateTransform\n * @extends {Transform}\n */\nexport default class RotateTransform extends Transform {\n\n    /**\n     * Creates an instance of RotateTransform. It will rotate a matrix by an angle [in degrees].\n     * \n     * @param {any} deg The rotate value in degrees.\n     * \n     * @memberOf RotateTransform\n     */\n    constructor(angle = 0) {\n        super();\n        this.set(angle);\n    }\n\n    set(angle) {\n        this.angle = angle;\n\n        const rad = angle * (Math.PI / 180);\n        const costheta = Math.cos(rad);\n        const sintheta = Math.sin(rad);\n\n        this.matrix = new Matrix([\n            [costheta, -sintheta, 0],\n            [sintheta, costheta, 0],\n            [0, 0, 1]\n        ]);\n    }\n\n    get inverse() {\n        return RotateTransform.from(this.matrix.inverse);\n    }\n\n    update(matrix) {\n\n        if (!(matrix instanceof Matrix)) {\n            throw new Error(`matrix needs to be of type ${Matrix.name}`);\n        }\n\n        const M = matrix;\n\n        // http://math.stackexchange.com/questions/13150/extracting-rotation-scale-values-from-2d-transformation-matrix\n        // const psi1 = Math.atan2(-M.b, M.a);\n        // const psi2 = Math.atan2(M.c, M.d);\n\n        // if (psi1 !== psi2) {\n        //     throw new Error(`matrix error ${psi1} !== ${psi2}`);\n        // }\n\n        // const angle = (psi2 * 180) / Math.PI;\n\n        const rad = Math.atan2(M.b, M.a);\n        const angle = (rad * 180) / Math.PI;\n\n        this.set(angle);\n    }\n\n    /**\n     * Reset rotate transform.\n     * \n     * @memberOf RotateTransform\n     */\n    reset() {\n        this.set(0);\n        super.reset();\n    }\n\n    static from(matrix) {\n        const transform = new RotateTransform();\n        transform.update(matrix);\n        return transform;\n    }\n\n    toString() {\n        return `${this.constructor.name} [angle=${this.angle}]`;\n    }\n}\n\n\n// WEBPACK FOOTER //\n// ./src/transforms/rotate-transform.js","import Matrix from '../utils/matrix';\nimport Transform from './transform';\n\n/**\n * The scale transform.\n * \n * @class ScaleTransform\n * @extends {Transform}\n */\nexport default class ScaleTransform extends Transform {\n\n    /**\n     * Creates an instance of ScaleTransform. It will scale a matrix by x and y.\n     * \n     * @param {any} x The scale factor in x.\n     * @param {any} y The scale factor in y.\n     * \n     * @memberOf ScaleTransform\n     */\n    constructor(x = 1.0, y = 1.0) {\n        super();\n        this.set(x, y);\n    }\n\n    set(x, y) {\n        this.x = x;\n        this.y = y;\n\n        this.matrix = new Matrix([\n            [x, 0, 0],\n            [0, y, 0],\n            [0, 0, 1],\n        ]);\n    }\n\n    get inverse() {\n        return ScaleTransform.from(this.matrix.inverse);\n    }\n\n    update(matrix) {\n\n        if (!(matrix instanceof Matrix)) {\n            throw new Error(`matrix needs to be of type ${Matrix.name}`);\n        }\n\n        const M = matrix;\n\n        // http://math.stackexchange.com/questions/13150/extracting-rotation-scale-values-from-2d-transformation-matrix\n        // const sx = Math.sign(M.a) * Math.sqrt(Math.pow(M.a, 2) + Math.pow(M.b, 2));\n        // const sy = Math.sign(M.d) * Math.sqrt(Math.pow(M.c, 2) + Math.pow(M.d, 2));\n\n        const sx = Math.sqrt(Math.pow(M.a, 2) + Math.pow(M.b, 2));\n        const sy = Math.sqrt(Math.pow(M.c, 2) + Math.pow(M.d, 2));\n\n        this.set(sx, sy);\n    }\n\n    /**\n     * Reset scale transform.\n     * \n     * @memberOf ScaleTransform\n     */\n    reset() {\n        this.set(1, 1);\n        super.reset();\n    }\n\n    static from(matrix) {\n        const transform = new ScaleTransform();\n        transform.update(matrix);\n        return transform;\n    }\n\n    toString() {\n        return `${this.constructor.name} [x=${this.x},y=${this.y}]`;\n    }\n}\n\n\n// WEBPACK FOOTER //\n// ./src/transforms/scale-transform.js","import Transform from './transform';\n\n/**\n * The transform group can hold multiple transform of type TranslateTransform, RotateTransform,\n * ScaleTransform, or even another TransformGroup. When the apply function is called, it will apply all\n * added transform in the exact order in which they have been added to the transform group. The unapply\n * function will unapply all transform in the reverse order in which they have been added to the\n * transform group.\n * \n * @class TransformGroup\n * @extends {Transform}\n */\nexport default class TransformGroup extends Transform {\n\n    /**\n     * Creates an instance of TransformGroup.\n     * \n     * @memberOf TransformGroup\n     */\n    constructor() {\n        super();\n\n        this.transforms = [];\n    }\n\n    /**\n     * Add a transform (e.g., TranslateTransform, RotateTransform, or ScaleTransform) to the transform\n     * group. All transforms will be applied in the order they were added to the transform group. If a\n     * transform group is unapplied, it will unapply all transforms in reverse order.\n     * \n     * @param {Transform} transform A transform of type Transform (e.g., TranslateTransform, RotateTransform,\n     * or ScaleTransform). Eventually, a TransformGroup can also be added.\n     * \n     * @throws {Error} Throws an error if transform is not of type Transform.\n     * \n     * @memberOf TransformGroup\n     */\n    add(transform, inverse = false) {\n\n        // Check if transform is of proper type.\n        if (!(transform instanceof Transform)) {\n            throw new Error(`transform needs to be of type ${Transform.name}`);\n        }\n\n        // Add transform to transforms.\n        this.transforms.push({\n            inverse,\n            transform\n        });\n    }\n\n    /**\n     * Remove a transform from this transform group. The transform has to be part of the transform group,\n     * otherwise an error will be thrown.\n     * \n     * @param {Transform} transform\n     * \n     * @throws {Error} Throws an error if transform is not of type Transform and if transform is not part\n     * of transform group.\n     * \n     * @memberOf TransformGroup\n     */\n    remove(transform) {\n\n        // Check if transform is of proper type.\n        if (!(transform instanceof Transform)) {\n            throw new Error(`transform needs to be of type ${Transform.name}`);\n        }\n\n        // Check if transform is part of transform group.\n        if (!this.transforms.contains(transform)) {\n            throw new Error(`transform is not part of this transform group`);\n        }\n\n        // Remove transform from transform group.\n        const idx = this.transforms.indexOf(transform);\n        this.transforms.splice(idx, 1);\n    }\n\n    /**\n     * Applies all transforms in the order in which they have been added to this transform group. The\n     * TransformGroup#apply function is specified in Transform ({@see Transform#apply}).\n     * \n     * @param {any} matrix The matrix to which transforms are applied.\n     * \n     * @memberOf TransformGroup\n     */\n    apply(matrix, type = null) {\n\n        // Apply each transform to the matrix.\n        this.transforms.forEach(({\n          transform,\n            inverse\n        }) => {\n            if (type && !(transform instanceof type) && !(transform instanceof TransformGroup)) {\n                return;\n            }\n            // console.log('apply inverse=%o transform=%o', inverse, transform.toString());\n            inverse ? transform.unapply(matrix, type) : transform.apply(matrix, type);\n        });\n    }\n\n    /**\n     * Unapplies all transforms in reverse order in which they have been added to this transform group. The\n     * TransformGroup#unapply function is specified in Transform ({@see Transform#unapply}).\n     * \n     * @param {any} matrix The matrix from which the transforms are unapplied.\n     * \n     * @memberOf TransformGroup\n     */\n    unapply(matrix, type = null) {\n\n        // Unapply each transform from the matrix in reverse order.\n        this.transforms.slice().reverse().forEach(({\n          transform,\n            inverse\n        }) => {\n            if (type && !(transform instanceof type) && !(transform instanceof TransformGroup)) {\n                return;\n            }\n            // console.log('unapply inverse=%o transform=%o', inverse, transform.toString());\n            inverse ? transform.apply(matrix, type) : transform.unapply(matrix, type);\n        });\n    }\n\n    /**\n     * Reset transform group.\n     * \n     * @memberOf TransformGroup\n     */\n    reset() {\n        this.transforms.forEach(({\n          transform\n        }) => {\n            transform.reset();\n        });\n    }\n\n    /**\n     * Transform group to string.\n     * \n     * @returns Transform group in string representation.\n     * \n     * @memberOf TransformGroup\n     */\n    toString() {\n        return `${this.constructor.name} [transforms=[${this.transforms.map(({ transform, inverse }) => {\n            return inverse ? transform.inverse.toString() : transform.toString();\n        }).join(\", \")}]]`;\n    }\n}\n\n\n// WEBPACK FOOTER //\n// ./src/transforms/transform-group.js","import Point from './utils/point';\nimport Matrix from './utils/matrix';\nimport TranslateTransform from './transforms/translate-transform';\nimport RotateTransform from './transforms/rotate-transform';\nimport ScaleTransform from './transforms/scale-transform';\nimport TransformGroup from './transforms/transform-group';\n\n/**\n * The transform stack builds the base object responsible for transforming a DOM element. It takes an\n * element as constructor parameter and binds itself to this element. The transform stack allows push\n * and pop of transforms. A transform is immediately applied on the element and poping will immediately\n * unapply the transform from the element.\n * \n * @class Transformer\n */\nexport default class Transformer {\n\n    /**\n     * @private\n     * @const {string}\n     */\n    static get version() {\n        return '{{PKG_VERSION}}';\n    };\n\n    /**\n     * Creates an instance of Transformer. It takes a DOM element as contstructor parameter to which\n     * this transform stack will bind itself. The transform stack will receive the elements current \n     * transform as matrix, which will be used to apply transforms.\n     * \n     * @param {any} element A DOM element to which transforms will be applied. \n     * \n     * @memberOf Transformer\n     */\n    constructor(element, callback, debug = false) {\n\n        // Element needs to be in DOM to get its clientWidth and clientHeight.\n        if (!element.parentElement) {\n            throw new Error(`Element has no parent element. Is the element in the DOM?`);\n        }\n\n        // Check if callback is set and if it is a function.\n        if (callback && typeof callback !== \"function\") {\n            throw new Error(`callback needs to be a function`);\n        }\n\n        this.element = element;\n        this.element.transformer = this;\n        this.callback = callback;\n        this.updateInProgress = false;\n\n        let matrix = this.getTransformMatrix();\n\n        this._scaleTransform = ScaleTransform.from(matrix);\n        this._rotateTransform = RotateTransform.from(matrix);\n        this._translateTransform = TranslateTransform.from(matrix);\n\n        const transformGroup = new TransformGroup();\n        transformGroup.add(this._rotateTransform);\n        transformGroup.add(this._scaleTransform);\n        transformGroup.add(this._translateTransform);\n\n        this._transforms = transformGroup;\n\n        if (debug) {\n\n            let visualTransformOrigin = this.element.querySelector(':scope > .transform-origin-point');\n\n            if (!visualTransformOrigin) {\n                // Create visual transform origin\n                visualTransformOrigin = document.createElement(\"transient\");\n                visualTransformOrigin.setAttribute(\"class\", \"transform-origin-point\");\n\n                // append debug element as first child of element\n                element.insertBefore(visualTransformOrigin, element.firstElementChild);\n            }\n        }\n    }\n\n    /**\n     * Get transform matrix from element transform.\n     * \n     * @returns Element transform matrix.\n     * \n     * @memberOf Transformer\n     */\n    getTransformMatrix() {\n        return Matrix.from(this.element);\n    }\n\n    /**\n     * Refresh transfroms from element transform.\n     * \n     * @memberOf Transformer\n     */\n    refreshTransforms() {\n        const matrix = this.getTransformMatrix();\n        this._translateTransform.update(matrix);\n        this._rotateTransform.update(matrix);\n        this._scaleTransform.update(matrix);\n    }\n\n    /**\n     * Reapplies all transforms again. This function should be used when any of the transforms in the transform\n     * chain changed.\n     * \n     * @memberOf TransformStack\n     */\n    reapplyTransforms(updateElementsTransform = true) {\n        let matrix = Matrix.identity(3);\n\n        if (this.element.renderTransform) {\n            this.element.renderTransform.apply(matrix);\n        }\n        this._transforms.apply(matrix);\n\n        this.elementMatrix = matrix;\n\n        if (updateElementsTransform) {\n            // Update element transform.\n            return this.updateElement();\n        } else {\n            return new Promise((resolve, reject) => {\n                resolve();\n            });\n        }\n    }\n\n    /**\n     * Merge render transform to main transform and reset\n     * render transform on success.\n     * \n     * @memberOf Transformer\n     */\n    complete() {\n        if (this.element.renderTransform) {\n            this.refreshTransforms();\n            this.element.renderTransform.reset();\n        }\n    }\n\n    /**\n     * Updates the element's transform matrix.\n     * \n     * @returns A promise resolved when element updated successfully.\n     * \n     * @memberOf TransformStack\n     */\n    updateElement() {\n\n        return new Promise((resolve, reject) => {\n\n            if (this.updateInProgress) {\n                // reject(`update already in progress`);\n                // resolve(this.elementMatrix);\n                return;\n            }\n\n            window.requestAnimationFrame(() => {\n\n                const updateElementTransform = () => {\n                    let elementTransform = this.elementMatrix.toCss();\n                    this.setCssTransform(elementTransform);\n                };\n\n                if (typeof this.callback === 'function') {\n                    if (this.callback.call(this, this.elementMatrix)) {\n                        updateElementTransform();\n                    }\n                } else {\n                    updateElementTransform();\n                }\n\n                this.updateInProgress = false;\n\n                resolve(this.elementMatrix);\n            });\n\n            this.updateInProgress = true;\n        });\n    }\n\n    /**\n     * Sets the element's transform also compensating for various vendor prefixes.\n     * \n     * @param {any} cssTansform The CSS transform.\n     * \n     * @memberOf TransformStack\n     */\n    setCssTransform(cssTransform) {\n\n        // Make sure the element is positioned absolute and its origin is at point (0, 0, 0).\n        this.element.style.position = \"absolute\";\n        this.element.style.transformOrigin = \"0 0 0\";\n\n        if (this.element instanceof SVGElement) {\n            cssTransform === \"none\" ? this.element.removeAttribute(\"transform\") : this.element.setAttribute(\"transform\", cssTransform);\n        } else if (this.element.nodeType === 1) {\n            this.element.style.webkitTransform = cssTransform;\n            this.element.style.mozTransform = cssTransform;\n            this.element.style.msTransform = cssTransform;\n            this.element.style.oTransform = cssTransform;\n            this.element.style.transform = cssTransform;\n        }\n    }\n\n    /**\n     * tbd.\n     * \n     * @returns\n     * \n     * @memberOf Transformer\n     */\n    getTransformHierarchy() {\n        const allTransformers = [];\n\n        // Also collect transforms of parents.\n        let parent = this.element;\n        do {\n            if (parent.transformer) {\n                allTransformers.push({\n                    transformer: parent.transformer,\n                    renderTransform: parent.renderTransform\n                });\n            }\n        }\n        while ((parent = parent.parentElement) !== null);\n\n        // Reverse transform order to start with root transform.\n        allTransformers.reverse();\n\n        return allTransformers;\n    }\n\n    /**\n     * tbd.\n     * \n     * @returns\n     *\n     * @memberOf Transformer\n     */\n    getAncesterElementWithoutTransformer() {\n        let parent = this.element;\n        do {\n            if (!parent.transformer) {\n                return parent;\n            }\n        }\n        while ((parent = parent.parentElement) !== null);\n\n        return window.document.body;\n    }\n\n    /**\n     * tbd.\n     * \n     * @param {any} m\n     * \n     * @memberOf Transformer\n     */\n    applyToLocalTransform(m, type = null) {\n        this._transforms.apply(m, type);\n\n        if (this.element.renderTransform) {\n            this.element.renderTransform.apply(m, type);\n        }\n    }\n\n    /**\n     * tbd.\n     * \n     * @param {any} m\n     * \n     * @memberOf Transformer\n     */\n    applyToGlobalTransform(m, type = null) {\n        const allTransformers = this.getTransformHierarchy();\n\n        allTransformers.forEach(({\n          transformer,\n            renderTransform\n        }) => {\n\n            // Undo main transforms.\n            if (transformer) {\n                transformer._transforms.unapply(m, type);\n            }\n\n            // Undo render transforms.\n            if (renderTransform) {\n                renderTransform.unapply(m, type);\n            }\n        });\n    }\n\n    /**\n     * tbd.\n     * \n     * @param {any} m\n     * \n     * @memberOf Transformer\n     */\n    unapplyFromGlobalTransform(m, type = null) {\n        const allTransformers = this.getTransformHierarchy();\n\n        allTransformers.forEach(({\n          transformer,\n            renderTransform\n        }) => {\n\n            // Apply render transforms.\n            if (renderTransform) {\n                renderTransform.apply(m, type);\n            }\n\n            // Apply main transforms.\n            if (transformer) {\n                transformer._transforms.apply(m, type);\n            }\n        });\n    }\n\n    /**\n     * Converts a point from global coordinates to local coordinates.\n     * \n     * @param {Point} point The point with global x- and y-coordinates.\n     * @returns The point with local x- and y-coordinates.\n     * \n     * @memberOf TransformStack\n     */\n    fromGlobalToLocal(point) {\n\n        if (!(point instanceof Point)) {\n            throw new Error(`point needs to be of instance ${Point.name}`);\n        }\n\n        // adjust x and y according to ancestor element offset\n        let ancestor = this.getAncesterElementWithoutTransformer();\n        let {\n          left,\n            top\n        } = ancestor.getBoundingClientRect();\n        let x = left ? point.x - left : point.x;\n        let y = top ? point.y - top : point.y;\n\n        let m = Matrix.identity(3);\n        m.translate(x, y);\n\n        this.applyToGlobalTransform(m);\n\n        return new Point(m.tx, m.ty);\n    }\n\n    /**\n     * Converts a point from local coordinates to global coordinates.\n     * \n     * @param {any} point The point with local x- and y-coordinates.\n     * @returns The point with global x- and y-coordinates.\n     * \n     * @memberOf TransformStack\n     */\n    fromLocalToGlobal(point) {\n\n        if (!(point instanceof Point)) {\n            throw new Error(`point needs to be of instance ${Point.name}`);\n        }\n\n        let m = Matrix.identity(3);\n        m.translate(point.x, point.y);\n\n        this.unapplyFromGlobalTransform(m);\n\n        // adjust x and y according to ancestor element offset\n        let ancestor = this.getAncesterElementWithoutTransformer();\n        let {\n          left,\n            top\n        } = ancestor.getBoundingClientRect();\n        let x = left ? m.tx + left : m.tx;\n        let y = top ? m.ty + top : m.ty;\n\n        return new Point(x, y);\n    }\n\n    /**\n     * Converts a delta point from global coordinates to local coordinates.\n     * \n     * @param {any} point The delta point with global x- and y-coordinates.\n     * @returns The delta point with local x- and y-coordinates.\n     * \n     * @memberOf TransformStack\n     * \n     * @see TransformStack#fromGlobalToLocal\n     */\n    fromGlobalToLocalDelta(deltaPoint) {\n\n        if (!(deltaPoint instanceof Point)) {\n            throw new Error(`delta point needs to be of instance ${Point.name}`);\n        }\n\n        const allTransforms = this.getTransformHierarchy();\n\n        let m = Matrix.identity(3);\n        m.translate(deltaPoint.x, deltaPoint.y);\n\n        allTransforms.forEach(({\n          transformer,\n            renderTransform\n        }) => {\n\n            // Undo main transforms.\n            if (transformer) {\n                transformer._transforms.unapply(m, ScaleTransform);\n                transformer._transforms.unapply(m, RotateTransform);\n            }\n        });\n\n        return new Point(m.tx, m.ty);\n    }\n\n    /**\n     * tbd.\n     * \n     * @readonly\n     * \n     * @memberOf Transformer\n     */\n    get localRotation() {\n        let m = Matrix.identity(3);\n        this.applyToLocalTransform(m, RotateTransform);\n        return m.angle;\n    }\n\n    /**\n     * tbd.\n     * \n     * @readonly\n     * \n     * @memberOf Transformer\n     */\n    get globalRotation() {\n        let m = Matrix.identity(3);\n        this.applyToGlobalTransform(m, RotateTransform);\n        return m.angle;\n    }\n\n    /**\n     * tbd.\n     * \n     * @readonly\n     * \n     * @memberOf Transformer\n     */\n    get localScale() {\n        let m = Matrix.identity(3);\n        this.applyToLocalTransform(m, ScaleTransform);\n        return new Point(m.scaleX, m.scaleY);\n    }\n\n    /**\n     * tbd.\n     * \n     * @readonly\n     * \n     * @memberOf Transformer\n     */\n    get globalScale() {\n        let m = Matrix.identity(3);\n        this.applyToGlobalTransform(m, ScaleTransform);\n        return new Point(m.scaleX, m.scaleY);\n    }\n\n    /**\n     * tbd.\n     * \n     * @readonly\n     * \n     * @memberOf Transformer\n     */\n    get globalScaleTest() {\n        let m = Matrix.identity(3);\n        m.scale(1, 1);\n\n        const allTransformers = [];\n\n        // Also collect transforms of parents.\n        let parent = this.element;\n        do {\n            if (parent.transformer) {\n                allTransformers.push({\n                    transformer: parent.transformer,\n                    renderTransform: parent.renderTransform\n                });\n            }\n        }\n        while ((parent = parent.parentElement) !== null);\n\n        // Apply all transforms in reverse order.\n        allTransformers.reverse().forEach(({\n          transformer,\n            renderTransform\n        }) => {\n\n            // Undo main transforms.\n            if (transformer) {\n                transformer._transforms.apply(m, ScaleTransform);\n            }\n\n            // Undo render transforms.\n            if (renderTransform) {\n                renderTransform.apply(m, ScaleTransform);\n            }\n        });\n\n        const scaleX = m.a;\n        const scaleY = m.d;\n\n        return new Point(scaleX, scaleY);\n    }\n\n    /**\n     * tbd.\n     * \n     * @memberOf Transformer\n     */\n    destroy() {\n        delete this._scaleTransform;\n        delete this._rotateTransform;\n        delete this._translateTransform;\n        delete this._transforms;\n    }\n}\n\n\n// WEBPACK FOOTER //\n// ./src/transformer.js","import Transformer from '../transformer';\n\nconst bind = (element, callback, debug) => {\n\n    // check for Promise support\n    if (!(\"Promise\" in window)) {\n        throw new Error(`transformer.js requires Promise`);\n    }\n\n    return new Promise((resolve, reject) => {\n\n        // return immediately if element already has transformer object\n        if (element.transformer) {\n            return resolve(element.transformer);\n        }\n\n        // create transformer in next tick to make sure that all styles have been applied to\n        // the receiving element, e.g., wait till width and height of the element are set\n        // correctly\n        setTimeout(() => {\n            const transformer = new Transformer(element, callback, debug);\n\n            transformer.reapplyTransforms().then(() => {\n                resolve(transformer);\n            });\n        }, 0);\n    });\n};\n\nexport { bind };\n\n\n// WEBPACK FOOTER //\n// ./src/extensions/bind.js","import Point from './utils/point';\nimport Matrix from './utils/matrix';\nimport TranslateTransform from './transforms/translate-transform';\nimport RotateTransform from './transforms/rotate-transform';\nimport ScaleTransform from './transforms/scale-transform';\nimport TransformGroup from './transforms/transform-group';\nimport Transformer from './transformer';\n\nimport { bind } from './extensions/bind';\nimport { hammerize } from './extensions/hammerize';\n\nexport {\n    // utils\n    Point,\n    Matrix,\n\n    // transforms\n    TranslateTransform,\n    RotateTransform,\n    ScaleTransform,\n    TransformGroup,\n\n    // extensions\n    bind,\n    hammerize\n};\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","import Point from '../utils/point';\nimport TranslateTransform from '../transforms/translate-transform';\nimport RotateTransform from '../transforms/rotate-transform';\nimport ScaleTransform from '../transforms/scale-transform';\nimport TransformGroup from '../transforms/transform-group';\n\nimport { bind } from './bind';\n\nimport Hammer from 'hammerjs';\n\nconst hammerize = (obj, options) => {\n\n    return new Promise((resolve, reject) => {\n\n        const Hammer = window.Hammer;\n\n        options = Object.assign({\n            pan: true,\n            rotate: true,\n            pinch: true,\n            callback: undefined,\n            enabled: true, // boolean or function that returns boolean\n            debug: false\n        }, options);\n\n        bind(obj, options.callback, options.debug).then((transformer) => {\n\n            // // Alternatively, the transformer API binds the transformer object to the element.\n            // const transformer = obj.transformer;\n\n            const hammerManager = new Hammer.Manager(obj);\n\n            // override destroy function to also destroy hammer manager\n            const _destroy = transformer.destroy;\n            transformer.destroy = function () {\n                hammerManager.destroy();\n                _destroy.call(this);\n            };\n\n            // Details on hammer.js can be found here: http://hammerjs.github.io\n            hammerManager.add(new Hammer.Pan({ threshold: 0, pointers: 0 }));\n            hammerManager.add(new Hammer.Rotate({ threshold: 0 })).recognizeWith(hammerManager.get('pan'));\n            hammerManager.add(new Hammer.Pinch({ threshold: 0 })).recognizeWith([hammerManager.get('pan'), hammerManager.get('rotate')]);\n\n            // Create custom render transform for element.\n            // !!! Changing any of this code or re-order will effect rendering of element after manipulation.\n            const renderTransform = new TransformGroup();\n            const scaleTransform = obj.scaleTransform = new ScaleTransform();\n            const rotateTransform = obj.rotateTransform = new RotateTransform();\n            const translateTransform = obj.translateTransform = new TranslateTransform();\n            renderTransform.add(scaleTransform);\n            renderTransform.add(rotateTransform);\n            renderTransform.add(translateTransform);\n            obj.renderTransform = renderTransform;\n\n            /**\n             * Returns true if interactions should be allowed, otherwise false.\n             */\n            const isEnabled = () => {\n                if (typeof options.enabled === 'function') {\n                    return options.enabled.call(transformer);\n                }\n                return options.enabled;\n            };\n\n            /**\n             * Check if event is a valid event.\n             *\n             * @param {any} event\n             * @returns\n             */\n            const isValidEvent = (event) => {\n                let parent = event.target;\n                do {\n                    if (parent.transformer) {\n                        return parent === obj;\n                    }\n                }\n                while ((parent = parent.parentElement) !== null);\n\n                return false;\n            };\n\n            // Consume event, so it does not get further propagated.\n            const consumeEvent = (event) => {\n                event.srcEvent.stopPropagation();\n            };\n\n            // The center point, which is returned by hammer.js, is in screen coordinates. The following function\n            // will transform these screen coordinates to canvas coordinates and with respect to an element's transform\n            // and if necessary according to an element's transform hierarchy.\n            const adjustCenterPoint = (point) => {\n                let p = new Point(point.x, point.y);\n                return obj.transformer.fromGlobalToLocal(p);\n            };\n\n            // Temporary variables.\n            let prevPoint = {\n                x: 0,\n                y: 0\n            };\n            let prevScale = 1.0;\n            let angleOffset = 0;\n            let prevAngle = 0;\n\n            hammerManager.on(\"hammer.input\", (event) => {\n                if (!isEnabled()) return;\n                if (!isValidEvent(event)) return;\n                consumeEvent(event);\n\n                if (event.isFinal) {\n                    transformer.complete();\n                }\n            });\n\n            // pan handler\n            hammerManager.on('panstart panmove', (event) => {\n                if (!isEnabled()) return;\n\n                if (!options.pan) return;\n\n                if (event.type === \"panstart\") {\n                    prevPoint.x = 0;\n                    prevPoint.y = 0;\n                    return;\n                }\n\n                let deltaPoint = new Point(event.deltaX, event.deltaY);\n                deltaPoint = transformer.fromGlobalToLocalDelta(deltaPoint);\n\n                const newX = (translateTransform.x - prevPoint.x) + deltaPoint.x;\n                const newY = (translateTransform.y - prevPoint.y) + deltaPoint.y;\n\n                translateTransform.set(newX, newY);\n                transformer.reapplyTransforms();\n\n                // update previous point for next panmove\n                prevPoint.x = deltaPoint.x;\n                prevPoint.y = deltaPoint.y;\n            });\n\n            // rotate handler\n            hammerManager.on(\"rotatestart rotatemove\", (event) => {\n                if (!isEnabled()) return;\n\n                if (!options.rotate) return;\n\n                if (event.type === \"rotatestart\") {\n                    angleOffset = event.rotation;\n                    prevAngle = 0;\n\n                    let centerPoint = adjustCenterPoint(event.center);\n                    rotateTransform.centerPoint.x = centerPoint.x;\n                    rotateTransform.centerPoint.y = centerPoint.y;\n\n                    return;\n                }\n\n                // correct angle offset\n                event.rotation -= angleOffset;\n\n                const deltaAngle = (rotateTransform.angle - prevAngle) + event.rotation;\n\n                prevAngle = event.rotation;\n\n                rotateTransform.set(deltaAngle);\n                transformer.reapplyTransforms();\n            });\n\n            // scale handler\n            hammerManager.on(\"pinchstart pinchmove\", (event) => {\n                if (!isEnabled()) return;\n\n                if (!options.pinch) return;\n\n                if (event.type === \"pinchstart\") {\n                    prevScale = event.scale;\n\n                    let centerPoint = adjustCenterPoint(event.center);\n                    scaleTransform.centerPoint.x = centerPoint.x;\n                    scaleTransform.centerPoint.y = centerPoint.y;\n\n                    return;\n                }\n\n                const scaleX = (scaleTransform.x / prevScale) * event.scale;\n                const scaleY = (scaleTransform.y / prevScale) * event.scale;\n\n                prevScale = event.scale;\n\n                scaleTransform.set(scaleX, scaleY);\n                transformer.reapplyTransforms();\n            });\n\n            let mouseWheelManipulated = false;\n\n            // This is a workaround to complete last transform started by a mousewheel interaction.\n            obj.addEventListener(\"mousemove\", () => {\n\n                if (mouseWheelManipulated) {\n                    transformer.complete();\n                    mouseWheelManipulated = false;\n                }\n            });\n\n            // Also allow object manipulation using mousewheel interaction. Hold down the ctrl key to\n            // scale an element and hold down the alt/option key to rotate an element.\n            obj.addEventListener(\"mousewheel\", (event) => {\n                if (!isEnabled()) return;\n\n                event.preventDefault();\n                event.stopPropagation();\n                event.stopImmediatePropagation();\n\n                mouseWheelManipulated = true;\n\n                // Normalize wheel to +1 or -1.\n                const wheel = event.wheelDelta / 120;\n\n                // Manipulation factor.\n                const manipulationFactor = Math.exp(wheel * 0.02);\n\n                // Adjust translate transform to fit zoom point.\n                let centerPoint = {\n                    x: event.clientX,\n                    y: event.clientY\n                };\n                centerPoint = adjustCenterPoint(centerPoint);\n\n                if (event.ctrlKey) {\n                    if (!options.rotate) return;\n\n                    const deltaAngle = -(manipulationFactor - 1) * 50;\n                    const angle = (rotateTransform.angle - deltaAngle) % 360;\n\n                    rotateTransform.set(angle);\n                    rotateTransform.centerPoint.x = centerPoint.x;\n                    rotateTransform.centerPoint.y = centerPoint.y;\n                    transformer.reapplyTransforms();\n\n                    return;\n                }\n\n                if (!options.pinch) return;\n\n                const newScale = scaleTransform.x * manipulationFactor;\n\n                scaleTransform.set(newScale, newScale);\n                scaleTransform.centerPoint.x = centerPoint.x;\n                scaleTransform.centerPoint.y = centerPoint.y;\n                transformer.reapplyTransforms();\n            }, false);\n\n            // return modified transformer\n            resolve(transformer);\n        });\n    });\n};\n\nexport { hammerize };\n\n\n// WEBPACK FOOTER //\n// ./src/extensions/hammerize.js","(function() { module.exports = window[\"hammerjs\"]; }());\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"hammerjs\"\n// module id = 11\n// module chunks = 0"],"sourceRoot":""}
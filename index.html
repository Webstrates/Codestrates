<!doctype html>
<html __wid="8iiFCgMH" version="6"><HEAD __wid="nyQjClRO"><META __wid="VC-iR3Y0" name="mobile-web-app-capable" content="yes"/><META name="apple-mobile-web-app-capable" content="yes" __wid="h-Ul6mwY"/><META name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no" __wid="iiS6bfZA"/><SCRIPT __wid="znuXkD9m" id="script-main">webstrate.on("loaded", function () { new Function(document.querySelector("#bootstrap").textContent)(); });</SCRIPT><TITLE __wid="F6LQLpsp">Codestrate</TITLE></HEAD><BODY __wid="KajDX5Up" class>




    

    
    

    

    

    

    








    






<DIV __wid="_Y8mEnp4" id="sections"><DIV name="Bootstrapping" class="section section-hidden" data-type="system" data-group="basic" data-id="QF65zNxe" __wid="MLtLye5P"><DIV class="paragraph body-paragraph locked" name="Documentation" draggable="false" data-id="DTYb8h2d" __wid="22aNicCA"><DIV data-type="content" contenteditable="false" class="section-documentation" __wid="PCkuc7NM"><H2 __wid="VXKFBRwG">Codestrate Bootstrapping</H2>A codestrate is bootstrapped with a single line of code that is in a script tag in the head of the document. The script will then query for the code paragraph with the ID #bootstrap (see below) and execute the code in a Function object. The scope of code paragraph execution does not create a closure to their surrounding context preventing any interferences with other code executions. The #bootstrap code then executes all code that has a class .bootstrap-module before paragraphs with "run-on-load" (green running man) get executed.<DIV __wid="qvXuLNEW"><BR __wid="jUE2sF6A"/></DIV><DIV __wid="t9meFsSx">The .bootstrap-module code paragraphs add a loading screen, establish "virtual machines" for JavaScript and JSON, enable "run-on-load" code paragraph execution, add functions to import libraries and require code from other code paragraphs, and add query extensions (e.g., query selectors that are based on MutationObserver). The virtual machines allow execution of JavaScript code after page load and without creating a closure to their surrounding context.<BR __wid="CLUmMa8r"/><H2 __wid="MutEz7hY">Attention</H2><DIV __wid="MVftaQgB"><UL __wid="apQuCTJ7"><LI __wid="WmWKrDkK">Do not change the ID of the #bootstrap code. It needs to be #bootstrap, otherwise the codestrate will not bootstrap.<BR __wid="m7TVqTzS"/></LI></UL></DIV></DIV></DIV></DIV>
<DIV class="paragraph data-paragraph locked collapsed" name="Properties" data-id="UQHBUNEJ" __wid="2ujjEHNR"><PRE data-type="content" type="application/json" class="section-properties" contenteditable="false" __wid="G4cbMFEZ">{
	"version": "1.0",
	"description": "Lorem ipsum",
	"changelog":
	{
		"1.0": "Initital Release"
	}
}</PRE></DIV><DIV class="paragraph code-paragraph collapsed" name="Bootstrap Code" draggable="false" last-execution-state="success" data-id="usn4MyQZ" __wid="aeYQcQzY"><PRE data-type="content" type="text/javascript" id="bootstrap" __wid="Ey4hc42k">window.getParameterByName = function(name, url) {
	if (!url) {
		url = window.location.href;
	}
	name = name.replace(/[\[\]]/g, "\\$&");
	var regex = new RegExp("[?&]" + name + "(=([^&#]*)|&|#|$)"),
			results = regex.exec(url);
	if (!results) return null;
	if (!results[2]) return '';
	return decodeURIComponent(results[2].replace(/\+/g, " "));
}

const exec = getParameterByName("exec");

// Do not execute bootstrap code. This is also used by pull sections to minimize transclusion time
// of codestrate from which sections will be pulled.
if (exec === "no") {
// 	const loadedEvent = new CustomEvent("codestrateloaded");
// 	window.dispatchEvent(loadedEvent);
	return;
}

// Bluntly override Codestrate object if it exists
const Codestrate = window.Codestrate = {
	get version() {
		return document.documentElement.getAttribute("version") || 0;
	},
	set version(version) {
		document.documentElement.setAttribute("version", version);
	},
	get OS() {
		return {
			isMac() {
				return (navigator.userAgent.indexOf("Mac OS X") != -1);
			}	
		}
	}
};

/**
 * Execute bootstrap modules. All code paragraphs with bootstrap-module class will
 * be executed in the order in which they are defined. Changing the order can
 * break the Codestrate.
 */
var modules = document.querySelectorAll(".bootstrap-module");

if (!modules) return;

var len = modules.length;
for (var i = 0; i &lt; len; i++) {
	let module = modules[i];
	let paragraph = module.closest('.paragraph');
	
	let codeSource = paragraph.getAttribute("id")
	|| (paragraph.getAttribute("name")
			&& paragraph.getAttribute("name").replace(/\W/g, "_"))
	|| `VM${Date.now()}`;
	
	let code = modules[i].textContent;
	code = `${code}\n//# sourceURL=${codeSource}`;
	new Function(code)();
}</PRE></DIV><DIV class="paragraph code-paragraph collapsed" draggable="false" name="Get Parameter By Name Function" data-id="AfanMQdJ" __wid="8r8jyi5d"><PRE data-type="content" type="text/javascript" class="bootstrap-module" __wid="T6GUCLd4">if (!Codestrate.hasOwnProperty("params")) {
	
  /**
   * Creates an array of all url parameters
   */
	const params = {};
	const paramsString = window.location.search.substring(1).split('&');
	for (let i = 0; i &lt; paramsString.length; i++) {
		let paramString = paramsString[i];
		
		// ignore if parameter string is empty
		if (!paramString || paramString === "") {
			continue;
		}
		
		let keyValue = paramsString[i].split('=');
		let key = keyValue[0];
		let value = keyValue[1] && decodeURIComponent(keyValue[1].replace(/\+/g, " "));
		
		// try to parse value into a JavaScript object or primitive type (e.g., bool), ignore if it fails
		try {
			value = JSON.parse(value);
		}
		catch (error) {
			// ignore
		}
		
		params[key] = value;
	};

  Object.defineProperty(Codestrate, 'params', {
    get: () => {
			return {
				_params: params,
				has(name) {
					return this._params.hasOwnProperty(name);
				},
				get(name, defaultValue = undefined) {
					return this.has(name) ? this._params[name] : defaultValue;
				}
			};
    }
  });
}

// @deprecated, will be removed soon
const getParameterByName = function (name, url) {
	console.warn(`window.getParameterByName is deprecated; use Codestrate.params.get(name, defaultValue)`);
	
  if (!url) {
    url = window.top.location.href;
  }
  name = name.replace(/[\[\]]/g, "\\$&");
  var regex = new RegExp("[?&]" + name + "(=([^&#]*)|&|#|$)"),
    results = regex.exec(url);
  if (!results) return null;
  if (!results[2]) return '';
  return decodeURIComponent(results[2].replace(/\+/g, " "));
}

window.getParameterByName = getParameterByName;</PRE></DIV><DIV class="paragraph code-paragraph collapsed" draggable="false" name="Polyfills" data-id="kBAUzKmQ" __wid="27MXCiV5"><PRE data-type="content" type="text/javascript" class="bootstrap-module" __wid="b4NwJs9J">if (window.Element && !Element.prototype.closest) {

  console.log('Adding polyfill for Element.prototype.closest');

  Element.prototype.closest =
    function (s) {
      var matches = (this.document || this.ownerDocument).querySelectorAll(s),
        i,
        el = this;
      do {
        i = matches.length;
        while (--i >= 0 && matches.item(i) !== el) {};
      } while ((i &lt; 0) && (el = el.parentElement));
      return el;
    };
}

if (!Element.prototype.matches) {

  console.log('Adding polyfill for Element.prototype.matches');

  Element.prototype.matches =
    Element.prototype.matchesSelector ||
    Element.prototype.mozMatchesSelector ||
    Element.prototype.msMatchesSelector ||
    Element.prototype.oMatchesSelector ||
    Element.prototype.webkitMatchesSelector ||
    function (s) {
      var matches = (this.document || this.ownerDocument).querySelectorAll(s),
        i = matches.length;
      while (--i >= 0 && matches.item(i) !== this) {}
      return i > -1;
    };
}

// Production steps of ECMA-262, Edition 5, 15.4.4.18
// Reference: http://es5.github.io/#x15.4.4.18
if (!Array.prototype.forEach) {

  console.log('Adding polyfill for Array.prototype.forEach');

  Array.prototype.forEach = function (callback /*, thisArg*/ ) {

    var T, k;

    if (this == null) {
      throw new TypeError('this is null or not defined');
    }

    // 1. Let O be the result of calling toObject() passing the
    // |this| value as the argument.
    var O = Object(this);

    // 2. Let lenValue be the result of calling the Get() internal
    // method of O with the argument "length".
    // 3. Let len be toUint32(lenValue).
    var len = O.length >>> 0;

    // 4. If isCallable(callback) is false, throw a TypeError exception. 
    // See: http://es5.github.com/#x9.11
    if (typeof callback !== 'function') {
      throw new TypeError(callback + ' is not a function');
    }

    // 5. If thisArg was supplied, let T be thisArg; else let
    // T be undefined.
    if (arguments.length > 1) {
      T = arguments[1];
    }

    // 6. Let k be 0
    k = 0;

    // 7. Repeat, while k &lt; len
    while (k &lt; len) {

      var kValue;

      // a. Let Pk be ToString(k).
      //    This is implicit for LHS operands of the in operator
      // b. Let kPresent be the result of calling the HasProperty
      //    internal method of O with argument Pk.
      //    This step can be combined with c
      // c. If kPresent is true, then
      if (k in O) {

        // i. Let kValue be the result of calling the Get internal
        // method of O with argument Pk.
        kValue = O[k];

        // ii. Call the Call internal method of callback with T as
        // the this value and argument list containing kValue, k, and O.
        callback.call(T, kValue, k, O);
      }
      // d. Increase k by 1.
      k++;
    }
    // 8. return undefined
  };
}

if (!window.requestAnimationFrame) {

  console.log('Adding polyfill for window.requestAnimationFrame');

  // http://paulirish.com/2011/requestanimationframe-for-smart-animating/
  // http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating

  // requestAnimationFrame polyfill by Erik MÃ¶ller. fixes from Paul Irish and Tino Zijdel

  // MIT license

  (function () {
    var lastTime = 0;
    var vendors = ['ms', 'moz', 'webkit', 'o'];
    for (var x = 0; x &lt; vendors.length && !window.requestAnimationFrame; ++x) {
      window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
      window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] ||
        window[vendors[x] + 'CancelRequestAnimationFrame'];
    }

    if (!window.requestAnimationFrame)
      window.requestAnimationFrame = function (callback, element) {
        var currTime = new Date().getTime();
        var timeToCall = Math.max(0, 16 - (currTime - lastTime));
        var id = window.setTimeout(function () {
            callback(currTime + timeToCall);
          },
          timeToCall);
        lastTime = currTime + timeToCall;
        return id;
      };

    if (!window.cancelAnimationFrame)
      window.cancelAnimationFrame = function (id) {
        clearTimeout(id);
      };
  }());
}

if (!Element.prototype || !CharacterData.prototype || !DocumentType.prototype) {

	console.log('Adding polyfill for {Element.prototype, CharacterData.prototype, DocumentType.prototype}.replaceWith');

	// from: https://github.com/jserz/js_piece/blob/master/DOM/ChildNode/replaceWith()/replaceWith().md
	(function (arr) {
		arr.forEach(function (item) {
			if (item.hasOwnProperty('replaceWith')) {
				return;
			}
			Object.defineProperty(item, 'replaceWith', {
				configurable: true,
				enumerable: true,
				writable: true,
				value: function replaceWith() {
					var argArr = Array.prototype.slice.call(arguments),
							docFrag = document.createDocumentFragment();

					argArr.forEach(function (argItem) {
						var isNode = argItem instanceof Node;
						docFrag.appendChild(isNode ? argItem : document.createTextNode(String(argItem)));
					});

					this.parentNode.replaceChild(docFrag, this);
				}
			});
		});
	})([Element.prototype, CharacterData.prototype, DocumentType.prototype]);
}</PRE></DIV><DIV class="paragraph code-paragraph collapsed" name="Random String" draggable="false" data-id="HRefSutb" __wid="ucDKFXTA"><PRE data-type="content" type="text/javascript" class="bootstrap-module" __wid="kcHcLQg5">Codestrate.util = {
	/**
	 * Get random string of size.
	 * @param  {int}    size     Expected length of string (optional).
	 * @param  {string} alphabet List of characters to be used in string (optional).
	 * @return {string}          Generated string.
	 * @public
	 */
	randomString(size = 8,
								// Does not include 0, O, o, 1, I, l for readability.
								alphabet = '23456789abcdefghijkmnpqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ') {
		const len = alphabet.length;
		let str = '';
		while (size--) {
			str += alphabet[this.random(0, len)];
		}
		return str;
	},

	/**
	 * Get random integer from interval [min, max). Unbiased and evenly distributed (or close to).
	 * @param  {int} min Minimum number, inclusive.
	 * @param  {int} max Maximum number, exclusive.
	 * @return {int}     Random number in interval [min, max);
	 * @public
	 */
	random(min, max) {
		return Math.floor(min + Math.random() * (max - min));
	}
};</PRE></DIV><DIV class="paragraph code-paragraph collapsed" draggable="false" name="Loading Indicator" data-id="U6W7p2mW" __wid="HayrgLFj"><PRE data-type="content" type="text/javascript" class="bootstrap-module" __wid="jDWWWv5R">let readyCounter = 0;

let loadingContainer;
const addLoadingIndicator = () => {
	// Hide document while loading all external webstrates.
	loadingContainer = document.createElement("transient");
	loadingContainer.classList.add("overlay");
	loadingContainer.classList.add("loading");

	const centerPiece = document.createElement("div");

	const loadingIndicator = document.createElement("div");

	centerPiece.appendChild(loadingIndicator);
	loadingContainer.appendChild(centerPiece);

	document.body.appendChild(loadingContainer);
};

const removeLoadingIndicator = () => {
	if (readyCounter &lt; 1) {
		
		// Push to next macro task to allow CSS of codestrate to be properly applied before removing
		// the loading indicator. Otherwise it will be a bit jaggy
		setTimeout(() => {
			setTimeout(() => {
				loadingContainer.remove();
			}, 0);
		}, 0);
	}
};

addLoadingIndicator();
++readyCounter;

window.addEventListener("codestrateloaded", function () {
	--readyCounter;
	removeLoadingIndicator();
});

if (typeof Transclusion !== 'undefined') {
	++readyCounter;
	window.addEventListener("externalwebstratesloaded", function () {
		--readyCounter;
		removeLoadingIndicator();
	});
}</PRE></DIV><DIV class="paragraph code-paragraph collapsed" name="Disconnect / Reconnect Code" draggable="false" style data-id="7NLAf26s" __wid="cgLm7sxT"><PRE data-type="content" type="text/javascript" class="bootstrap-module" __wid="9k6QRkmC">var loadingContainer;

function showOffline() {
  // Hide document while loading all external webstrates.
  loadingContainer = document.createElement("transient");
  loadingContainer.classList.add("overlay");
  loadingContainer.classList.add("disconnected");

  const centerPiece = document.createElement("div");

  const loadingIndicator = document.createElement("div");

  centerPiece.appendChild(loadingIndicator);
  loadingContainer.appendChild(centerPiece);

  document.body.appendChild(loadingContainer);
}

webstrate.on("reconnect", function() {
  if (loadingContainer) {
    loadingContainer.remove();
    loadingContainer = null;
  }
});

webstrate.on("disconnect", function() {
  showOffline();
});</PRE></DIV><DIV class="paragraph code-paragraph collapsed" draggable="false" name="Virtual Machine (VM)" data-id="hJYaHnaf" __wid="eNViGPAm"><PRE data-type="content" type="text/javascript" class="bootstrap-module" __wid="yyaxruQy">const mergeContexts = (...contexts) => {
	const context = {};

	contexts.forEach(ctx => {
		Object.keys(ctx).forEach(key => {
			context[key] = ctx[key];
		});
	});

	return context;
};

Codestrate.VirtualMachines = {
	_vms: {},
	get(name) {
		return this._vms[name];
	},
	create(names, executeFunc) {

		const vm = {
			context: {}
		};

		vm.addToGlobalContext = (context) => {
			vm.context = mergeContexts(vm.context, context);
		};

		vm.getExecutionContext = (context = {}) => {

			const tmpContext = mergeContexts(vm.context, {
				console: Codestrate.activeConsole || window.console,
				Variable: window.Variable,
				SharedMemory: Codestrate.SharedMemory
			}, context);

			return {
				execute: (code) => {
					try {
						return executeFunc(code, tmpContext);
					}
					catch (error) {
						
						// log events only once, but still propagate them to the first paragraph
						// that initiated execution
						if (!error.handled) {
							// set actual source of error
							error.source = tmpContext.codeSource;
							error.paragraph = tmpContext.paragraph;
							error.handled = true;
							tmpContext.console.error(error);
						}
						
						throw error;
					}
				}
			};
		};

		// store vm
		if (typeof names === 'string') {
			this._vms[names] = vm;
		}
		else {
			names.forEach((name) => {
				this._vms[name] = vm;
			});
		}
	}
};</PRE></DIV><DIV class="paragraph code-paragraph collapsed" draggable="true" name="JavaScript VM" last-execution-state="success" data-id="wpGiGayi" __wid="RkYznQeM"><PRE data-type="content" type="text/javascript" class="bootstrap-module" __wid="3hZfdJLU">Codestrate.VirtualMachines.create(["JavaScript", "text/javascript"], (code, context) => {
	code = `${code}\n//# sourceURL=${context.codeSource}`;

	const argNames = Object.keys(context);
	const args = argNames.map(key => context[key]);

	const f = new Function(...argNames, code);
	return f(...args);
});</PRE></DIV><DIV class="paragraph code-paragraph collapsed" draggable="false" name="JSON VM" data-id="42Z4ifSq" __wid="q9ydiMqQ"><PRE data-type="content" type="text/javascript" class="bootstrap-module" __wid="Fxv4AfTR">Codestrate.VirtualMachines.create(["JSON", "application/json"], (code) => {
	const f = new Function(`return ${code}`);
	return f();
});</PRE></DIV><DIV class="paragraph code-paragraph collapsed" draggable="false" name="Event Handling" style data-id="N3B5Vng9" __wid="zBnK34XJ"><PRE data-type="content" type="text/javascript" class="bootstrap-module" __wid="Sunh6BmK">// new event system
const _eventHandlers = {};

const addEventListener = (name, handler) => {
  if (!_eventHandlers.hasOwnProperty(name)) {
    _eventHandlers[name] = [];
  }
  let handlers = _eventHandlers[name];
  handlers.push(handler);
};

const removeEventListener = (name, handler = undefined) => {
  if (!_eventHandlers.hasOwnProperty(name)) {
    return;
  }
	
	// remove all handlers for this event
	if (!handler) {
		delete _eventHandlers[name];
		return;
	}
	
  let handlers = _eventHandlers[name];
	let idx = handlers.indexOf(handler);
  handlers.splice(idx, 1);
};

const dispatchEvent = (name, event) => {
  if (_eventHandlers.hasOwnProperty(name)) {
    let handlers = _eventHandlers[name];
    for (let i = 0; i &lt; handlers.length; i++) {
      handlers[i](event);
    }
  }
};

const on = (name, handler) => {
  // split in individual events, e.g. "change refresh execute" will
  // be ["change", "refresh", "execute"]
  let names = name.match(/\S+/g) || [];
  for (let i = 0; i &lt; names.length; i++) {
    let name = names[i];
    addEventListener(name, handler);
  }
};

const off = (name, handler = undefined) => {
  // split in individual events, e.g. "change refresh execute" will
  // be ["change", "refresh", "execute"]
  let names = name.match(/\S+/g) || [];
  for (let i = 0; i &lt; names.length; i++) {
    let name = names[i];
		removeEventListener(name, handler);
  }
};

Codestrate.addEventListener = addEventListener;
Codestrate.on = addEventListener;
Codestrate.removeEventListener = removeEventListener;
Codestrate.off = removeEventListener;
Codestrate.dispatchEvent = dispatchEvent;</PRE></DIV><DIV class="paragraph code-paragraph collapsed" name="Execute Code Paragraphs" data-id="GVBwaApD" __wid="SAyNnsWe"><PRE data-type="content" type="text/javascript" class="bootstrap-module" __wid="6yPd2gws">// Codestrate has loaded state
let loaded = false;

// Codestrate loaded property
Object.defineProperty(Codestrate, "loaded", {
	get: () => {
		return loaded;
	}
});

Codestrate.runCode = (paragraph) => {
	
	// block execution of consecutive code paragraphs until this paragraph executed completely after
	// importing all libs or requiring other code paragraphs
	let blockHandle = Codestrate.blockExecution("Codestrate.runCode");
	
	const codeSelector = '[data-type="content"]';
	const element = paragraph.querySelector(codeSelector);

	if (!element) {
		throw new Error(`Could not find ${codeSelector} in paragraph`);
	}
	
	const codeType = element.getAttribute("type");
	if (!codeType) {
		throw new Error(`Could not find type attribute on ${element}`);
	}
		
	var code = element.innerText;

	Codestrate.dispatchEvent("beforeruncode", {
		paragraph: paragraph,
		code: code
	});

	let codeSource = paragraph.getAttribute("id")
		|| (paragraph.getAttribute("name")
					&& paragraph.getAttribute("name").replace(/\W/g, "_"))
		|| `VM${Codestrate.util.randomString()}`;
		
	try {
		const vm = Codestrate.VirtualMachines.get(codeType);

		const context = vm.getExecutionContext({
			paragraph,
			codeSource,
			exports: {}
		});
		
		context.execute(code);

		Codestrate.dispatchEvent("successruncode", {
			paragraph: paragraph,
			code: code
		});
	}
	catch (error) {
		
		Codestrate.dispatchEvent("errorruncode", {
			error: error,
			paragraph: paragraph,
			code: code
		});
	}
		
	Codestrate.dispatchEvent("afterruncode", {
		paragraph: paragraph,
		code: code
	});
	
	// release block handle
	blockHandle.continue();
};

let paragraphSelector = '.paragraph[run-on-load="true"]';
if (Codestrate.params.has("groups")) {
	let groups = Codestrate.params.get("groups");
	let groupSelector = groups.map((group) => {
		return `.section[data-group="${group}"] ${paragraphSelector}`;
	}).join(',');
	
	paragraphSelector = `.section:not([data-group]) ${paragraphSelector},${groupSelector}`;
}

// console.log('execute selector', paragraphSelector);

const executeOnLoadSections = Array.from(document.querySelectorAll(paragraphSelector));
const len = executeOnLoadSections.length;

let currentIndex = 0;
let blockedExecutionCount = 0;

const execute = () => {
	
	// Break execution loop when all paragraph have been executed.
	if (currentIndex >= len) {
		// set codestrate as loaded
		loaded = true;
		
		const loadedEvent = new CustomEvent("codestrateloaded");
		window.dispatchEvent(loadedEvent);
		return;
	}

	const paragraph = executeOnLoadSections[currentIndex];

	Codestrate.runCode(paragraph);
	
	if (!blockedExecutionCount) {
		execute(++currentIndex);
	}
};

Codestrate.blockExecution = (message = "", timeout = 30000) => {
	++blockedExecutionCount;
	let hasContinued = false;
	
	let timeoutHandle;

	const continueWithNext = () => {
		clearTimeout(timeoutHandle);
		--blockedExecutionCount;
		
		if (!blockedExecutionCount) {
			hasContinued = true;
			execute(++currentIndex);
		}
	};

	timeoutHandle = setTimeout(() => {
		const confirmMessage = `Loading "${message}" is taking too long. Do you want to continue?`;
		if (window.confirm(confirmMessage)) {
			continueWithNext();
		}
	}, timeout);

	return {
		continue: () => {
			if (!hasContinued) {
				continueWithNext();
			}
		}
	}
};

// Execute first paragraph if one exists.
if (len) {
	execute(currentIndex);
}</PRE></DIV><DIV class="paragraph code-paragraph collapsed" name="Query Extensions" draggable="false" run-on-load="true" data-id="gbYXPcgb" __wid="qqwJwceq"><PRE data-type="content" type="text/javascript" __wid="csUrp2xN">// The Codestrates Query Extension do not trigger events for elements with class 'template' or
// elements that have a parent with class 'template'. This is a temporary solution until actual
// HTML5 template elements are supported within Codestrates.

/**
 * Ignore mutations for elements with class template or for elements that have a parent element
 * with class template
 */
const isMutationAllowed = (element) => {
	return !element.closest('.template');
};

/**
 * The live query selector
 */
const liveQuerySelectorAll = function (selector, observerOptions = { subtree: true, childList: true }) {

	const elements = this.querySelectorAll(selector);

	let addResolve;
	let removeResolve;
	
	let observer;
	if (observerOptions) {
		observer = new MutationObserver(mutations => {

			mutations.forEach(mutation => {

				switch (mutation.type) {
					case "childList":

						if (removeResolve) {
							Array.prototype.forEach.call(mutation.removedNodes, (node) => {
								if (node.nodeType !== 1) return;

								try {
									if (node.matches(selector)) {
										removeResolve(node);
									}

									if (observerOptions.subtree) {
										const subNodes = node.querySelectorAll(selector);
										Array.prototype.forEach.call(subNodes, (subNode) => removeResolve(subNode));
									}
								}
								catch (error) {
									window.console.error(error, node);
								}
							});
						}

						if (addResolve) {
							Array.prototype.forEach.call(mutation.addedNodes, (node) => {
								if (node.nodeType !== 1) return;

								try {
									if (node.matches(selector)) {
										addResolve(node);
									}

									if (observerOptions.subtree) {
										const subNodes = node.querySelectorAll(selector);
										Array.prototype.forEach.call(subNodes, (subNode) => addResolve(subNode));
									}
								}
								catch (error) {
									window.console.error(error, node);
								}
							});
						}
						break;
														 }
			});
		});
		observer.observe(this, observerOptions);
	}

	const resolver = {
		added(resolve) {

			if (typeof resolve !== 'function')
				throw new Error('First parameter needs to be a function');

			// add resolve function that also checks for allowed mutations
			addResolve = (element) => {
				if (!isMutationAllowed(element)) return;
				resolve(element);
			};

			// immediately callback resolve function to notifiy callee about initial elements
			Array.prototype.forEach.call(elements, (element) => {
				addResolve(element);
			});
			
			return resolver;
		},
		removed(resolve) {
			if (typeof resolve !== 'function')
				throw new Error('First parameter needs to be a function');

			// remove resolve function that also checks for allowed mutations
			removeResolve = (element) => {
				if (!isMutationAllowed(element)) return;
				resolve(element);
			};
			
			return resolver;
		},
		stop() {
			if (observer) {
				observer.disconnect();
			}
		}
	}

	return resolver;
};

Document.prototype.liveQuerySelectorAll = liveQuerySelectorAll;
Element.prototype.liveQuerySelectorAll = liveQuerySelectorAll;


const liveAttribute = function(attributeName) {
	const element = this;

	let attributeChanged;

	const observer = new MutationObserver(mutations => {

		if (typeof attributeChanged === 'function') {
			mutations.forEach(mutation => {

				if (mutation.attributeName === attributeName) {
					attributeChanged(mutation.target.getAttribute(attributeName), mutation.oldValue);
				}
			});
		}
	});
	observer.observe(element, { attributes: true, attributeOldValue: true });

	let resolver = {
		changed(resolve) {
			
			// attribute changed function that also checks for allowed mutations
			attributeChanged = (value, oldValue) => {
				if (!isMutationAllowed(element)) return;
				resolve(value, oldValue);
			}

			// immediately callback resolve function to notifiy callee about initial attribute value
			attributeChanged(element.getAttribute(attributeName), undefined);
			return resolver;
		},
		stop() {
			observer.disconnect();
		}
	}
	
	return resolver;
};

Element.prototype.liveAttribute = liveAttribute;</PRE></DIV><DIV class="paragraph code-paragraph collapsed" name="Template Code" draggable="false" run-on-load="true" data-id="BsNZH7Rd" __wid="3T33UFX3"><PRE data-type="content" type="text/javascript" __wid="nhMn47xr">const func = `return eval('\`' + __str__ + '\`');`

window.template = function (str, data) {
	let context = Object.assign({}, data, {
		__str__: str
	});

  const argNames = Object.keys(context);
  const args = argNames.map((key) => context[key]);

  const f = new Function(...argNames, func);
  return f(...args);
}</PRE></DIV><DIV class="paragraph code-paragraph collapsed" draggable="false" name="Import Function" run-on-load="true" style data-id="HpbBedd6" __wid="ZX6gqFFS"><PRE data-type="content" type="text/javascript" __wid="6pxcfxFk">const relativeUrlRegex = new RegExp('^\\s*(?:[a-z0-9]+:)?//', 'i');
const isCacheEnabled = Codestrate.params.get("cache", false);
const cacheKeyPrefix = "notestrate-import:";

console.debug(`Cache enabled: ${isCacheEnabled}`);

let importsContainer = document.head.querySelector('transient#imports');

// Add imports container if it does not exist.
if (!importsContainer) {
	importsContainer = document.createElement("transient");
	importsContainer.setAttribute("id", "imports");
	document.head.insertBefore(importsContainer, document.head.firstChild);
}

/**
 * Returns true if the resource is relative path to this webstrate.
 *
 * @param {string} src Url to resource.
 * @param {boolean} Returns true if the resource is relative. 
 */
const isRelativeResource = (src) => {
	return !relativeUrlRegex.test(src);
};

const getLatestAssets = () => {
	
	let latestAssets = {};
	let assets = webstrate.assets.call({});
	Array.prototype.forEach.call(assets, asset => {
		if (!latestAssets[asset.fileName] || latestAssets[asset.fileName].v &lt; asset.v) {
			latestAssets[asset.fileName] = asset;
		}
	});
	
	return latestAssets;
};

// Webstrate assets to check if cached resource needs to be updated.
const assets = []; //getLatestAssets();

/**
* Executes JavaScript code by adding it to a script element, which is then appended
* to the importsContainer transient element. The script element is returned.
*
* @param {string} code The JavaScript code.
* @return {HTMLScriptElement} The script element containing the code.
*/
const executeJavaScript = function (code) {

	// Add sourcemap functionality to script
	code = `${code}\n//# sourceURL=${Codestrate.util.randomString()}`;

	const script = document.createElement("script");
	script.setAttribute("type", "text/javascript");

	// Use text node to make large scripts work (> 65k characters)
	const textNode = document.createTextNode(code);
	script.appendChild(textNode);

	importsContainer.appendChild(script);

	return script;
};

/**
* Executes the CSS by adding it to a style element, which is then appended to the
* importsContainer transient element. The style element is returned.
*
* @param {string} css The CSS style.
* @param {HTMLStyleElement The style element containing the css.
*/
const executeCss = function (css) {

	// Create the style element
	const style = document.createElement("style");

	// Add styles
	style.innerHTML = css;

	// WebKit hack :(
	style.appendChild(document.createTextNode(""));

	// Add the style element to the page
	importsContainer.appendChild(style);

	return style;
};

const storeInCache = (src, type) => {
	
	// Check if cache is enabled and only cache resources are from this webstrate.
	if (!isCacheEnabled || !isRelativeResource(src)) {
		return false;
	}
	
	// Get asset and only cache if asset for resource exists.
	const asset = assets[src];
	
	if (typeof (Storage) !== "undefined" && asset) {
		
		// Get resource and store its content in cache.
		fetch(src, { credentials: 'include' }).then(externalResource => {
			externalResource.text().then(content => {
				
				const resource = {
					asset,
					type,
					content
				};
				
				localStorage.setItem(`${cacheKeyPrefix}${src}`, JSON.stringify(resource));
			})
		});
	}
}

/**
 * It loads the source from cache if the cache is enabled and if it exists in cache
 */
const loadFromCache = (src) => {
	
	if (!isCacheEnabled) {
		return false;
	}
	
	if (typeof (Storage) !== "undefined") {

		const value = localStorage.getItem(`${cacheKeyPrefix}${src}`);

		if (value) {
			try {
				const { asset, type, content } = JSON.parse(value);
				
				// If asset does not exist then it has been updated eventually
				if (assets[asset.fileName].v > asset.v) {
					localStorage.removeItem(`${cacheKeyPrefix}${src}`);
					return false;
				}

				let imported = importsContainer.querySelector(`[data-src="${src}"]`);

				// Source already imported
				if (imported) {
					return true;
				}
				
// 				console.debug(`Loading ${asset.fileName}?v=${asset.v} from cache`);

				let element;
				if (type === "text/javascript") {
					element = executeJavaScript(content);
				}
				else if (type === "text/css") {
					element = executeCss(content);
				}
				else {
					throw new Error(`Type "${type}" is not supported.`);
				}
				element.setAttribute("data-cached", "true");
				element.setAttribute("data-src", src);
				return true;
			}
			catch (error) {
				debugger;
				console.error(`Could not load source ${src} from cache. Removing it from cache.`, error);
				localStorage.removeItem(`${cacheKeyPrefix}${src}`);
			}
		}
	}

	return false;
}

window.importLib = function (src, type = "text/javascript") {

	// Block execution of consecutive code paragraphs until all external libraries imported
	// by the current code paragraph have been executed.
	const blockHandle = Codestrate.blockExecution(src);

	const loadLibrary = (s, callback) => {

		if (loadFromCache(s)) {
			setTimeout(() => {
				callback();
			}, 0);
			return;
		}
		
		let script = importsContainer.querySelector(`script[src="${s}"]`);

		// Import source only once.
		if (!script) {
			script = document.createElement("script");
			script.setAttribute("type", type);
			script.setAttribute("src", s);
			script.onload = () => {
				script.__loaded = true;

				if (isCacheEnabled) {
					storeInCache(s, type);
				}

				callback();

				if (script.__callbacks) {
					script.__callbacks.forEach(cb => cb());
				}
			};
			importsContainer.appendChild(script);
		}
		// Script is imported by another code paragraph, but has not been loaded completely
		// by the first one. So, the callback is added to a list and called after the
		// has loaded.
		else if (!script.__loaded) {
			if (!script.__callbacks) {
				script.__callbacks = [];
			}
			script.__callbacks.push(callback);
		}
		// The script has been loaded and executed before. Just continue.
		else {
			callback();
		}
	}

	// Returns a promise like function, which will be executed when all imports
	// were loaded.
	return {

		then: (resolve) => {

			if (typeof src === "string") {
				loadLibrary(src, () => {
					try {
						resolve();
					}
					finally {
						blockHandle.continue();
					}
				});
			}
			else if (Array.isArray(src)) {
			
				const len = src.length;
				let i = 0;

				const loadNextLib = () => {
					if (i &lt; len) {
						loadLibrary(src[i], () => {
							++i;
							loadNextLib();
						});
					}
					else {
						try {
							resolve();
						}
						finally {
							blockHandle.continue();
						}
					}
				};

				loadNextLib();
			}
			else {
				throw new Error(`The 1 parameter must be a string or an array of strings instead of ${src}`);
			}
		}
	};
}

/**
 * Load style from source.
 *
 * @param {string|Array} src The url to the source or an array of urls to sources.
 */
const loadStyle = (src) => {

	// Load resource from cache and return on success.
	if (loadFromCache(src))	return;
		
	let link = importsContainer.querySelector(`link[src="${src}"]`);

	// Import resource only once.
	if (!link) {
		link = document.createElement("link");
		link.setAttribute("rel", "stylesheet");
		link.setAttribute("href", src);
		importsContainer.appendChild(link);

		if (isCacheEnabled) {
			storeInCache(src, "text/css");
		}
	}
}

// Export importStyle function to global window object.
window.importStyle = function (src) {

	if (typeof src === "string") {
		loadStyle(src);
	}
	else if (Array.isArray(src)) {
		src.forEach(loadStyle);
	}
	else {
		throw new Error(`The 1 parameter must be a string or an array of strings instead of ${src}`);
	}
}</PRE></DIV><DIV class="paragraph code-paragraph collapsed" draggable="false" name="Require Function" run-on-load="true" last-execution-state="success" data-id="47dEZgUz" __wid="zvKHtyyh"><PRE data-type="content" type="text/javascript" __wid="bfJWBJac">const vm = Codestrate.VirtualMachines.get("JavaScript");

const requireSingle = (codeElement, data, reuseExports, multiple = false) => {

  let code;
  if (multiple) {
    code = codeElement.map((element) => {
      return element.innerText;
    }).join('\n\n');
		codeElement = codeElement[0];
  }
	else {
    code = codeElement.innerText;
  }

  // Replace placeholders like ${myVar} in code
  if (data) {
    code = template(code, data);
  }

  let paragraph = codeElement.closest('.paragraph');

  let codeSource = paragraph.getAttribute("id") ||
    (paragraph.getAttribute("name") &&
      paragraph.getAttribute("name").replace(/\W/g, "_")) ||
    `VM${Codestrate.util.randomString()}`;

  const type = codeElement.getAttribute("type");

  if (type === "text/javascript") {
		
		// return exports from previous execution when resuse exports is enabled
		if (reuseExports && codeElement.__exports) {
			return codeElement.__exports;
		}
		
		let exports = {};
		const context = vm.getExecutionContext({
			paragraph,
			codeSource,
			exports: exports
		});

		context.execute(code);

		if (reuseExports) {
			// store exports in for later reuse
			codeElement.__exports = exports;
		}
		
    return exports;
  }
	else if (type === "application/json") {
    const jsonVM = Codestrate.VirtualMachines.get(type);
    const context = jsonVM.getExecutionContext();
    return context.execute(code);
  }
	else if (type === "text/css") {
    return code;
  }
	else if (type === "text/html") {
    let html = codeElement.innerHTML;

    if (data) {
      html = template(html, data);
    }

    const container = document.createElement("div");
    container.innerHTML = html;

    return Array.from(container.children).map(c => c);
  }

  return code;
};

const require = (selector, data, reuseExports = true) => {
  const codeElements = Array.from(document.querySelectorAll(`${selector}[data-type="content"]`));

  if (!codeElements.length) {
    throw new Error(`require('${selector}') does not exist`);
  }

  if (codeElements.length > 1) {
		return requireSingle(codeElements, data, reuseExports, true);
  }

  return requireSingle(codeElements[0], data, reuseExports);
};

const requireAll = (selector, data, reuseExports = true) => {
  const codeElements = Array.from(document.querySelectorAll(`${selector}[data-type="content"]`));

  let exports = Array.prototype.map.call(codeElements, (codeElement) => {
    return requireSingle(codeElement, data, reuseExports);
  });

  return exports;
};

// Add require to global execution context for JavaScript virtual machine
vm.addToGlobalContext({
  require,
  requireAll
});

// for debugging: export to Codestrate object
Codestrate.require = require;
Codestrate.requireAll = requireAll;</PRE></DIV><DIV class="paragraph code-paragraph collapsed" name="Destroy Event Listeners On Rerun" style draggable="false" run-on-load="true" data-id="8237gBwR" __wid="psYTkfJk"><PRE data-type="content" type="text/javascript" id="destroy-event-listeners-on-rerun" __wid="S5SPCZU9">Codestrate.addEventListener("beforeruncode", (event) => {

  const {
    paragraph,
    code
  } = event;

  // add codestrate object
  if (!paragraph.codestrate) {
    paragraph.codestrate = {};
  }

  if (paragraph.__listeners) {
// 		console.info('removing event listeners added during a previous run of this paragraph', paragraph.__listeners);
    paragraph.__listeners.forEach((listener) => {
      listener.source.removeEventListener(...listener.parameters);
    });

    // clear list of event listeners
    paragraph.__listeners.length = 0;
  } else {
    paragraph.__listeners = [];
  }

  if (!paragraph.codestrate.customAddEventListener) {
    paragraph.codestrate.customAddEventListener = function () {
      var parameters = Array.from(arguments);
      // window.console.log('arguments %o', parameters);

      try {
        paragraph.codestrate.oldAddEventListener.call(this, ...parameters);
        paragraph.__listeners.push({
          source: this,
          parameters: parameters
        });
      } catch (error) {
        throw error;
      }
    };
  }

  // only register custom event listener once as another code paragraph might have already done
  // this
  if (Node.prototype.addEventListener === paragraph.codestrate.customAddEventListener) {
    console.warn('prevent overriding addEventListener multiple times');
    return;
  }

  // keep a reference to the previous event listener, which will be re-added after the code
  // paragraph ran
  paragraph.codestrate.oldAddEventListener = Node.prototype.addEventListener;

  // temporarily override addEventListener with custom implementation
  Node.prototype.addEventListener = paragraph.codestrate.customAddEventListener;
});

Codestrate.addEventListener("afterruncode", (event) => {

  const {
    paragraph
  } = event;

  // ignore this code paragraph's after run
  if (paragraph.querySelector('#destroy-event-listeners-on-rerun')) {
    return;
  }

  // re-add old addEventListener
  if (paragraph.codestrate.oldAddEventListener) {
    Node.prototype.addEventListener = paragraph.codestrate.oldAddEventListener;
    delete paragraph.codestrate.oldAddEventListener;
  }
});</PRE></DIV><DIV class="paragraph code-paragraph collapsed" draggable="false" name="Destroy DOM Elements On Rerun" style data-id="qaqmECVU" __wid="EUswGKtJ"><PRE data-type="content" type="text/javascript" id="destroy-dom-elements-on-rerun" __wid="gZgVD9AN">Codestrate.addEventListener("beforeruncode", (event) => {

  const {
    paragraph,
    code
  } = event;

  // add codestrate object
  if (!paragraph.codestrate) {
    paragraph.codestrate = {};
  }

  if (paragraph.__appendedChildren) {
    console.info('removing children appended during a previous run of this paragraph', paragraph.__appendedChildren);
    paragraph.__appendedChildren.forEach((child) => {
      child.remove();
    });

    // clear list of event listeners
    paragraph.__appendedChildren.length = 0;
  } else {
    paragraph.__appendedChildren = [];
  }

  if (!paragraph.codestrate.customAppendChild) {
    paragraph.codestrate.customAppendChild = function (child) {
      paragraph.__appendedChildren.push(child);
      paragraph.codestrate.oldAppendChild.call(this, child);
    };
  }

  // only register custom appendChild once as another code paragraph might have already done
  // this
  if (Node.prototype.appendChild === paragraph.codestrate.customAppendChild) {
    console.warn('prevent overriding appendChild multiple times');
    return;
  }

  // keep a reference to the previous appendChild function, which will be re-added after the code
  // paragraph ran
  paragraph.codestrate.oldAppendChild = Node.prototype.appendChild;

  // temporarily override appendChild with custom implementation
  Node.prototype.appendChild = paragraph.codestrate.customAppendChild;
});

Codestrate.addEventListener("afterruncode", (event) => {

  const {
    paragraph
  } = event;

  // ignore this code paragraph's after run
  if (paragraph.querySelector('#destroy-dom-elements-on-rerun')) {
    return;
  }

  // re-add old addEventListener
  if (paragraph.codestrate.oldAddEventListener) {
    Node.prototype.appendChild = paragraph.codestrate.oldAppendChild;
    delete paragraph.codestrate.oldAppendChild;
  }
});</PRE></DIV><DIV class="paragraph code-paragraph collapsed" run-on-load="true" last-execution-state="success" draggable="false" name="Dialog VM Overwrite" style data-id="W54QAJP8" __wid="TfQ4UPv9"><PRE data-type="content" type="text/javascript" __wid="mmkkJmsz">const Dialogs = require('#dialogs');

const vm = Codestrate.VirtualMachines.get("JavaScript");
vm.addToGlobalContext({
	alert: Dialogs.alert,
	confirm: Dialogs.confirm,
	prompt: Dialogs.prompt
});</PRE></DIV><DIV class="paragraph code-paragraph collapsed" name="Event Bus" draggable="false" style data-id="fKKWnXRG" __wid="TZ9QC7BV"><PRE data-type="content" type="text/javascript" id="event-bus" __wid="SfZBN3cs">let allHandlers = {};

/**
 * Add handler.
 */
const addHandler = (name, handler) => {
	if (!allHandlers.hasOwnProperty(name)) {
		allHandlers[name] = [];
	}
	allHandlers[name].push(handler);
};

/**
 * Remove handler.
 */
const removeHandler = (name, handler) => {
	if (allHandlers.hasOwnProperty(name)) {

		if (handler) {
			// filter by handler instances
			allHandlers[name] = allHandlers[name].filter((h) => h !== handler);
		}
		else {
			// remove all handlers for name if handler instance is undefined
			delete allHandlers[name];
		}
	}
};

/**
 * Trigger all handlers registered for event name.
 */
const triggerHandlers = (name, event) => {
	if (allHandlers.hasOwnProperty(name)) {
		allHandlers[name].forEach((handler) => {
			handler.call(window, event);
		});
	}
};

class Bus {
	
	constructor() {
		Codestrate.SharedMemory.register(this);
	}
	
	on(name, handler) {
		addHandler(name, handler);
		return this;
	}

	off(name, handler = undefined) {
		removeHandler(name, handler);
		return this;
	}

	trigger(name, event) {
		triggerHandlers(name, event);
		return this;
	}
	
	destroy() {
		Codestrate.SharedMemory.unregister(this);
	}
}

exports.Bus = Bus;</PRE></DIV><DIV class="paragraph code-paragraph collapsed" name="Shared Memory" run-on-load="true" style data-id="cVLFX86N" __wid="EkBC3PXJ"><PRE data-type="content" type="text/javascript" __wid="BCiCPX9j">Codestrate.SharedMemory = new Proxy({
	_buses: [],
	_updateVariable(o) {
		this[o.key] = o.value;
	},
	register(bus) {
		this._buses.push(bus);

		bus.on("set", this._updateVariable);
	},
	unregister(bus) {
		bus.off("set", this._updateVariable);

		this._buses = this._buses.filter((b) => b !== bus);
	}
}, {
	get(target, key) {
		return target[key];
	},
	set(target, key, value) {
		target[key] = value;

		target._buses.forEach((bus) => {
			bus.trigger("set", {
				key,
				value
			});
		});
		
		return true;
	}
});</PRE></DIV></DIV><DIV class="section section-hidden" name="Console" data-type="system" data-group="basic" data-id="nyjy5imM" __wid="VN9fuiQE"><DIV class="paragraph body-paragraph locked" draggable="false" name="Documentation" data-id="BR9vXBE3" __wid="f3QFqdx9"><DIV data-type="content" type="text/html" codemirror="true" contenteditable="false" class="section-documentation" __wid="7QAuYJ7J"><H2 __wid="B8ey9Lv4">Description</H2>The console section adds a console to each code paragraph. All console calls within a paragraph are logged to the paragraph's console before logs are redirected to the browser console. To show the console, this section adds a console button to each paragraph header. Clicking the console button toggles the console. Consoles are hidden by default and located in a transient element, which means their state is not synchronized with other clients have the same codestrate open.</DIV></DIV><DIV class="paragraph data-paragraph locked collapsed" name="Properties" data-id="x22UQapi" __wid="Me9PxSX9"><PRE data-type="content" type="application/json" class="section-properties" contenteditable="false" __wid="WZuqMJvL">{
	"version": "1.0",
	"description": "Lorem ipsum",
	"changelog":
	{
		"1.0": "Initital Release"
	}
}</PRE></DIV>
<DIV class="paragraph code-paragraph collapsed" draggable="false" name="Console" run-on-load="true" last-execution-state="success" data-id="8gS9rQm6" __wid="aiWqj6r8"><PRE data-type="content" type="text/javascript" __wid="CQtxJK3a">importLib("moment.min.js").then(() => {

  class Console {

    constructor(paragraph, container) {
			this.messageBufferSize = 100;
			this.paragraph = paragraph;
      this.container = container;

      // Logs go to buffer and will be subsequently rendered in
      // requestAnimationFrame.
      this._outputBuffer = [];

      this._addHeader();
      this._addOutput();
      this._addInput();

      this._addCloseButton();

      this.container.classList.add("close");
			
			// scroll to paragraph that produced the error
			this.paragraph.addEventListener("click", (event) => {
				
				let target = event.target;

				const error = target.closest('[error-id]');
				if (error) {
					event.preventDefault();
					
					const source = error.getAttribute("source");
					const lineNumber = Number(error.getAttribute("line-number")) - 1;

					const paragraph = error.__paragraph;
					paragraph.classList.remove("collapsed");

					const section = paragraph.closest('.section');
					section.classList.remove("section-hidden");
					
					const content = paragraph.querySelector('[data-type="content"]');

					// add class to line with error
					if (content.__editor && content.__editor.editor) {
						
						let cm = content.__editor.editor;
						
						const addError = (lineHandle) => {
							cm.addLineClass(lineHandle, "background", "line-error");
							cm.addLineClass(lineHandle, "text", "line-error-text");
//  						cm.addLineClass(lineHandle, "gutter", "line-error-text");
// 	  					cm.addLineClass(lineHandle, "wrap", "line-error-text");
							
							cm.focus();
							cm.setCursor(lineNumber, 0);
						};
						
						const removeError = (lineHandle) => {
							cm.removeLineClass(lineHandle, "background", "line-error");
							cm.removeLineClass(lineHandle, "text", "line-error-text");
// 							cm.removeLineClass(lineHandle, "gutter", "line-error-text");
// 							cm.removeLineClass(lineHandle, "wrap", "line-error-text");
						};
						
						// remove previous error
						if (this.errorLineHandle) {
							removeError(this.errorLineHandle);
							this.errorLineHandle = null;
						}
						
						// add error
						this.errorLineHandle = cm.getLineHandle(lineNumber);
						addError(this.errorLineHandle);
						
						// remove error on editor change
						let that = this;
						cm.on("change", function change() {
							cm.off("change", change);
							
							if (that.errorLineHandle) {
								removeError(that.errorLineHandle);
								that.errorLineHandle = null;
							}
						});
					}

					paragraph.scrollIntoView();
				}
			});
    }

    open() {
      this.container.classList.remove("close");
      setTimeout(() => {
        this.container.classList.add("open");
      }, 1);
    }

    close() {
      const onClosed = (event) => {
        if (event.propertyName === "height") {
          this.container.removeEventListener("transitionend", onClosed);
          this.container.classList.add("close");
        }
      };

      this.container.removeAttribute("style");
      this.container.addEventListener("transitionend", onClosed, false);
      this.container.classList.remove("open");
    }

    toggle() {
      if (this.container.classList.contains("open")) {
        this.close();
      }
      else {
        this.open();
      }
    }

    destroy() {
      this.close();

      this.container.addEventListener("transitionend", (event) => {
        if (event.propertyName === "height") {
          this.container.remove();
        }
      }, false);
    }

    log() {
      this._internalLog("log", ...arguments);
    }

    info() {
      this._internalLog("info", ...arguments);
    }

    error() {
      this._internalLog("error", ...arguments);
    }

    warn() {
      this._internalLog("warn", ...arguments);
    }

    debug() {
      this._internalLog("debug", ...arguments);
    }

    trace() {
      this._internalLog("trace", ...arguments);
    }

    _addHeader() {
      this.header = document.createElement("div");
      this.header.setAttribute("class", "header");
      this.container.appendChild(this.header);
    }

    _addOutput() {
      this.output = document.createElement("div");
      this.output.setAttribute("class", "output");
      this.container.appendChild(this.output);
    }

    _addInput() {
      this.input = document.createElement("div");
      this.input.setAttribute("class", "input");
      
      let history = [];
      let historyIndex = -1;

      const inputElement = document.createElement("input");
      inputElement.setAttribute("type", "text");
      inputElement.addEventListener("keydown", event => {
        
//         alert('key code' + event.key);
        
        if (event.keyCode === 13) {

          // Get console input
          const value = inputElement.value;
          
          // Ignore empty console input
          if (value.trim() === "") {
            return;
          }
          
          // Push console input to history
          history.push(value);
          historyIndex = history.length;

          try {
//             const f = new Function('console', `return ${value}`);
//             const result = f(this);
            
            this.log(value);
            
            const result = eval(value);

            this.log(result);
          }
          catch (error) {
            this.error(error);
          }
          finally {
            // Reset console input
            inputElement.value = "";
          }
        }
        else if (event.keyCode === 38) {
          
          if (historyIndex > 0) {
            inputElement.value = history[--historyIndex];
          }
        }
        else if (event.keyCode === 40) {
          
          if (historyIndex &lt; history.length - 1) {
            inputElement.value = history[++historyIndex];
          }
          else {
            historyIndex = history.length;
            inputElement.value = "";
          }
        }
      });
      this.input.appendChild(inputElement);

      this.container.appendChild(this.input);
    }

    _addCloseButton() {
      const closeConsole = document.createElement("span");
      closeConsole.setAttribute("class", "close-console");
      closeConsole.addEventListener("click", event => {
        if (typeof this.onClose === 'function') {
          if (this.onClose.call(this)) {
            this.close();
          }
        }
        else {
          this.close();
        }
      });

      const icon = document.createElement("i");
      icon.setAttribute("class", "material-icons");
      closeConsole.appendChild(icon);

      this.header.appendChild(closeConsole);
    }

    _updateScroll() {
      this.output.scrollTop = this.output.scrollHeight;
    }

    _internalLog(type, ...args) {
			
			// Log to actual DevTools console including the paragraph that contains the code.
			const console = window.console;
			if (console) {
				const consoleLog = console[type];
				if (typeof consoleLog === 'function') {
					const location = this.paragraph.getAttribute("name") || "No Name";
					console.group("Console %c%s", 'color: orange;', location);
					consoleLog.call(window, ...args);
					console.groupCollapsed("%cLog Source", 'font-weight: normal;');
					console.log(this.paragraph);
					console.groupEnd();
					console.groupEnd();
				}
			}

      this._outputBuffer.push({
//         timestamp: moment().format("YYYY-MM-DD HH:mm:ss.SSS"),
        timestamp: moment().format("HH:mm:ss.SSS"),
        type: type,
        args: args
      });
			
			let location = "";

      /**
       * Convert arg to output that conforms to console output.
       */
      const convertArg = (arg) => {

        let converted = arg;

        if (arg instanceof Error) {
					
					let error = arg;
					
// 					let codeSource = tmpContext.codeSource;
// 					if (error.source) {
// 						codeSource = error.source;
// 					}
					
// 					window.console.log(error.source);

					const codeSelector = '[data-type="content"]';
					const element = error.paragraph.querySelector(codeSelector);

					// 		window.console.error(error, error.source);
					const regex = new RegExp("^([^\n]+)\n" + // error string
																	 "[^]+?" + // whatever comes before the parenthesis
																	 "\\((?:.*?):" + // code name or trash, non-capturing
																	 "([0-9]+):([0-9]+)\\)" // parenthesis
																	);

					const matches = error.stack.match(regex);
					if (matches) {
						let [_, errorString, lineNumber, letterNumber] = matches;
						// Everything except SyntaxErrors will be in a `new Function` construct with
						// two appended lines, which we should account for.
						if (errorString.substring(0,12) !== "SyntaxError:") {
							lineNumber = lineNumber - 2;
						}
						
						const errorId = Codestrate.util.randomString();
						
						location = `&lt;span error-id="${errorId}" source="${error.source}" line-number="${lineNumber}">${error.source}:${lineNumber}&lt;/span>`;

						converted = `${errorString}&lt;br>&nbsp;&nbsp;at (${location})`;

						setTimeout(() => {
							const spans = document.querySelectorAll(`[error-id="${errorId}"]`);
							Array.prototype.forEach.call(spans, (span) => {
								span.__paragraph = error.paragraph;
							});
						}, 0);
					}
					else {
						converted = error.stack;
					}
        }
        else if (arg instanceof HTMLElement) {
					// Convert HTML element to a string.
					// !!! The replace is required otherwise the console will render the HTML
					// instead of logging the markup.
					converted = arg.outerHTML.replace(/[\u00A0-\u9999&lt;>\&]/gim, (idx) => {
						return `&#${idx.charCodeAt(0)};`;
					});
        }
        else if (typeof arg === 'object') {
					try {
          	converted = JSON.stringify(arg, null, "  ");
					}
					catch (error) {
// 						window.console.error(error);
						converted = arg.toString();
					}
        }
        
        let type = typeof arg;
        if (arg === null) {
          type = "null";
        }

        return `&lt;span class="${type}">${converted}&lt;/span>`;
      };

      const logToOutput = () => {
				
				// reduce log messages to maximum of buffer size
				let limit = this.messageBufferSize - this._outputBuffer.length;
				while (this.output.childNodes.length > limit && this.output.childNodes.length > 0) {
					this.output.firstElementChild.remove();
				}

        const fragment = document.createDocumentFragment();

        this._outputBuffer.forEach((item) => {
          const entry = document.createElement("div");
					entry.classList.add("log-output");
					entry.classList.add(item.type);

          const args = item.args.map(convertArg);
          let message = args.join(" ");

          entry.innerHTML = `
&lt;div class="time">${item.timestamp}&lt;/div>
&lt;div class="message">${message}&lt;/div>
&lt;div class="location">${location}&lt;/div>
`;
          fragment.appendChild(entry);
        });

        this.output.appendChild(fragment);

        this._updateScroll();

        // Clear output buffer
        this._outputBuffer.length = 0;

        // Allow new animation frame requests
        this.requestedAnimationFrame = false;
      };

      if (!this.requestedAnimationFrame) {
        this.requestedAnimationFrame = true;
        window.requestAnimationFrame(logToOutput);
      }
    }
  }


  // Hook into Active Essay bootstrap and set console for currently executed code
  // block.
  Codestrate.addEventListener("beforeruncode", event => {

    const { paragraph } = event;

    // Set active console.
    Codestrate.activeConsole = paragraph.console;
  });
  
  const addConsole = (paragraph) => {

    // Add console only once.
    if (paragraph.console) return;

    const consoleContainer = document.createElement("transient");
    consoleContainer.setAttribute("class", "console");

    // Attach actual console to element.
    const console = new Console(paragraph, consoleContainer);
    paragraph.console = console;
    paragraph.appendChild(consoleContainer);
  };

  document.liveQuerySelectorAll('.paragraph.code-paragraph').added(addConsole);
});</PRE></DIV><DIV class="paragraph style-paragraph collapsed" name="Console Style" draggable="false" data-id="Xi64tc6E" __wid="NPPrem7K"><STYLE data-type="content" type="text/css" codemirror="true" __wid="SL3kJWrz">.console {
/*   position: relative; */
  background: rgb(48, 48, 48);
  margin-top: 5px;
  width: 100%;
  height: 0;
  opacity: 0;
  pointer-events: none;
  z-index: 9;
  display: block;

  border: 1px solid rgb(135, 135, 129);
  border-radius: 2px;
  
  background-color: rgba(0, 0, 0, .1);
  
  display: none;

  /*   -webkit-transition: height 500ms ease-in-out 0s, opacity 500ms ease-in-out 0s;
  -moz-transition: height 500ms ease-in-out 0s, opacity 500ms ease-in-out 0s;
  transition: height 500ms ease-in-out 0s, opacity 500ms ease-in-out 0s; */
}

.console.open {
  display: flex;
/*   flex: 1; */
/*   flex-direction: column; */
  flex-flow: column;

  /*   height: 100%; */
  min-height: 200px;
  opacity: 1.0;
  pointer-events: all;

  overflow: hidden;
  overflow-y: hidden;
  resize: vertical;
}

.console.close {
  border: 0;
  padding: 0;
  margin: 0;
}

.console .header {
  padding: 5px;
	border-bottom: 1px solid rgb(135, 135, 129);
}

.console .header:before {
  content: "Console";
}

.console .close-console {
  position: absolute;
  top: 0;
  right: 0;
  height: 100%;
  z-index: 1;
  cursor: pointer;
  /*font-size: .6em;*/
}

/* .console .close-console i:after {
  content: "close";
  position: absolute;
  top: 50%;
  right: 0;
  font-size: .8em;
  transform: translate3d(0, -50%, 0);
} */

.console .output,
.console .input {
  font-family: "Menlo", monospace;
  font-size: 11px;
}

.console .output {
  flex: 1;
  
/*   background-color: orange; */
  overflow: hidden;
  overflow-y: auto;
/*   padding: 5px; */

/*   border-top: 1px solid rgba(255, 255, 255, .05);
  border-bottom: 1px solid rgba(255, 255, 255, .05); */
}

.console > .output > .log-output {
  display: flex;
	flex-direction: row;
  /*word-break: break-all;*/
/*   word-wrap: break-word; */
  /*float: right;*/
/*   white-space: pre-wrap; */
	padding: 0 5px;
  border-top: 1px solid rgba(255, 255, 255, .05);
  border-bottom: 1px solid rgba(255, 255, 255, .05);
	
/* 	margin-bottom: -1px; */
}

.console > .output > .log-output > * {
/* 	display: inline; */
	padding: 3px;
}

.console > .output > .log-output > .message {
	flex: 1;
}

/* .console > .output > div:not(:last-child) {
  padding: 3px 0 3px 0;
  border-bottom: 1px solid rgba(255, 255, 255, .1);
}

.console > .output > div:last-child {
  padding: 3px 0 0 0;
}

.console > .output > div > .time {
  color: rgb(135, 135, 129);
}
*/

.console > .output > .log-output.error {
	color: rgb(255, 127, 127);
	background-color: rgba(30, 0, 0, 1);
  border-top: 1px solid rgba(73, 0, 0, 1);
  border-bottom: 1px solid rgba(73, 0, 0, 1);
}

.console > .output > .log-output .time,
.console > .output > .log-output .location {
	color: lightgray;
}

.console > .output > .log-output .location {
	text-decoration: underline;
	cursor: pointer;
}

.console > .output > .log-output.warn {
	background-color: rgba(255, 255, 0, .1);
  color: rgba(255, 220, 158, 1.0);
  border-top: 1px solid rgba(255, 255, 0, .5);
  border-bottom: 1px solid rgba(255, 255, 0, .5);
}

.console > .output > .log-output.debug {
  color: rgba(76, 136, 255, 1.0);
}

.console > .output > .log-output > .message .number,
.console > .output > .log-output > .message .boolean {
  color: #9179ff;
}

.console > .output > .log-output > .message .object {

}

.console > .output > .log-output > .message .null,
.console > .output > .log-output > .message .undefined {
  color: rgb(135, 135, 129);
}

.console > .output > .log-output > .message.info:before {
  content: "INFO: ";
	display: inline-block;
}

.console .input {
  padding: 5px;
	border-top: 1px solid rgb(135, 135, 129);
}

.console .input:before {
  content: ">";
  margin-right: 5px;
  font-weight: bold;
  width: 10px;
  display: inline-block;
}

.console .input input[type="text"] {
	font-family: inherit;
  border: 0;
  outline: 0;
  color: white;
  width: calc(100% - 15px);
  background-color: transparent;
}

.console [error-id] {
	text-decoration: underline;
	cursor: pointer;
}

.CodeMirror .line-error {
	background-color: red;
	animation-name: highlight;
	animation-duration: 1250ms;
	opacity: .15;	
	margin-right: 5px;
}

/* .CodeMirror .line-error-text {
	text-decoration: underline;
	text-decoration-color: red;
	text-decoration-style: wavy;
} */

/* .CodeMirror .line-error-gutter {
	text-decoration: underline;
	text-decoration-color: red;
	text-decoration-style: wavy;
} */

/* .CodeMirror .line-error-wrap {
	text-decoration: underline;
	text-decoration-color: red;
	text-decoration-style: wavy;
} */

@keyframes highlight {
	from {
		opacity: .5;	
	}
}</STYLE></DIV></DIV><DIV class="section section-hidden" name="Migration" data-type="system" data-group="editing" data-id="ifppNbfJ" __wid="pMGsmrDL"><DIV class="paragraph body-paragraph locked" draggable="false" name="Documentation" data-id="4W22rTyt" __wid="5zVMGZ9E"><DIV data-type="content" type="text/html" codemirror="true" contenteditable="false" class="section-documentation" __wid="LuNjFzyk"><H2 __wid="9d2Qhp7w">Description</H2><DIV __wid="EjhJENYU">The migration section allows to update document structure of previous versions of a codestrate. For example, the "Put sections into div#sections" adds a div element with ID sections to the document body and then moves all sections previously in the document body to the newly created div#sections element.</DIV><DIV __wid="My2KfEGW"><BR __wid="eNAe5nxS"/></DIV><DIV __wid="tmmxgrSq">The migration section also allows to add or update assets that changed of have been added between two versions of a codestrate.</DIV></DIV></DIV><DIV class="paragraph data-paragraph locked collapsed" name="Properties" data-id="rYz2ZveL" __wid="5x63zQmi"><PRE data-type="content" type="application/json" class="section-properties" contenteditable="false" __wid="jp97McEP">{
	"version": "1.0",
	"description": "Lorem ipsum",
	"changelog":
	{
		"1.0": "Initital Release"
	}
}</PRE></DIV>

<DIV class="paragraph code-paragraph collapsed" draggable="false" last-execution-state="success" run-on-load="true" name="Migration Facade" data-id="BjiiG8sZ" __wid="Ctgamcqu"><PRE data-type="content" type="text/javascript" __wid="pJzXX3VQ">const AssetUtils = require('#asset-utils');

const Migration = (minVersion, name, perform, assets = []) => {

	if (typeof minVersion !== 'number') {
		throw new Error('Migration must have a minimum version');
	}

	if (!name) {
		throw new Error('Migration must have a name');
	}

	if (typeof perform !== 'function') {
		throw new Error('perform must implement migration process');
	}

	return {
		name,
		minVersion,
		migrate() {
			return new Promise((resolve, reject) => {
				(async() => {

					// fetching assets and uploading them to this codestrate
					if (assets.length) {
						window.console.log(`fetching assets for migration ${name}`);

						for (let i = 0; i &lt; assets.length; i++) {
							let assetName = assets[i];
							let response = await fetch(assetName, { credentials: 'include' });
							let blob = await response.blob();
							window.console.log(assetName, blob);
							let asset = await AssetUtils.uploadBlob(assetName, blob);
						}
						
						window.console.log(`all assets uploaded for migration ${name}`);
					}

					window.console.log(`running migration ${name}`);
					let task = perform();
					
					// allow promises as return values for migration perform
					if (task instanceof Promise) {
						await task;
					}

					window.console.log(`migration ${name} completed`);
					
					resolve();
				})();
			});
		}
	}
}

// Adding migration class to JavaScript execution context. This will make the Migration class
// available in code paragraphs only and not expose it to the global window scope.
const vm = Codestrate.VirtualMachines.get("JavaScript");
vm.addToGlobalContext({
	Migration
});</PRE></DIV><DIV class="paragraph code-paragraph collapsed" last-execution-state="success" name="Migration Loader" run-on-load="true" data-id="kTHY8iBv" __wid="iWfMdr3A"><PRE data-type="content" type="text/javascript" __wid="57RsQSKH">// never perform migration on prototype!!!
if (webstrate.webstrateId !== "Codestrate") {

	// prevent other code paragraphs from being executed, allow 60 seconds to execute before timeout
	const blockHandle = Codestrate.blockExecution("migration", 60000);

	(async() => {
		let requires = requireAll('.migration');

		// get all migrations and filter out obselete migrations
		let migrations = Array.prototype.map.call(requires, (r) => {
			return r.migration;
		}).filter((m) => m.minVersion > Codestrate.version);
		
		if (migrations.length) {
			
			let result = await confirm("Do you want to migrate this codestrate?", "Migration codestrate");

			if (result) {
				// sort migrations to apply them in proper order
				migrations.sort((m1, m2) => m1.minVersion > m2.minVersion);

				// perform all migrations

				for (let i = 0; i &lt; migrations.length; i++) {
					await migrations[i].migrate();
					Codestrate.version = migrations[i].minVersion;
				}
			}
		}

		// continue with next code paragraph
		blockHandle.continue();

		// reload if migrations where applied
		if (migrations.length) {

			let result = await confirm("Do you want to remove migration scripts?", "Migration completed");

			if (result) {
				// get all migration code paragraphs, and remove them
				let migrations = document.querySelectorAll('.migration');
				Array.prototype.forEach.call(migrations, (migration) => {
					let paragraph = migration.closest('.paragraph');
					if (paragraph) {
						paragraph.remove();
					}
				});
			}

			// reload after timeout to make sure the codestrate works without side-effects
			setTimeout(() => {
				alert('Reloading codestrate in 5 seconds');
				window.location.reload();
			}, 5000);
		}
	})();
}</PRE></DIV><DIV class="paragraph code-paragraph collapsed" name="Migration - Put sections into div#sections" data-id="ENaMHnxt" __wid="2XTasmmS"><PRE data-type="content" type="text/javascript" class="migration" __wid="JNBFSDD8">// These are dependencies that have been added to the new version of Codestrates or need an update
const assets = [
	"/Codestrate/codemirror.css",
	"/Codestrate/codemirror-addon-simplescrollbars.css",
	"/Codestrate/codemirror-addon-dialog.css",
	"/Codestrate/codemirror-addon-show-hint.css",
	"/Codestrate/codemirror-addon-foldgutter.css",
	"/Codestrate/codemirror-addon-matchesonscrollbar.css",
	"/Codestrate/codemirror.js",
	"/Codestrate/codemirror-addon-annotatescrollbar.js",
	"/Codestrate/codemirror-addon-simplescrollbars.js",
	"/Codestrate/codemirror-addon-scrollpastend.js",
	"/Codestrate/codemirror-addon-show-hint.js",
	"/Codestrate/codemirror-addon-javascript-hint.js",
	"/Codestrate/codemirror-addon-xml-hint.js",
	"/Codestrate/codemirror-addon-html-hint.js",
	"/Codestrate/codemirror-addon-css-hint.js",
	"/Codestrate/codemirror-addon-anyword-hint.js",
	"/Codestrate/codemirror-addon-comment.js",
	"/Codestrate/codemirror-addon-continuecomment.js",
	"/Codestrate/codemirror-addon-foldcode.js",
	"/Codestrate/codemirror-addon-foldgutter.js",
	"/Codestrate/codemirror-addon-brace-fold.js",
	"/Codestrate/codemirror-addon-xml-fold.js",
	"/Codestrate/codemirror-addon-markdown-fold.js",
	"/Codestrate/codemirror-addon-comment-fold.js",
	"/Codestrate/codemirror-addon-indent-fold.js",
	"/Codestrate/codemirror-addon-matchbrackets.js",
	"/Codestrate/codemirror-addon-matchtags.js",
	"/Codestrate/codemirror-addon-closebrackets.js",
	"/Codestrate/codemirror-addon-closetag.js",
	"/Codestrate/codemirror-addon-searchcursor.js",
	"/Codestrate/codemirror-addon-match-highlighter.js",
	"/Codestrate/codemirror-addon-matchesonscrollbar.js",
	"/Codestrate/codemirror-addon-jump-to-line.js",
	"/Codestrate/codemirror-addon-search.js",
	"/Codestrate/codemirror-mode-xml.js",
	"/Codestrate/codemirror-mode-htmlmixed.js",
	"/Codestrate/codemirror-mode-javascript.js",
	"/Codestrate/codemirror-mode-css.js",
	"/Codestrate/codemirror-mode-go.js",
	"/Codestrate/quadtree.js",
];

// The perform function applies necessary changes to the DOM to update the document structure
const perform = () => {
	let container = document.createElement("div");
	container.setAttribute("id", "sections");

	const sections = document.querySelectorAll('body > div.section');
	Array.prototype.forEach.call(sections, (s) => {
		container.appendChild(s);
	});
	document.body.appendChild(container);
};

// This migration will move all sections from body to a new div.sections element
exports.migration = Migration(1, "SectionsToDiv", perform, assets);</PRE></DIV><DIV class="paragraph code-paragraph collapsed" name="Migration - Pull beatify libraries 
" data-id="prqCkgr6" __wid="9HHVq9gT"><PRE data-type="content" type="text/javascript" class="migration" __wid="CFsmQmbs">// These are dependencies that have been added to the new version of Codestrates or need an update
const assets = [
	"/Codestrate/beautify.js",
	"/Codestrate/beautify-css.js",
	"/Codestrate/beautify-html.js"
];

// This migration will copy all assets from originating codestrate
exports.migration = Migration(2, "PullBeautifyLibraries", () => {}, assets);</PRE></DIV><DIV class="paragraph code-paragraph collapsed" draggable="false" style name="Migration - Add section-visible to sections" data-id="RZFZNFxT" __wid="JRkMgbFu"><PRE data-type="content" type="text/javascript" class="migration" __wid="NBFrmBVL">// This migration will add section-visible class to sections that are currently visible. The
// class is required e.g., for the tooltip to display tooltip downwards for first visible section.
// Because otherwise the tooltips will be cut off.
exports.migration = Migration(3, "AddSectionVisibleClass", () => {
	let sections = document.querySelectorAll('.section:not(.section-hidden)');
	Array.prototype.forEach.call(sections, (section) => {
		section.classList.add("section-visible");
	});
});</PRE></DIV><DIV class="paragraph code-paragraph collapsed" name="Migration - Pull linter libraries" style data-id="jqsLHEwJ" __wid="jNKDxWA6"><PRE data-type="content" type="text/javascript" class="migration" __wid="kJ6HR8H5">// These are dependencies that have been added to the new version of Codestrates or need an update
const assets = [
	"/Codestrate/codemirror-linter-jshint.js",
	"/Codestrate/codemirror-linter-htmlhint.js",
	"/Codestrate/codemirror-linter-csslint.js",
	"/Codestrate/codemirror-linter-jsonlint.js",
	
	"/Codestrate/codemirror-addon-lint.js",
	"/Codestrate/codemirror-addon-lint.css",
	
	"/Codestrate/codemirror-addon-javascript-lint.js",
	"/Codestrate/codemirror-addon-html-lint.js",
	"/Codestrate/codemirror-addon-css-lint.js",
	"/Codestrate/codemirror-addon-json-lint.js"
];

// This migration will copy all assets from originating codestrate
exports.migration = Migration(4, "PullLinterLibraries", () => {}, assets);</PRE></DIV><DIV class="paragraph code-paragraph collapsed" name="Migration - Pull active line addon" data-id="UQdEcpxj" __wid="PVSZu4nu"><PRE data-type="content" type="text/javascript" class="migration" __wid="3egib77f">// These are dependencies that have been added to the new version of Codestrates or need an update
const assets = [
	"/Codestrate/codemirror-addon-active-line.js"
];

// This migration will copy all assets from originating codestrate
exports.migration = Migration(5, "PullActiveLineAddon", () => {}, assets);</PRE></DIV><DIV class="paragraph code-paragraph collapsed" data-id="WfAEm9Ru" name="Migration - Update sortable.js" __wid="XvD5UJth"><PRE data-type="content" type="text/javascript" class="migration" __wid="yYbaL7NM">// These are dependencies that have been added to the new version of Codestrates or need an update
const assets = [
	"/Codestrate/Sortable.js"
];

// This migration will copy all assets from originating codestrate
exports.migration = Migration(6, "UpdateSortableLibrary", () => {}, assets);</PRE></DIV></DIV><DIV name="User & Client Manager" class="section section-hidden" data-type="system" data-group="basic" data-id="5anpeYib" __wid="V5TMVSRA"><DIV class="paragraph body-paragraph locked" draggable="false" name="Documentation" data-id="JF57SD8B" __wid="yLfF3Bjd"><DIV data-type="content" type="text/html" codemirror="true" contenteditable="false" class="section-documentation" __wid="AHFXWzHz"><H2 __wid="vHsX9zLf">Description</H2><SPAN style="font-size: 14.6667px;" __wid="5C54msHd">The user manager adds a users array to the Codestrate global window object. Each object in the users array will have the user id and a generated user color. For example, the color can be used in the in the Codestrate to have a consistent user color for remote pointers and remote cursors.</SPAN></DIV></DIV><DIV class="paragraph data-paragraph locked collapsed" name="Properties" data-id="yMviPwWQ" __wid="e6X7ZKCJ"><PRE data-type="content" type="application/json" class="section-properties" contenteditable="false" __wid="B5He7kjt">{
	"version": "1.0",
	"description": "Lorem ipsum",
	"changelog":
	{
		"1.0": "Initital Release"
	}
}</PRE></DIV>
<DIV class="paragraph code-paragraph collapsed" run-on-load="true" name="Client Manager Global" data-id="icqmBqmd" __wid="3RFxp7sa"><PRE data-type="content" type="text/javascript" __wid="bEth6wSA">// Add a clients array to the global Codestrate object
if (Codestrate && !Codestrate.clients) {
  Codestrate.clients = [];
}

let ignoreUpdates = false;

/**
 * Get the client object.
 *
 * @param {string} The client id.
 */
const getClient = (id = webstrate.clientId) => {
  const clients = Codestrate.clients;
  return clients.find((c) => c.id === id);
};

/**
 * Adds a new client to the clients array and generates a random client color. Nothing will
 * happen if a client already exists.
 *
 * @param {string} id The client id.
 * @param {object} userObject The user object.
 */
const addClient = (id, userObject) => {
  let client = getClient(id);

  // Add client only if it does not exist
  if (!client) {

    let handler = {
      get: function (target, name) {
        return target[name];
      },
      set: function (target, name, value) {
        target[name] = value;

        Codestrate.dispatchEvent("clientUpdateProperty", {
          propertyName: name,
          client
        });

        if (!ignoreUpdates) {
          sendClientData(undefined, false, client.id);
        }

        // Indicate success
        return true;
      }
    };

    userObject.id = id;
    userObject.color = '#' + (Math.random() * 0xFFFFFF &lt;&lt; 0).toString(16);
    userObject.avatarUrl = webstrate.user.avatarUrl || "unknown.jpg";
    client = new Proxy(userObject, handler);

    Codestrate.clients.push(client);
    Codestrate.dispatchEvent("clientAdd", client);
  }
};

/**
 * Removes a client from the clients array.
 *
 * @param {string} id The client id.
 */
const removeClient = (id) => {
  const clients = Codestrate.clients;
  const idx = clients.findIndex((c) => c.id === id);
  const client = clients.splice(idx, 1);

  Codestrate.dispatchEvent("clientRemove", client[0]);
};

/**
 * Update a clients data.
 *
 * @param {string} id The client id.
 *
 */
const updateClient = (id, data) => {
  const clients = Codestrate.clients;

  // Add client only if it does not exist
  let client = getClient(id);
  if (client) {
    ignoreUpdates = true;

    // merge data into client
    Object.assign(client, data);

    // client is not anonymous anymore
    delete client.anonymous;

    ignoreUpdates = false;

    Codestrate.dispatchEvent("clientUpdate", client);
  }
};

/**
 * Get other client ids (all connected client ids except for own client id).
 */
const otherClientIds = () => {
  return webstrate.clients.filter((c) => c !== webstrate.clientId);
};

/**
 * Send client data to other clients.
 */
const sendClientData = (receiverId = undefined, giveMeYourClientData = true, clientId = undefined) => {

  const clientData = getClient(clientId);
	
	if (!clientData) {
		console.warn(`could not find client data for client ${clientId}`);
		return;
	}
	
  const otherClients = otherClientIds();

  webstrate.signal({
    cmd: "ClientData",
    clientData,
    giveMeYourClientData
  }, receiverId ? [receiverId] : otherClients);
};

webstrate.on("signal", (message, senderId) => {

  let {
    cmd,
    clientData,
    giveMeYourClientData
  } = message;

  if (cmd === "ClientData") {

    // ignore own message
    if (webstrate.clientId === senderId) {
      return;
    }

    updateClient(clientData.id, clientData);

    if (giveMeYourClientData) {
      // Also send back own avatar to sender client.
      sendClientData(senderId, false);
    }
  }
});

/**
 * Add existing clients on connect
 */
const onConnect = () => {
  // Add all existing clients
  webstrate.clients.forEach((c) => {
    if (webstrate.clientId === c) {
      addClient(c, webstrate.user);
    } else {
      addClient(c, {
        username: "anonymous",
        anonymous: true
      });
    }
  });

  // send this clients data
  sendClientData();
};

/**
 * Remove all clients on disconnect
 */
const onDisconnect = () => {
  Codestrate.clients.forEach((client) => removeClient(client.id));
};

// Add a client to the list of clients when it joins
webstrate.on("clientJoin", (clientId) => addClient(clientId, {
  username: "anonymous",
  anonymous: true
}));

// Remove a client from the list of clients when it leaves
webstrate.on("clientPart", (clientId) => removeClient(clientId));

// Add clients on reconnect
webstrate.on("reconnect", onConnect);

// Clear all clients
webstrate.on("disconnect", onDisconnect);

// reconnect is only called when disconnected before and not on initial load, 
// therefore we call onConnect here
onConnect();</PRE></DIV><DIV class="paragraph code-paragraph collapsed" name="Client Manager Utils" data-id="XKUmvrUu" __wid="rSMdqgcp"><PRE data-type="content" type="text/javascript" id="client-manager" __wid="iwzY4y9J">/**
 * Convert a hex colour to a rgb/rgba value
 * @param {string} hex
 * @param {?number} opacity
 * @returns {string}
 */
const convertHexToRGBA = (hex, opacity) => {
  hex = hex.replace('#', '');
  const r = parseInt(hex.substring(0, 2), 16);
  const g = parseInt(hex.substring(2, 4), 16);
  const b = parseInt(hex.substring(4, 6), 16);

  return `rgba(${r},${g},${b},${opacity})`;
};

const getClient = exports.getClient = (id = webstrate.clientId) => {
  return Codestrate.clients.find((c) => c.id === id);
};

const getClientColor = exports.getClientColor = (id = webstrate.clientId) => {
  const client = getClient(id);

  if (!client) {
//     return "#00ff00";
    throw new Error(`Client ${id} does not exist in ${JSON.stringify(Codestrate.clients)}`);
  }

  return client.color;
};

exports.getClientColorInRGBA = (id = webstrate.clientId, opacity = 1.0) => {
  return convertHexToRGBA(getClientColor(id), opacity);
};</PRE></DIV><DIV class="paragraph code-paragraph collapsed" name="User Manager Global" run-on-load="true" data-id="Fyk5aXMy" __wid="P8svkzxb"><PRE data-type="content" type="text/javascript" __wid="JBhnr9Bh">if (!Codestrate.hasOwnProperty("users")) {
  Object.defineProperty(Codestrate, 'users', {
    get: () => {
      let users = [];

      Codestrate.clients.forEach((c) => {
        let user = users.find((u) => u.id === c.userId);
        if (!user) {
          user = {
            id: (c.userId || c.id),
						username: c.username,
						displayName: c.displayName,
						avatarUrl: c.avatarUrl,
            clients: [c]
          };
          users.push(user);
        } else {
          user.clients.push(c);
        }
      });

      return users;
    }
  });
}</PRE></DIV><DIV class="paragraph code-paragraph collapsed" name="User Manager" data-id="Bh7aPTWt" __wid="Nc3Nc6yc"><PRE data-type="content" type="text/javascript" id="user-manager" __wid="izEVtWJr">exports.getUser = (userId = webstrate.user.userId) => {
	return Codestrate.users.find((user) => user.id === userId);
};</PRE></DIV></DIV><DIV name="Idle Timer" class="section section-hidden" data-type="system" data-group="basic" data-id="bZ9ftpMD" __wid="GEA5rm3d"><DIV class="paragraph body-paragraph locked" name="Documentation" data-id="CpWbeNtn" draggable="false" __wid="RNnV64HZ"><DIV data-type="content" type="text/html" codemirror="true" contenteditable="false" class="section-documentation" __wid="maea5Kg6"><H2 __wid="RRAUY8dV">Description</H2><DIV __wid="ZM26nP3n">The idle timer section is a small extension to the codestrate, which sends out awake signals when the user interacts with the codestrate. For example, the idle timer is used for the avatar to indicate whether a user is present or absent.</DIV></DIV></DIV>
<DIV class="paragraph data-paragraph locked collapsed" name="Properties" data-id="Mv7cqyj9" __wid="Cw5dJaPv"><PRE data-type="content" type="application/json" class="section-properties" contenteditable="false" __wid="wDrkKE3D">{
	"version": "1.0",
	"description": "Lorem ipsum",
	"changelog":
	{
		"1.0": "Initital Release"
	}
}</PRE></DIV><DIV class="paragraph code-paragraph collapsed" name="Idle Timer Code" run-on-load="true" last-execution-state="success" draggable="false" data-id="SJuq3Muw" __wid="gfy7PzN8"><PRE data-type="content" type="text/javascript" __wid="AMc9cFhm">// Time until client becomes idle/inactive (in milliseconds)
const IDLE_TIMEOUT = 300 * 1000;

let isIdle = false;
let idleTimeout;
let lastAction = Date.now();

const actionHappend = () => {
	
	lastAction = Date.now();
	
	// Send awake message only if client was in idle mode
	if (isIdle) {
		isIdle = false;
		signalAwake();
	}

	if (idleTimeout) {
		clearTimeout(idleTimeout);
	}

	idleTimeout = setTimeout(() => {
		isIdle = true;
		signalIdle();
	}, IDLE_TIMEOUT);
};

/**
 * Signal awake message to all clients.
 */
const signalAwake = () => {
	webstrate.signal({ type: "IdleTimer", cmd: "awake" });
};

/**
 * Signal idle message to recipients or all clients.
 *
 * @param {Array|string} [recicipients] An array of client ids or a single client id indicating the recipients of the idle signal.
 */
const signalIdle = (recipients = webstrate.clients) => {
	webstrate.signal({
		type: "IdleTimer",
		cmd: "idle",
		idleTime: Date.now() - lastAction
	}, recipients);
};

// Send idle state to joining clients when idle = true
webstrate.on("clientJoin", (clientId) => {
	
	// Ignore own client join event
	if (clientId === webstrate.clientId) return;
	
	if (isIdle) {
		// We have to set a timeout here to cope with race condition. The signalIdle is
		// sent to the requesting client before the callback that listens for this message
		// is registered.
		setTimeout(() => signalIdle(clientId), 10000);
	}
});

// webstrate.on("reconnect", actionHappend);

document.addEventListener("mousemove", actionHappend);
document.addEventListener("keydown", actionHappend);
document.addEventListener("touchstart", actionHappend);
document.addEventListener("touchmove", actionHappend);
document.addEventListener("touchend", actionHappend);
actionHappend();</PRE></DIV></DIV><DIV class="section section-hidden" name="Dialogs" data-type="system" data-group="basic" data-id="aUnGvNB7" __wid="m6f28C2h"><DIV class="paragraph body-paragraph locked" draggable="false" name="Documentation" data-id="AVYTegUf" __wid="7waFYHzZ"><DIV data-type="content" type="text/html" codemirror="true" contenteditable="false" class="section-documentation" __wid="AkxR4uw7"><H2 __wid="ndfLcpPU">Description</H2><DIV __wid="Xp5CwPSH">The dialog section adds support to write custom non-modal dialogs that can be used for various purposes. For example, it is used to overwrite a browser's default dialogs with non-blocking dialogs.</DIV></DIV></DIV><DIV class="paragraph data-paragraph locked collapsed" name="Properties" data-id="Xz6yvM28" __wid="7XeRvJcS"><PRE data-type="content" type="application/json" class="section-properties" contenteditable="false" __wid="5xXRWw5F">{
	"version": "1.0",
	"description": "Lorem ipsum",
	"changelog":
	{
		"1.0": "Initital Release"
	}
}</PRE></DIV>

<DIV class="paragraph body-paragraph collapsed" name="Dialog Template" draggable="false" data-id="wtHuW5uq" __wid="dPXzeVcC"><DIV data-type="content" type="text/html" codemirror="true" contenteditable="true" id="dialog-template" __wid="3riD26sJ"><DIV class="modal" __wid="EynJ8GAG"></DIV>
<DIV class="dialog" __wid="A2HYJSqE">
	<DIV class="title" __wid="zBANsMMu">${title}</DIV>
	<DIV class="body" __wid="LwMPnArh">${message}</DIV>
	<DIV class="actions" __wid="7rZptMFY">
		${actions}
	</DIV>
</DIV></DIV></DIV><DIV class="paragraph code-paragraph collapsed" draggable="false" last-execution-state="success" name="Dialog Exports" data-id="LkND9ZyA" __wid="z5vsYAHP"><PRE data-type="content" type="text/javascript" id="dialogs" __wid="eAhDuZte">exports.prompt = (message, defaultValue = "", title = "") => {

	return new Promise((resolve, reject) => {

		const transient = document.createElement("transient");

		const elements = require('#dialog-template', {
			title: title === "" ? "&nbsp;" : title,
			message: `&lt;div>${message}&lt;/div>
&lt;input class="input" type="text" value="${defaultValue}">`,
			actions: `&lt;div class="button ok">OK&lt;/div>
&lt;div class="button cancel">Cancel&lt;/div>`
		});

		elements.forEach(e => transient.appendChild(e));

		const okBtn = transient.querySelector('.ok');
		const cancelBtn = transient.querySelector('.cancel');
		const input = transient.querySelector('.input');

		const ok = () => {
			transient.remove();
			resolve(input.value);
		};

		const cancel = () => {
			transient.remove();
			resolve(false);
		};

		okBtn.addEventListener("click", ok);
		cancelBtn.addEventListener("click", cancel);

		input.addEventListener("keydown", e => {
			e.stopPropagation();

			if (e.keyCode === 13) {
				e.preventDefault();
				ok();
			}
			else if (e.keyCode === 27) {
				e.preventDefault();
				cancel();
			}
		});

		document.body.appendChild(transient);

		input.focus();
	});
};

exports.alert = (message, title = "") => {

	return new Promise((resolve, reject) => {

		const transient = document.createElement("transient");

		const elements = require('#dialog-template', {
			title: title === "" ? "&nbsp;" : title,
			message: message,
			actions: `&lt;div class="button ok">OK&lt;/div>`
		});

		elements.forEach(e => transient.appendChild(e));

		const okBtn = transient.querySelector('.ok');

		const ok = () => {
			transient.remove();
			resolve(true);
		};

		okBtn.addEventListener("click", ok);

		document.body.appendChild(transient);
	});
};

exports.confirm = (message, title = "") => {

	return new Promise((resolve, reject) => {

		const transient = document.createElement("transient");

		const elements = require('#dialog-template', {
			title: title === "" ? "&nbsp;" : title,
			message: message,
			actions: `&lt;div class="button ok">OK&lt;/div>
&lt;div class="button cancel">Cancel&lt;/div>`
		});

		elements.forEach(e => transient.appendChild(e));

		const okBtn = transient.querySelector('.ok');
		const cancelBtn = transient.querySelector('.cancel');

		const ok = () => {
			transient.remove();
			resolve(true);
		};

		const cancel = () => {
			transient.remove();
			resolve(false);
		};

		okBtn.addEventListener("click", ok);
		cancelBtn.addEventListener("click", cancel);

		document.body.appendChild(transient);
	});
};</PRE></DIV><DIV class="paragraph code-paragraph collapsed" last-execution-state="success" run-on-load="true" name="Show Tags Dialog" data-id="JTLwYcxH" __wid="KLkGBED2"><PRE data-type="content" type="text/javascript" __wid="d4U5NvZE">Codestrate.showTags = () => {
	
	const transient = document.createElement("transient");
	
	const tags = webstrate.tags();
	const keys = Object.keys(tags);
	keys.reverse();
	
	let tagElementsString = '&lt;ul>';
	let len = keys.length > 10 ? 10 : keys.length;
	for (var i = 0; i &lt; len; i++) {
		tagElementsString += `&lt;li class="tag" data-key="${keys[i]}" data-tag="${tags[keys[i]]}">${tags[keys[i]]}&lt;/li>`;
	}
	tagElementsString += '&lt;/ul>';

	const elements = require('#dialog-template', {
		title: "Codestrate Tags",
		message: tagElementsString,
		actions: `&lt;div class="button cancel">Cancel&lt;/div>`
	});

	elements.forEach(e => transient.appendChild(e));

	const cancelBtn = transient.querySelector('.cancel');
	
	const tagElements = Array.from(transient.querySelectorAll('.tag'));
	tagElements.forEach(element => {
		element.addEventListener("click", e => {
			const tag = element.getAttribute("data-tag");
			webstrate.restore(tag);
			window.location.reload();
		});
	});
	
	const cancel = () => {
		transient.remove();
	};

	cancelBtn.addEventListener("click", e => {
		transient.remove();
	});

	document.body.appendChild(transient);
};</PRE></DIV><DIV class="paragraph style-paragraph collapsed" name="Show Tags Dialog Style" data-id="2yNTLyMH" __wid="78b5uDhf"><STYLE data-type="content" type="text/css" codemirror="true" __wid="bzJHtJky">.dialog .body {
	overflow: auto;
	max-height: calc(100vh - 260px);
}

.dialog ul {
	list-style-type: none;
	margin: 0;
	padding: 0;
}

.dialog ul li.tag {
	padding: 5px;
	cursor: pointer;
}

.dialog ul li.tag:hover {
	background-color: rgba(255, 255, 255, .1);
}</STYLE></DIV></DIV><DIV class="section section-hidden" name="Permissions" data-type="system" data-group="basic" data-id="2acKLAiX" __wid="VjUPf3x4"><DIV class="paragraph body-paragraph locked" name="Documentation" data-id="V97VARVD" draggable="false" __wid="yVGZXtxR"><DIV data-type="content" type="text/html" codemirror="true" contenteditable="false" class="section-documentation" __wid="BgDQpPLK"><H2 __wid="6szjVUyW">Description</H2>The permissions section adds a user interface to change permissions of the codestrate. The section adds a menu item to the global menu to access the permissions user interface through a dialog.</DIV></DIV><DIV class="paragraph data-paragraph locked collapsed" name="Properties" data-id="6W7YshS2" __wid="qRNSeYCX"><PRE data-type="content" type="application/json" class="section-properties" contenteditable="false" __wid="4tiX3rn5">{
	"version": "1.0",
	"dependencies": [],
	"description": "Lorem ipsum",
	"changelog":
	{
		"1.0": "Initital Release"
	}
}</PRE></DIV>

<DIV class="paragraph code-paragraph collapsed" run-on-load="true" name="Permission Code" draggable="false" last-execution-state="success" data-id="Z643HnjW" __wid="m4cDe7Pi"><PRE data-type="content" type="text/javascript" __wid="CbYXQjVa">var Permissions = (function () {

  this.version = "0.0.3";

  /**
   * Clear all document permissions aka. removes data-auth attribute.
   */
  const clearPermissions = function () {
    const htmlElement = document.documentElement;
    delete htmlElement.dataset.auth;
  };

  /**
   * Get permissions object of current document.
   */
  this.get = function () {
    const htmlElement = document.documentElement;
    const auth = htmlElement.dataset.auth;
    return auth ? JSON.parse(auth) : [];
  };

  /**
   * Applies permissions to current document.
   * 
   * @param [] auth Array containing document permissions (e.g., [{username:"raedle",
   * provider:"github",permissions:"rw"}.{username:"anonymous",provider:"",
   * permissions:"r"}])
   */
  this.set = function (auth) {
    const htmlElement = document.documentElement;

    if (auth && auth.length) {
      htmlElement.dataset.auth = JSON.stringify(auth);
    }
    else {
      clearPermissions();
    }
  };
	
  /**
   * Grant permissions to username using the given authentication provider.
   * 
   * @param String username Username of user that is granted specific permissions to
   * the current document.
   * @param String permissions Document permissions for username (e.g., "r" or "rw").
   * @param String provider="" Authentication provider, e.g., "github" for GitHub.
   */
  this.grant = function (username, permissions, provider = "") {
    const auth = getPermissions();
    const userPermission = auth.find(item => item.username === username && item.provider === provider);
    if (userPermission) {
      userPermission.permissions = permissions;
    }
    else {
      auth.push({
        username,
        provider,
        permissions
      });
    }

    set(auth);
  };

  /**
   * @param String username Revoke permissions for username.
   * @param String provider="" Revoke permissions given the particular authentication provider.
   */
  this.revoke = function (username, provider = "") {
    const auth = getPermissions();
    const permissionIndex = auth.findIndex(item => item.username === username && item.provider === provider);
    if (permissionIndex > -1) {
      auth.splice(permissionIndex, 1);
    }
		
    set(auth);
  };

  /**
   * List permissions of current document.
   */
  this.list = function () {
    const auth = getPermissions();
    console.log("Document permissions");
    auth.forEach(({username, permissions, provider}) => {
      console.log("Username %s has %s permissions using %s provider.", username, permissions, provider);
    });
  };

  return this;
}).call({});

window.webstrate.permissions = Permissions;</PRE></DIV><DIV class="paragraph code-paragraph collapsed" name="Permissions Dialog" run-on-load="true" last-execution-state="success" data-id="NDi9y4Pu" __wid="BTH3KKAa"><PRE data-type="content" type="text/javascript" __wid="BPCJRya5">Codestrate.showPermissions = () => {
	
	const transient = document.createElement("transient");
	transient.classList.add("permissions-dialog");
	
	const permissions = webstrate.permissions.get();
	
	let content = `
  &lt;table>
    &lt;thead>
      &lt;th>Username&lt;/th>
      &lt;th>Provider&lt;/th>
      &lt;th>Permissions&lt;/th>
      &lt;th>Delete&lt;/th>
    &lt;/thead>
    &lt;tbody id="permissions-list">
			${permissions.map((p) => {
				return `&lt;tr class="permission">
									&lt;td class="username" contenteditable="true">${p.username}&lt;/td>
									&lt;td class="provider" contenteditable="true">${p.provider}&lt;/td>
									&lt;td class="permissions" contenteditable="true">${p.permissions}&lt;/td>
									&lt;td class="delete">
   								  &lt;i class="material-icons">delete&lt;/i>
									&lt;/td>
								&lt;/tr>`;
			}).join("")}
    &lt;/tbody>
  &lt;/table>`;

	const elements = require('#dialog-template', {
		title: "Codestrate permissions",
		message: content,
		actions: `
			&lt;div class="button add">Add&lt;/div>
			&lt;div class="button apply">Apply&lt;/div>
  		&lt;div class="button close">Close&lt;/div>
		`
	});

	elements.forEach(e => transient.appendChild(e));

	const addBtn = transient.querySelector('.add');
	const applyBtn = transient.querySelector('.apply');
	const closeBtn = transient.querySelector('.close');
	const list = transient.querySelector('#permissions-list');
	
	const tagElements = Array.from(transient.querySelectorAll('.tag'));
	tagElements.forEach(element => {
		element.addEventListener("click", e => {
			const tag = element.getAttribute("data-tag");
			webstrate.restore(tag);
			window.location.reload();
		});
	});
	
	list.addEventListener("click", (event) => {
		const target = event.target;
		if (target.closest('.delete')) {
			let permission = target.closest('.permission');
			console.log('permission', permission);
			permission.remove();
		}
	});
	
	const add = () => {
		const newPermission = document.createElement("tr");
		newPermission.classList.add("permission");
		newPermission.innerHTML = `
			&lt;td class="username" contenteditable="true">&lt;/td>
			&lt;td class="provider" contenteditable="true">&lt;/td>
			&lt;td class="permissions" contenteditable="true">&lt;/td>
			&lt;td class="delete">
				&lt;i class="material-icons">delete&lt;/i>
			&lt;/td>
		`;
		list.appendChild(newPermission);
	};
	
	const apply = () => {
		
		let elementPermissions = Array.from(list.querySelectorAll('.permission'));
		let permissions = elementPermissions.map((p) => {
			return {
				username: p.querySelector('.username').textContent,
				provider: p.querySelector('.provider').textContent,
				permissions: p.querySelector('.permissions').textContent,
			};
		});
		
		console.log(permissions);
		
		webstrate.permissions.set(permissions);
		
		transient.remove();
	};
	
	const close = () => {
		transient.remove();
	};
	
	addBtn.addEventListener("click", add);
	applyBtn.addEventListener("click", apply);
	closeBtn.addEventListener("click", close);

	document.body.appendChild(transient);
};</PRE></DIV><DIV class="paragraph style-paragraph collapsed" data-id="n86qmxNM" name="Permissions Dialog" __wid="36xKvi5T"><STYLE data-type="content" type="text/css" codemirror="true" __wid="RFid9Eaa">.permissions-dialog {
	cursor: default;
}

.permissions-dialog .dialog {
	min-width: 500px !important;
}

.permissions-dialog .dialog table {
	width: 100%;
}

.permissions-dialog .dialog th {
	text-align: left;
}

.permissions-dialog table tr:hover {
	background-color: rgba(255, 255, 255, .1);
}

.permissions-dialog .delete {
	cursor: pointer;
}

.permissions-dialog .delete:hover i {
	color: red;
}</STYLE></DIV></DIV><DIV class="section section-hidden" name="Paragraph as Data" data-type="system" data-group="basic" data-id="YyuMHDM2" __wid="wa3Z9wpm"><DIV class="paragraph body-paragraph locked" draggable="false" name="Documentation" data-id="VTaB3pMn" style __wid="C7xiPtvP"><DIV data-type="content" type="text/html" codemirror="true" contenteditable="false" class="section-documentation" __wid="AUT3RXuD"><H2 __wid="bndaQRAN">Description</H2><DIV __wid="Qx66dP6Q">This section allows to share program states (object states) between connected clients. It provides a function to load the content of a content paragraph as a JavaScript object and properties set to this JavaScript object will update the content paragaph. The content of the content paragraph is then synchronized with other clients connected to this codestrate. If another client also loaded the content paragraph as JavaScript object, it will automatically update the object state/property as well.</DIV><DIV __wid="XkWEGzfW"><BR __wid="BRYfTiY5"/></DIV><DIV __wid="E8M4ZGEq">This section is still experimental. An example of how to use the section functionality can be found in the json2dom Example paragraph below.</DIV></DIV></DIV><DIV class="paragraph code-paragraph" last-execution-state="success" style name="json2dom Example" data-id="gnGDZu5j" draggable="false" __wid="RRyxYrMD"><PRE data-type="content" type="text/javascript" __wid="Anp4mF3B">let json2dom = require("#json2dom", null, false).load;
window.data = json2dom("#json2dom-example");

document.querySelector("#json2dom-example").innerHTML = "";

data.off("change");

data.test = { 
	subProp: {
		abc: 1.23
	}
};

data.test.off("change");

data.test.on("change", (event) => {
	window.console.log("test change:", event);
});

data.test.propertyChanged("abc", (value) => {
	window.console.log("abc property changed:", value);
});

data.test.abc = "abc";

data.test = { abc: { a: 1.234, b: "c" } };
data.test.abc = { a: 1.234 };
data.test.abc = "1.234";
data.test.abc = 1.234;
data.test.abc = 1.234;
data.test.abc = { a: 1.234 };
data.test = { abc: { a: 1.234, b: "c" } };
data.test.abc = "abc";</PRE></DIV><DIV class="paragraph data-paragraph locked collapsed" name="Properties" data-id="yJAtqUkj" __wid="TY22TCFF"><PRE data-type="content" type="application/json" class="section-properties" contenteditable="false" __wid="GKAWyzgd">{
	"version": "1.0",
	"description": "Lorem ipsum",
	"changelog":
	{
		"1.0": "Initital Release"
	}
}</PRE></DIV>

<DIV class="paragraph body-paragraph" style name="json2dom Example Data" draggable="false" data-id="sEem4VBU" __wid="6Bhr2ZRv"><DIV data-type="content" type="text/html" codemirror="true" contenteditable="true" id="json2dom-example" class="json2dom" __wid="An98TJyf"><ENTRY key="test" type="object" contenteditable="true" __wid="2eAgZhgT"><ENTRY key="abc" type="string" contenteditable="true" __wid="b3qtgkGm">abc</ENTRY></ENTRY></DIV></DIV><DIV class="paragraph code-paragraph collapsed" draggable="false" style name="Event Handler" data-id="J2Z66tzM" __wid="bZHsHMZ9"><PRE data-type="content" type="text/javascript" id="event-handler" __wid="pRVaR5Aa">class EventHandler {

	constructor() {
		this._eventHandlers = {};
	}
	
	addEventListener(name, handler) {
		if (!this._eventHandlers.hasOwnProperty(name)) {
			this._eventHandlers[name] = [];
		}
		let handlers = this._eventHandlers[name];
		handlers.push(handler);
	}

	removeEventListener(name, handler = undefined) {
		if (!this._eventHandlers.hasOwnProperty(name)) {
			return;
		}

		// remove all handlers for this event
		if (!handler) {
			delete this._eventHandlers[name];
			return;
		}

		let handlers = this._eventHandlers[name];
		let idx = handlers.indexOf(handler);
		handlers.splice(idx, 1);
	}

	dispatchEvent(name, event) {
		if (this._eventHandlers.hasOwnProperty(name)) {
			let handlers = this._eventHandlers[name];
			for (let i = 0; i &lt; handlers.length; i++) {
				handlers[i](event);
			}
		}
	}

	on(name, handler) {
		// split in individual events, e.g. "change refresh execute" will
		// be ["change", "refresh", "execute"]
		let names = name.match(/\S+/g) || [];
		for (let i = 0; i &lt; names.length; i++) {
			let name = names[i];
			this.addEventListener(name, handler);
		}
	}

	off(name, handler = undefined) {
		// split in individual events, e.g. "change refresh execute" will
		// be ["change", "refresh", "execute"]
		let names = name.match(/\S+/g) || [];
		for (let i = 0; i &lt; names.length; i++) {
			let name = names[i];
			this.removeEventListener(name, handler);
		}
	}
}

exports.EventHandler = EventHandler;</PRE></DIV><DIV class="paragraph code-paragraph collapsed" style name="JSON2DOMHandler" data-id="T9Fy6bUK" __wid="vPTq3xAQ"><PRE data-type="content" type="text/javascript" id="json2dom" __wid="2hMGRW4b">const {
  EventHandler
} = require('#event-handler');

class JSON2DOMHandler {
  constructor(node, rootNode = false, isArray = false) {
    this.node = node;
    this.rootNode = rootNode;
		this.isArray = isArray;

    if (rootNode) {

      this.eventHandler = new EventHandler();

      // version to keep track when change event handler was added and when property updated, for
      // reason see custom dispatch event below
      this.triggerVersion = 0;

      // custom dispatch event that checks for addedAt property to avoid race conditions with
      // mutation observer
      let that = this;
      this.eventHandler.dispatchEvent = function (name, event) {
        if (this._eventHandlers.hasOwnProperty(name)) {
          let handlers = this._eventHandlers[name];
          for (let i = 0; i &lt; handlers.length; i++) {
            let handler = handlers[i];
            // check if handler was added before property updated, and NOT after
            // 						window.console.log(handler.addedAtVersion, that.updatedAtVersion);
            if (handler.addedAtVersion &lt;= that.updatedAtVersion) {
              handler(event);
            }
          }
        }
      }.bind(this.eventHandler);
			
			const addNode = (nodes, node) => {
				
				// ignore node
				// Also test if parent element exits. This is important because if a property is set and
				// then immediately delete using the delete keyword, it is removed from the DOM, but the
				// mutation observer still contains the operation for when the property was added to the
				// DOM.
				//
				// Example:
				//
				// ```
				// obj.foobar = "baz";
				// delete obj.foobar;
				// ```
				//
				if (node.nodeType !== Node.ELEMENT_NODE || !document.body.contains(node)) {
					return;
				}
				
				for (let i = 0; i &lt; nodes.length; i++) {
					let aNode = nodes[i];
					
					// don't add nodes twice
					if (aNode === node) {
						return;
					}
					
					// is in hierarchy
					if (aNode.contains(node)) {
						return;
					}
					
					// swap nodes if new node contains existing node
					if (node.contains(aNode)) {
						nodes.splice(i, 1, node);
						return;
					}
				}
				
				// add node
				nodes.push(node);
			};

      let observer = new MutationObserver((mutations) => {
//         				window.console.log(mutations);
				
				let nodes = [];
				
        mutations.forEach((mutation) => {
          if (mutation.type === "childList") {
            Array.prototype.forEach.call(mutation.addedNodes, (node) => {
							addNode(nodes, node);
            });
          } else if (mutation.type === "characterData") {
            // get actual node element
            let node = mutation.target.parentElement;
						addNode(nodes, node);
					} else if (mutation.type === "attributes") {
						// get actual node element
						let node = mutation.target;
						addNode(nodes, node);
          }
        });
				
// 				console.log('nodes', nodes);
								
				nodes.forEach((node) => {
					this._triggerChanged(node);
				});
      });
      observer.observe(node, {
        childList: true,
        subtree: true,
        characterData: true,
        attributes: true,
        attributeFilter: ["type"]
      });
    }
  }

  get rootHandler() {
    let currentNode = this.node;
    while (!currentNode.__JSON2DOMHandler.rootNode) {
      currentNode = currentNode.parentElement;
    }
    return currentNode.__JSON2DOMHandler;
  }

  get propPath() {
    let paths = [];
    let currentNode = this.node;
    while (!currentNode.__JSON2DOMHandler.rootNode) {
      let path = currentNode.getAttribute("key");
      paths.splice(0, 0, path);
      currentNode = currentNode.parentElement;
    }
    return paths.join('_');
  }

  _triggerChanged(node) {
		
    let parentElement = node.parentElement;
    let parentHandler = parentElement.__JSON2DOMHandler;
    let parentProxy;
    if (!parentHandler) {
			let type = parentElement.getAttribute("type");
      createProxy(parentElement, false, type === "array");
      parentHandler = parentElement.__JSON2DOMHandler;
    }
		
    if (node) {
      let propName = node.getAttribute("key");
      let value = parentHandler.proxy[propName];
			let handler = node.__JSON2DOMHandler;
			if (!handler) {
				let type = node.getAttribute("type");
				createProxy(node, false, type === "array");
				handler = node.__JSON2DOMHandler;
			}
			let eventName = `change_${handler.propPath}`;

// 			console.log(`_triggerChanged for property "${propName}" with event name "${eventName}"`, this.eventHandler);
// 			window.console.log('proxy', this.proxy);

      this.eventHandler.dispatchEvent(eventName, {
        propName,
        value
      });
    } else {
      window.console.log('node does not have handler', node);
    }
  }

	_createValue(node) {
		let type = node.getAttribute("type");
		switch (type) {
			case "string":
				return node.firstChild.nodeValue;
			case "number":
				return Number(node.firstChild.nodeValue);
			case "boolean":
				return node.firstChild.nodeValue === "true";
			case "array":
// 				return this._getArrayValue(node);
				return createProxy(node, false, true);
			case "object":
				return createProxy(node);
			default:
				return null;
		}
	}
	
	_getArrayValue(node) {
		let entries = this.node.querySelectorAll(':scope>entry[key]');
		return Array.prototype.map.call(entries, (entry) => {
			return this._createValue(entry);
		});
	}

  get(obj, propName) {
		
// 		window.console.log('get prop', propName, this.isArray);

		// return event functions
		switch (propName) {
			case "_isArray":
				return this.isArray;
			case "on":
				return (name, handler) => {
					let json2domHandler = this.rootHandler;
					handler.addedAtVersion = ++json2domHandler.triggerVersion;
					json2domHandler.updatedAtVersion = handler.addedAtVersion;
					let newName = `${name}_${this.propPath}`;
					json2domHandler.eventHandler.addEventListener.call(json2domHandler.eventHandler, newName, handler);
				};
			case "off":
				return (name, handler) => {
					let json2domHandler = this.rootHandler;
					let newName = `${name}_${this.propPath}`;
					json2domHandler.eventHandler.removeEventListener.call(json2domHandler.eventHandler, newName, handler);
				};
			case "propertyChanged":
				return (propName, changeHandler) => {
					let json2domHandler = this.rootHandler;
					let parentPath = this.propPath;
					let propPath = parentPath && parentPath !== "" ? `${parentPath}_${propName}` : propName;
					let newName = `change_${propPath}`;
					let handler = (event) => {
						if (event.propName === propName) {
							changeHandler(event.value);
						}
					};
					handler.addedAtVersion = ++json2domHandler.triggerVersion;
					json2domHandler.updatedAtVersion = handler.addedAtVersion;
					
					json2domHandler.eventHandler.addEventListener.call(json2domHandler.eventHandler, newName, handler);
				};
    }
		
		// Workaround for arrays because arrays get also wrapped in a proxy, but then
		// the proxy object is an object and not an array and does not exhibit array
		// functions. Therefore, array functions need to be passed to the caller if
		// it is an actual array function
		let type = this.node.getAttribute("type");
		if (type === "array") {
			
// 			window.console.log('calling prop name on array', propName, Array.prototype.hasOwnProperty(propName));
			
			if (propName === "toJSON") {
				let type = this.node.getAttribute("type");
				if (type === "array") {
					return () => {
						return this._getArrayValue(this.node);
					};
				}
			}
			else if (Array.prototype.hasOwnProperty(propName)) {
				let value = this._createValue(this.node);
				let origMethod = Array.prototype[propName];
				
				if (typeof origMethod === 'function') {
					return function (...args) {
						return origMethod.apply(value, args);
					};
				}
				
				let arrayValue = this._getArrayValue(this.node);
				return arrayValue[propName];
			}
		}

		let childNode = this.node.querySelector(`:scope>entry[key="${propName}"]`);
    if (!childNode) return undefined;
    return this._createValue(childNode);
  }

  set(target, propName, value) {

//     		window.console.log('set prop', propName, value);

    // add updated at property on handler to decide if change event should be triggered because
    // mutations might be triggered after change event was registered even property was changed
    // before event was registered
    let json2domHandler = this.rootHandler;
    json2domHandler.updatedAtVersion = ++json2domHandler.triggerVersion;

    // check if value is an array or get type of value --> reset type in case property type changes
    let type = Array.isArray(value) ? "array" : typeof value;
		if (type === "object" && value._isArray) {
			 type = "array";
		}
		
		// get parent type because array items need to be treated differently
		let parentType = this.node.getAttribute("type");
		
		// ignore	if parent is an array, it might be a call to set new array length,
		// e.g., when an element was pushed or splice was called
		if (parentType === "array" && Array.prototype.hasOwnProperty(propName)) {
			return true;
		}
		
    // create new child node if it does not exist === property does not exist
		let childNode = this.node.querySelector(`:scope>entry[key="${propName}"]`);
		let existed = !!childNode;
    if (!childNode) {
      childNode = document.createElement("entry");
      childNode.setAttribute("key", propName);
      childNode.setAttribute("type", type);
			
			if (parentType === "array") {
				childNode.setAttribute("is-array-item", "true");
			}
			
      childNode.setAttribute("contenteditable", "true");
      this.node.appendChild(childNode);
    }

    let prevType = childNode.getAttribute("type");
		if (prevType !== type) {
			childNode.setAttribute("type", type);
		}

    if (type === "object" || type === "array") {

      // clear eventually existing nodes, otherwise it will end in a broken JSON state
			// reset attribute to trigger mutation and only event for this node is triggered
			if (existed) {
				childNode.remove();
				this.node.appendChild(childNode);
			}
			
			childNode.innerHTML = "";

      var childObject = createProxy(childNode, false, type === "array");
      for (let childProp in value) {
				childObject[childProp] = value[childProp];
      }
    } else {
      // check if new value differes from current value
      if (childNode.innerText !== String(value)) {
        childNode.innerText = value;
      }
    }

    return true;
  }
	
	getPrototypeOf(target) {
		let type = this.node.getAttribute("type");
// 		window.console.log('get prototype of', type, target);
		switch (type) {
			case "string":
				return String.prototype;
			case "number":
				return Number.prototype;
			case "boolean":
				return Boolean.prototype;
			case "array":
				return Array.prototype;
			case "object":
				return Object.prototype;
		}
		return undefined;
	}
	
	getOwnPropertyDescriptor(target, propName) {
		let childNode = this.node.querySelector(`:scope>entry[key="${propName}"]`);
		let type = childNode.getAttribute("type");
		let value = this._createValue(childNode);
		
		if (type === "object" || type === "array") {
			return {
				writable: true,
				enumerable: true,
				configurable: true,
				value: value
			};
		}
		return Object.getOwnPropertyDescriptor({ _wonkyHack: value }, '_wonkyHack');
  }
	
	ownKeys(target) {
		let entries = this.node.querySelectorAll(':scope>entry[key]');
		return Array.prototype.map.call(entries, (entry) => {
			return entry.getAttribute("key");
		});
  }
	
	has(target, propName) {
		return !!this.node.querySelector(`:scope>entry[key="${propName}"]`);
  }

  deleteProperty(target, propName) {
		let childNode = this.node.querySelector(`:scope>entry[key="${propName}"]`);
    if (childNode) {
      // TODO use Proxy.revocable() to call proxy.revoke() on remote objects to signal that they are
      // outdated
      childNode.remove();
      return true;
    }
    return false;
  }
}

function createProxy(node, rootNode = false, isArray = false) {
  // bi-directional binding needed for changed events
  let handler = node.__JSON2DOMHandler;
	
	if (!handler) {
		handler = new JSON2DOMHandler(node, rootNode, isArray);
		// handler is needed to trigger change events
		node.__JSON2DOMHandler = handler;
	}

  let proxy = new Proxy({}, handler);
  handler.proxy = proxy;
  node.proxy = proxy;

  return proxy;
}

exports.load = (selector) => {
  let node = document.querySelector(selector);
  // second parameter is to enable observer to allow for change events
  return createProxy(node, true);
};</PRE></DIV><DIV class="paragraph style-paragraph collapsed" draggable="false" style name="json2dom Style" data-id="pxEpcrNt" __wid="B7b9rJYg"><STYLE data-type="content" type="text/css" codemirror="true" __wid="9W9KxNsQ">.json2dom {
	padding: 10px;
	font-family: "Menlo", monospace;
	color: black;
	background-color: white;
	user-select: none;
}

.json2dom:before {
	content: "{";
}

.json2dom:after {
	content: "}";
}

.json2dom entry {
	display: block;
	padding-left: 20px;
	outline: 0;
	caret-color: black;
}

.json2dom entry:before,
.json2dom entry:after {
	color: black;
	pointer-events: none;
	display: inline;
}

.json2dom entry[type="boolean"],
.json2dom entry[type="number"] {
	color: blue;
}

.json2dom entry[type="string"] {
	color: red;
}

.json2dom entry:before {
	content: attr(key) ": ";
}

.json2dom entry[type="string"]:before {
	content: attr(key) ": \"";
}

.json2dom entry[type="string"]:after {
	content: "\"";
}

.json2dom entry[type="boolean"]:after,
.json2dom entry[type="number"]:after {
	content: "";
}

.json2dom entry[type="object"]:before {
	content: attr(key) ": {";
}

.json2dom entry[type="object"]:after {
	content: "}";
}

.json2dom entry[type="array"]:before {
	content: attr(key) ": [";
}

.json2dom entry[type="array"]:after {
	content: "]";
}

.json2dom entry[is-array-item]:before {
	content: "";
}

.json2dom entry[type="string"][is-array-item]:before {
	content: "\"";
}

.json2dom entry[type="object"][is-array-item]:before {
	content: "{";
}

.json2dom entry[type="array"][is-array-item]:before {
	content: "[";
}</STYLE></DIV></DIV><DIV class="section section-hidden" name="Global Menu" data-type="system" data-group="basic" data-id="9LquKSJE" __wid="bqGPqT8U"><DIV class="paragraph body-paragraph locked" draggable="false" name="Documentation" data-id="KDD29nq9" __wid="Pnwng5je"><DIV data-type="content" type="text/html" codemirror="true" contenteditable="false" class="section-documentation" __wid="FRUhk9us"><H2 __wid="FC58bYkL">Description</H2><DIV __wid="g6vC3s2W">The global menu adds a sliding menu to the codestrate. For example, the global menu allows to create new sections, change codestrate permissions, tag and restore a codestrate, change the codestrate document title, pull system sections from another codestrate, allows to invite other users to the codestrate, allows to show and hide sections, and toggle between the default and plain theme.</DIV></DIV></DIV><DIV class="paragraph data-paragraph locked collapsed" name="Properties" data-id="R2Gx7nZ3" __wid="phfwbaqN"><PRE data-type="content" type="application/json" class="section-properties" contenteditable="false" __wid="RxrAeVnG">{
	"version": "1.0",
	"description": "Lorem ipsum",
	"changelog":
	{
		"1.0": "Initital Release"
	}
}</PRE></DIV>

<DIV class="paragraph body-paragraph collapsed" draggable="false" style name="Global Menu Template" data-id="sP2y6U2W" __wid="wQABPX4V"><DIV data-type="content" type="text/html" codemirror="true" contenteditable="true" __wid="dUGfBEiz"><TEMPLATE id="global-menu-template" __wid="vrnF2Fyk">
	<TRANSIENT id="global-menu" class="closed" __wid="b2UGDEtX">
		<SPAN class="handle" __wid="iBQyYzaw"></SPAN>
		<DIV class="content" __wid="8ezCScez"></DIV>
	</TRANSIENT>
</TEMPLATE></DIV></DIV><DIV class="paragraph code-paragraph collapsed" draggable="false" style name="Add Global Menu" run-on-load="true" data-id="pa2PDQ5T" __wid="TPkWCuwx"><PRE data-type="content" type="text/javascript" __wid="kn7s9adQ">// The global menu.
let globalMenuTemplate = document.querySelector('#global-menu-template');
let globalMenuFragment = document.importNode(globalMenuTemplate.content, true);
let globalMenu = globalMenuFragment.querySelector('#global-menu');

// Handle to open and close the global menu.
const handle = globalMenu.querySelector('.handle');
handle.setAttribute("class", "handle");
handle.addEventListener("click", () => {
	const GlobalMenuUtils = require('#global-menu-utils');
  GlobalMenuUtils.toggle();
});

// Close menu on click outside of global menu.
/*window.addEventListener("click", event => {
  if (!event.target.closest('#global-menu')) {
    globalMenu.classList.add("closed");
  }
});*/

document.body.appendChild(globalMenuFragment);</PRE></DIV><DIV class="paragraph code-paragraph collapsed" style draggable="false" name="Global Menu Utils" data-id="H9YMLbvG" __wid="CKBY98Xp"><PRE data-type="content" type="text/javascript" id="global-menu-utils" __wid="qm7KcBKg">const globalMenu = document.querySelector('#global-menu');
const content = globalMenu.querySelector('.content');

exports.open = () => {
	globalMenu.classList.remove("closed");
};

exports.close = () => {
	globalMenu.classList.add("closed");
};

exports.toggle = () => {
	globalMenu.classList.toggle("closed");
};

exports.addDivider = () => {
  const divider = document.createElement("hr");
  content.appendChild(divider);
};

exports.addMenuItem = (menuItem) => {
	content.appendChild(menuItem);
};</PRE></DIV><DIV class="paragraph code-paragraph collapsed" name="Global Menu Code" draggable="false" style run-on-load="true" data-id="7aMu3qpU" __wid="CuWmWgnb"><PRE data-type="content" type="text/javascript" __wid="SisFEUwe">const GlobalMenuUtils = require('#global-menu-utils');

const createButton = (name, classNames, action) => {
  const button = document.createElement("button");
  button.innerText = name;
  
  if (classNames) {
    button.setAttribute("class", classNames);
  }
  
  if (typeof action === 'function') {
    button.addEventListener("click", action);
  }
  
  return button;
};

let createSection = createButton("Create section", null, () => {
  const section = document.createElement("div");
  section.classList.add("section");
  section.classList.add("section-visible");
	
	const sections = document.querySelector('#sections');
	sections.appendChild(section);
});

let createCodestrateCopy = createButton("Create copy of codestrate", null, () => {
	GlobalMenuUtils.close();
	window.location = `/${webstrate.webstrateId}/?copy`;
});

let tagCodestrate = createButton("Tag codestrate", null, () => {
	GlobalMenuUtils.close();

	(async() => {
		const name = await prompt('Set tag name', "", "Tag codestrate");
		if (name) {
			webstrate.tag(name);
		}
	})();
});

let restoreCodestrate = createButton("Restore codestrate", null, () => {
	GlobalMenuUtils.close();
  Codestrate.showTags();
});

let changeCodestratePermissions = createButton("Change codestrate permissions", null, () => {
	GlobalMenuUtils.close();
  Codestrate.showPermissions();
});

GlobalMenuUtils.addMenuItem(createSection);
GlobalMenuUtils.addDivider();
GlobalMenuUtils.addMenuItem(createCodestrateCopy);
GlobalMenuUtils.addMenuItem(tagCodestrate);
GlobalMenuUtils.addMenuItem(restoreCodestrate);
GlobalMenuUtils.addMenuItem(changeCodestratePermissions);</PRE></DIV><DIV class="paragraph code-paragraph collapsed" name="Change Codestrate Title" last-execution-state="success" run-on-load="true" draggable="false" style data-id="Vjge2uGj" __wid="8AkiErbv"><PRE data-type="content" type="text/javascript" __wid="gWPvaKCH">const GlobalMenuUtils = require('#global-menu-utils');

const changeDocumentTitleAction = document.createElement('button');
changeDocumentTitleAction.innerHTML = "Change codestrate title";
changeDocumentTitleAction.addEventListener("click", event => {
	
	(async() => {
		let title = await prompt("Type in the new title of this codestrate!", document.title, "Codestrate Title");
		if (title) {
			document.title = title;
		}
	})();
});

GlobalMenuUtils.addDivider();
GlobalMenuUtils.addMenuItem(changeDocumentTitleAction);</PRE></DIV></DIV><DIV class="section section-hidden" name="The Codestrate Code" data-type="system" data-group="editing" data-id="RWxfFGXB" __wid="ZaHhaQ4k">
        
    <DIV class="paragraph body-paragraph locked" name="Documentation" draggable="false" data-id="5du9n32b" __wid="7kGhPvKx"><DIV data-type="content" type="text/html" class="section-documentation" contenteditable="false" codemirror="true" __wid="H3jbYVaq"><H2 __wid="swqqqDYi">Description</H2>This section is the nucleus of how the codestrate started. It organically grew with new features being introduced over the course of time. We have started to dissect the section and move paragraphs to their own sections. Yet, the development and use of Codestrates is very organic and we haven't entirely refactored the Codestrates prototype. But, this section will possibly fade away over time.<DIV __wid="dYtTzU6A"><BR __wid="kg4Gq6Ys"/></DIV><DIV __wid="HunfsFy9">At the moment, it still contains paragraphs that create the transient user interface for paragraphs such as paragraph headers and paragraph actions (e.g., lock, delete, collapse, and move paragraph).</DIV></DIV></DIV><DIV class="paragraph data-paragraph locked collapsed" name="Properties" data-id="9Tcd2zNW" __wid="xi3egBeD"><PRE data-type="content" type="application/json" class="section-properties" contenteditable="false" __wid="M9ghHi6V">{
	"version": "1.0",
	"description": "Lorem ipsum",
	"changelog":
	{
		"1.0": "Initital Release"
	}
}</PRE></DIV>

<DIV class="paragraph style-paragraph collapsed" draggable="false" name="Animations (@keyframes)" style data-id="ia4CUjdL" __wid="QtQfMVPZ"><STYLE data-type="content" type="text/css" codemirror="true" __wid="d9VjBiNU">/* The animation code */
@keyframes blink-cursor {
    from { opacity: 1.0; }
    to { opacity: 0.0; }
}</STYLE></DIV><DIV class="paragraph code-paragraph collapsed" draggable="false" name="DOM Utils" run-on-load="true" style data-id="TwAVFiuS" __wid="gxMFTjsB"><PRE data-type="content" type="text/javascript" id="dom-utils" __wid="P8uQanHT">const HTMLUtils = window.HTMLUtils = (function () {

	this.getCaretPosition = function (editableDiv) {
		var caretPos = 0,
				sel, range;
		if (window.getSelection) {
			sel = window.getSelection();
			if (sel.rangeCount) {
				range = sel.getRangeAt(0);
				if (range.commonAncestorContainer.parentNode == editableDiv) {
					caretPos = range.endOffset;
				}
			}
		} else if (document.selection && document.selection.createRange) {
			range = document.selection.createRange();
			if (range.parentElement() == editableDiv) {
				var tempEl = document.createElement("span");
				editableDiv.insertBefore(tempEl, editableDiv.firstChild);
				var tempRange = range.duplicate();
				tempRange.moveToElementText(tempEl);
				tempRange.setEndPoint("EndToEnd", range);
				caretPos = tempRange.text.length;
			}
		}
		return caretPos;
	};
	
	this.setCaretPosition = function(editableDiv, position) {

		// Only set new caret position if position > 0
		if (position &lt;= 0) return;
		
		
		var textNode = editableDiv.firstChild;
		var range = document.createRange();
		range.setStart(textNode, position);
		range.setEnd(textNode, position);
		var sel = window.getSelection();
		sel.removeAllRanges();
		sel.addRange(range);
	};

	this.pasteHtmlAtCaret = function (html) {
		var sel, range;
		if (window.getSelection) {
			// IE9 and non-IE
			sel = window.getSelection();
			if (sel.getRangeAt && sel.rangeCount) {
				range = sel.getRangeAt(0);
				range.deleteContents();

				// Range.createContextualFragment() would be useful here but is
				// non-standard and not supported in all browsers (IE9, for one)
				var el = document.createElement("div");
				el.innerHTML = html;
				var frag = document.createDocumentFragment(), node, lastNode;
				while ((node = el.firstChild)) {
					lastNode = frag.appendChild(node);
				}
				range.insertNode(frag);

				// Preserve the selection
				if (lastNode) {
					range = range.cloneRange();
					range.setStartAfter(lastNode);
					range.collapse(true);
					sel.removeAllRanges();
					sel.addRange(range);
				}
			}
		} else if (document.selection && document.selection.type != "Control") {
			// IE &lt; 9
			document.selection.createRange().pasteHTML(html);
		}
	};

	this.appendChildAtCaret = function (child, beforeInsert) {

		if (window.getSelection) {
			
			// IE9 and non-IE
			const selection = window.getSelection();

			let range;
			if (selection.focusNode && selection.getRangeAt && selection.rangeCount) {
				range = selection.getRangeAt(0);
			}
			else {
				range = HTMLUtils.lastRange;
			}

			if (range) {

				// Check if child should be inserted at range.
				if (typeof beforeInsert === 'function') {
					if (!beforeInsert(range)) {
						return false;
					}
				}

				range.deleteContents();
				range.insertNode(child);

				// Preserve the selection
				if (child) {
					range = range.cloneRange();
					range.setStartAfter(child);
					range.collapse(true);
					selection.removeAllRanges();
					selection.addRange(range);
				}

				return true;
			}
		}
		else {
			throw new Error(`Append child at caret is not supported.`);
		}

		return false;
	};

	return this;
}).call({});

/**
 * This is a hack for iOS devices where the selection on contenteditable
 * changes when clicking a button.
 */
document.addEventListener("selectionchange", event => {

	if (window.getSelection) {
		const selection = window.getSelection();

		let node = selection.focusNode;
		if (node) {
			
			const range = selection.getRangeAt(0);
			HTMLUtils.lastRange = range.cloneRange();

			if (node.nodeType === 3) {
				node = node.parentElement;
			}
			
			const bodyParagraphContent = node.closest('.paragraph.body-paragraph [data-type="content"][contenteditable]');
			
			if (bodyParagraphContent) {
				bodyParagraphContent._selectionRange = range.cloneRange();		
			}
		}
	}
});

/**
 *
 */
Element.prototype.appendChildAtCaret = function(child) {
	if (!this.isContentEditable) return;

	let range = this._selectionRange;

	if (range) {
// 		range.deleteContents();
		range.insertNode(child);

		if (window.getSelection) {
			const selection = window.getSelection();
			
			// Preserve the selection
			if (child) {
				range = range.cloneRange();
				range.setStartAfter(child);
				range.collapse(true);
				selection.removeAllRanges();
				selection.addRange(range);
			}
		}

		return true;
	}

	return false;
};</PRE></DIV><DIV class="paragraph code-paragraph collapsed" name="Action Utils" draggable="false" data-id="8GcNuGZD" __wid="KdgdqZ3m"><PRE data-type="content" type="text/javascript" id="action-utils" __wid="7ZUWaAD6">exports.create = (action, options = {}) => {
  
  options = Object.assign({
    classNames: null,
    text: null
  }, options);
  
  const button = document.createElement("div");
  button.setAttribute("class", "action" + (options.classNames ? " " + options.classNames : ""));
  button.addEventListener("click", action);
  
  if (options.text) {
    const text = document.createElement("span");
    text.setAttribute("class", "action-label");
    text.innerText = options.text;
    button.appendChild(text);
  }
	
	if (options.tooltip) {
		button.setAttribute("tooltip", options.tooltip);
	}

  const icon = document.createElement("i");
  icon.setAttribute("class", "material-icons");
  button.appendChild(icon);
  
  return button;
};</PRE></DIV><DIV class="paragraph code-paragraph collapsed" name="Section Code" draggable="false" run-on-load="true" style data-id="WPJxSYWH" __wid="R4ysGKU5"><PRE data-type="content" type="text/javascript" __wid="xJQVnKx4">const ActionUtils = require('#action-utils');
const ParagraphUtils = require('#paragraph-utils');

/**
 * Add a transient header to the section. This transient element will
 * contain all section specific actions, like collapse, and sortable.
 */
const addArticleHeader = (section) => {
  
	// Add section header only once.
	if (section.querySelector('.section-header')) return;
	
  const header = document.createElement("transient");
  header.setAttribute("class", "section-header");
  
  addEditableElement(section, header, "name");
  addEditableElement(section, header, "id");
  
  addDeleteAction(section, header);
	addToggleSystemSectionAction(section, header);
	// addTogglePackageSectionAction(section, header); // MB: Preparation for Package System
  addHideCollapsedParagraphsAction(section, header);
	
  addDataParagraphAction(section, header);
  addCodeParagraphAction(section, header);
  addStyleParagraphAction(section, header);
  addBodyParagraphAction(section, header);
  
  section.insertBefore(header, section.firstChild);
};

const addEditableElement = (section, header, attributeName) => {
  
  // Add title name element to header.
  const nameElement = document.createElement("span");
  nameElement.setAttribute("class", `${attributeName}-input`);
  nameElement.setAttribute("contenteditable", "true");
  
  section.liveAttribute(attributeName).changed(value => {
		// This fixes a bug introduced in Chrome 57 and Safari resulting in reverse
		// text input.
		let position = HTMLUtils.getCaretPosition(nameElement);
    nameElement.innerHTML = value || "";
		HTMLUtils.setCaretPosition(nameElement, position);
  });
  
  nameElement.addEventListener("input", function () {
    const name = nameElement.innerText;
    const hasName = !!name.trim().length;

    if (!hasName) {
      section.removeAttribute(attributeName);
    }
    else {
      section.setAttribute(attributeName, name);
    }
  });
  header.appendChild(nameElement);
};

const addDeleteAction = (section, header) => {
  const action = ActionUtils.create(() => {

    const name = section.getAttribute("name");

    let message = "Do you really want to delete this section?";
    if (name && name !== "") {
      message = "Do you really want to delete section " + name + " ?";
    }

    const result = confirm(message, "Delete Section");

		if (result instanceof Promise) {
			result.then(r => {
				if (r) {
					section.remove();
				}
			});
    }
		else if (result) {
			section.remove();
		}
  }, { classNames: "delete-section", tooltip: true });
  
  header.appendChild(action);
};

const addBodyParagraphAction = (section, header) => {
  const action = ActionUtils.create(() => {
    const paragraph = ParagraphUtils.createBodyParagraph();
    section.appendChild(paragraph);
  }, { classNames: "add-body-paragraph", tooltip: true });
  
  header.appendChild(action);
};

const addCodeParagraphAction = (section, header) => {
  const action = ActionUtils.create(() => {
    const paragraph = ParagraphUtils.createCodeParagraph();
    section.appendChild(paragraph);
  }, { classNames: "add-code-paragraph", tooltip: true });
  
  header.appendChild(action);
};

const addStyleParagraphAction = (section, header) => {
  const action = ActionUtils.create(() => {
    const paragraph = ParagraphUtils.createStyleParagraph();
    section.appendChild(paragraph);
  }, { classNames: "add-style-paragraph", tooltip: true });
  
  header.appendChild(action);
};

const addDataParagraphAction = (section, header) => {
  const action = ActionUtils.create(() => {
    const paragraph = ParagraphUtils.createDataParagraph();
    section.appendChild(paragraph);
  }, { classNames: "add-data-paragraph", tooltip: true });
  
  header.appendChild(action);
};

const addHideCollapsedParagraphsAction = (section, header) => {

  const action = ActionUtils.create(() => {
    section.classList.toggle("hide-collapsed-paragraphs"); 
  }, {
		classNames: "hide-collapsed-paragraphs2",
		tooltip: true
	});
  
  header.appendChild(action);
};


const addToggleSystemSectionAction = (section, header) => {
  
	const action = ActionUtils.create(() => {
    
    if (section.hasAttribute("data-type") && (section.getAttribute("data-type") === "system")) {
      section.removeAttribute("data-type");
    }
    else {
      section.setAttribute("data-type", "system");
    }
  }, {
		classNames: "toggle-system-section",
		tooltip: true
	});
  
  header.appendChild(action);
};

const addTogglePackageSectionAction = (section, header) => {
  
	const action = ActionUtils.create(() => {
    
    if (section.hasAttribute("data-type") && (section.getAttribute("data-type") === "package")) {
      section.removeAttribute("data-type");
    }
    else {
      section.setAttribute("data-type", "package");
    }
  }, {
		classNames: "toggle-package-section",
		tooltip: true
	});
  
  header.appendChild(action);
};

// Live query the body for existing sections on load and new sections added later.
const sectionQuery = document.liveQuerySelectorAll('.section').added(addArticleHeader);</PRE></DIV><DIV class="paragraph code-paragraph collapsed" name="Variable Code" draggable="false" run-on-load="true" style data-id="LkEsdkdw" __wid="izxJUZFX"><PRE data-type="content" type="text/javascript" __wid="5bsXatAq">window.Variable = function (name) {

  const variables = Array.from(document.querySelectorAll(`div.variable[data-name="${name}"]`));

  this.set = function (value) {
    variables.forEach(variable => {
      variable.innerHTML = value;
    });
  };

  this.setTransient = function (value) {
    variables.forEach(variable => {
      variable.innerHTML = `&lt;transient>${value}&lt;/transient>`;
    });
  };
	
	this.appendChild = function(child) {
		if (variables.length === 0) {
			console.warn(`Variable ${name} does not exist`);
		}
		
		if (variables.length > 1) {
			console.warn(`Variable.appendChild only applied to first variable`);
		}
		
		if (variables.length > 0) {
			variables[0].appendChild(child);
		}
	};

  return this;

}.bind({});</PRE></DIV><DIV class="paragraph code-paragraph collapsed" draggable="false" name="Paragraph Utils Code" style data-id="8SKMAbq9" __wid="gvL6hfCz"><PRE data-type="content" type="text/javascript" id="paragraph-utils" __wid="Qt2vC7bQ">const paragraphHeaderClass = "paragraph-header";

const createParagraph = (type) => {
	const paragraph = document.createElement("div");
	paragraph.classList.add("paragraph");
	paragraph.classList.add(`${type}-paragraph`);
	return paragraph;
};

exports.createBodyParagraph = (content = "") => {
	const paragraph = createParagraph("body");

	const contentContainer = document.createElement("div");
	contentContainer.setAttribute("data-type", "content");
	contentContainer.setAttribute("type", "text/html");
	contentContainer.setAttribute("codemirror", "true");
	contentContainer.contentEditable = true;
	contentContainer.innerHTML = content;

	paragraph.appendChild(contentContainer);

	return paragraph;
};

exports.createStyleParagraph = (style = "/* CSS here */", containerElement = "style") => {
	const paragraph = createParagraph("style");

	const styleContainer = document.createElement(containerElement);
	styleContainer.setAttribute("data-type", "content");
	styleContainer.setAttribute("type", "text/css");
	styleContainer.setAttribute("codemirror", "true");
	
	const textNode = document.createTextNode(style);
	styleContainer.appendChild(textNode);

	paragraph.appendChild(styleContainer);

	return paragraph;
};

exports.createCodeParagraph = (code = "// JavaScript code here") => {
	const paragraph = createParagraph("code");

	const codeContainer = document.createElement("pre");
	codeContainer.setAttribute("data-type", "content");
	codeContainer.setAttribute("type", "text/javascript");
	
	const textNode = document.createTextNode(code);
	codeContainer.appendChild(textNode);
	
	paragraph.appendChild(codeContainer);

	return paragraph;
};

exports.createDataParagraph = (data = "/* JSON here */") => {
	const paragraph = createParagraph("data");

	const dataContainer = document.createElement("pre");
	dataContainer.setAttribute("data-type", "content");
	dataContainer.setAttribute("type", "application/json");
	
	
	const textNode = document.createTextNode(data);
	dataContainer.appendChild(textNode);

	paragraph.appendChild(dataContainer);

	return paragraph;
};

/**
 * Get paragraph header or create a new transient header if it does not
 * exist.
 */
const getHeader = (paragraph) => {
  
  let header = paragraph.querySelector(`.${paragraphHeaderClass}`);
  if (!header) {
    header = document.createElement("transient");
    header.setAttribute("class", paragraphHeaderClass);
    paragraph.insertBefore(header, paragraph.firstChild);
  }
  return header;
};

/**
 * Get content element.
 */
const getContentElement = (paragraph) => {
  return paragraph.querySelector('[data-type="content"]');
};

exports.getHeaderElement = getHeader;
exports.getContentElement = getContentElement;

exports.addHeaderAction = (paragraph, className, action, options) => {
  
  let header = getHeader(paragraph);
  
  // Only add header action once.
  if (header.querySelector(`.${className}`)) return;
  
  const actionElement = document.createElement("div");
  actionElement.setAttribute("class", `action ${className}`);
  
  // Add action if defined.
  if (action) {
    actionElement.addEventListener("click", action);
  }
	
	// Add tooltip when provided as optional setting
	if (options && options.tooltip) {
		actionElement.setAttribute("tooltip", options.tooltip);
	}

  const icon = document.createElement("i");
  icon.setAttribute("class", "material-icons");
  actionElement.appendChild(icon);
  
  header.appendChild(actionElement);
  
  return actionElement;
};

exports.addEditableElement = (target, attributeName, proxyElement) => {
  
  // Only add editable element once.
  if (target.querySelector(`span.${attributeName}-input`)) return;
  
  // Add title name element to header.
  const nameElement = document.createElement("span");
  nameElement.setAttribute("class", `input ${attributeName}-input`);
  nameElement.setAttribute("contenteditable", "true");
  
  // Update when changing to the attribute happen (also remote updates).
  proxyElement.liveAttribute(attributeName).changed(value => {
		// This fixes a bug introduced in Chrome 57 and Safari resulting in reverse
		// text input.
		let position = HTMLUtils.getCaretPosition(nameElement);
    nameElement.innerHTML = value || "";
		HTMLUtils.setCaretPosition(nameElement, position);
  });
  
  nameElement.addEventListener("input", function () {
    const name = nameElement.innerText;
    const hasName = !!name.trim().length;

    if (!hasName) {
      proxyElement.removeAttribute(attributeName);
    }
    else {
      proxyElement.setAttribute(attributeName, name);
    }
  });
  target.appendChild(nameElement);
};</PRE></DIV><DIV class="paragraph code-paragraph collapsed" data-id="G87Cp7CG" run-on-load="true" name="Add data-ids to Sections and Paragraphs" __wid="snAVPWED"><PRE data-type="content" type="text/javascript" __wid="PrXC9xBn">document.liveQuerySelectorAll(".section, .paragraph").added(element => {
	if (!element.hasAttribute("data-id")) {
		element.setAttribute("data-id", Codestrate.util.randomString());
	}
});</PRE></DIV><DIV class="paragraph code-paragraph collapsed" name="Focussed Section" draggable="false" run-on-load="true" style data-id="drVmLP3i" __wid="3tKxRFU4"><PRE data-type="content" type="text/javascript" __wid="cL3pSN2D">window.addEventListener("click", function (event) {
  if (!event.target || !event.target.closest) return;

  if (!event.target.closest('.paragraph') && window.Codestrate.focussedSection) {
    window.Codestrate.focussedSection = null;
  }
});

window.addEventListener("focus", function (event) {
  if (!event.target || !event.target.closest) return;

  const paragraph = event.target.closest('.paragraph');

  if (paragraph === window.Codestrate.focussedSection) return;

  if (window.Codestrate.focussedSection) {
    window.Codestrate.focussedSection = null;
  }

  if (paragraph) {
    window.Codestrate.focussedSection = paragraph;
  }
}, true);</PRE></DIV><DIV class="paragraph code-paragraph collapsed" name="Paragraph Title Code" run-on-load="true" draggable="false" style data-id="mdyivJjZ" __wid="aZCX6Y4q"><PRE data-type="content" type="text/javascript" __wid="PUFaSeyi">const ParagraphUtils = require('#paragraph-utils');

document.liveQuerySelectorAll('.paragraph').added(paragraph => {
  
  const header = ParagraphUtils.getHeaderElement(paragraph);
  const content = ParagraphUtils.getContentElement(paragraph);
  
  ParagraphUtils.addEditableElement(header, "name", paragraph);
  ParagraphUtils.addEditableElement(header, "id", content);
  ParagraphUtils.addEditableElement(header, "class", content);
});</PRE></DIV><DIV class="paragraph code-paragraph collapsed" draggable="false" name="Paragraph Collapse Action Code" run-on-load="true" style data-id="TTfmS2at" __wid="Va76w2Zx"><PRE data-type="content" type="text/javascript" __wid="jXWMGcUb">const SectionUtils = require('#paragraph-utils');

const addCollapsibleAction = function(paragraph) {
  SectionUtils.addHeaderAction(paragraph, "collapse-expand", () => {
    paragraph.classList.toggle("collapsed");
  }, {
		tooltip: true
	});

  // CodeMirror requires a refresh on the editor if any of the parent or
  // container styles changed.
  const updateEditor = () => {
    
    const content = paragraph.querySelector('[data-type="content"]');
      
    if (content && content.__editor && content.__editor.editor) {
      content.__editor.editor.refresh();
    }
  };
  
  paragraph.liveAttribute("class").changed(updateEditor);
};

document.liveQuerySelectorAll('.paragraph').added(addCollapsibleAction);</PRE></DIV><DIV class="paragraph code-paragraph collapsed" name="Paragraph Sortable Action Code" draggable="false" run-on-load="true" last-execution-state="success" style data-id="Wn58bYws" __wid="XSp9LcSe"><PRE data-type="content" type="text/javascript" __wid="EHpTAckM">importLib("Sortable.js").then(() => {

  const ParagraphUtils = require('#paragraph-utils');

  const addSortableAction = function(paragraph) {
    ParagraphUtils.addHeaderAction(paragraph, "drag-handle");
		
		paragraph.addEventListener("dragstart", event => {
			let clonedNode = paragraph.cloneNode(true);
			clonedNode.classList.remove("dragging");
			clonedNode.removeAttribute("style");
			
			let transients = clonedNode.querySelectorAll('transient');
			Array.prototype.forEach.call(transients, transient => {
				transient.remove();
			});
			
			let html = clonedNode.outerHTML;
			
			let data = {
				webstrateId: webstrate.webstrateId,
				type: "paragraph",
				html: html
			};
			
			event.dataTransfer.setData('application/x-codestrate', JSON.stringify(data));
			
		}, false);
  };
	
	const initSortable = function(section) {
		
		/* events fired on the drop targets */
		section.addEventListener("dragover", event => {
			event.preventDefault();
		}, false);
		
		section.addEventListener("drop", event => {
			let plainData = event.dataTransfer.getData('application/x-codestrate');
			if (!plainData) return;
			
			let data = JSON.parse(plainData);
			
			// Drag and drop occured in the same codestrate, thus ignore it
			if (data.webstrateId === webstrate.webstrateId) {
				return;
			}
			
			let container = document.createElement("div");
			container.innerHTML = data.html;
			section.appendChild(container.children[0]);
		}, false);
		
    Sortable.create(section, {
      group: {
        name: "blocks"//,
        // pull: 'clone'
      },
      animation: 150,
      // sort: false,
      draggable: '.paragraph',
      handle: '.drag-handle',
      ghostClass: "dragging",  // Class name for the drop placeholder
      chosenClass: "dragging",  // Class name for the chosen item
      dragClass: "dragging",  // Class name for the dragging item
			
			scrollSensitivity: 30, // px, how near the mouse must be to an edge to start scrolling.
			scrollSpeed: 30, // px

      onChoose: function (/**Event*/evt) {

        if (window.Codestrate.focussedSection) {
          // removeConsole(window.Codestrate.focussedSection);
          window.Codestrate.focussedSection = null;
        }
      },

      // Element dragging started
      onStart: function (/**Event*/evt) {

        const codes = Array.from(document.querySelectorAll('pre[type],*[codemirror]'));
        codes.forEach(code => {
          if (code.__editor) {
            code.__editor.editor.setOption('dragDrop', false);
          }
        });
      },

      // Element dragging ended
      onEnd: function (/**Event*/evt) {
        const codes = Array.from(document.querySelectorAll('pre[type],*[codemirror]'));
        codes.forEach(code => {
          if (code.__editor) {
            code.__editor.editor.setOption('dragDrop', true);
          }
        });
      },
    });
  };

  document.liveQuerySelectorAll('.section').added(initSortable);
  document.liveQuerySelectorAll('.paragraph').added(addSortableAction);
});</PRE></DIV><DIV class="paragraph code-paragraph collapsed" name="Paragraph Delete Action Code" draggable="false" run-on-load="true" style data-id="js38GiLb" __wid="WNYw7paj"><PRE data-type="content" type="text/javascript" __wid="22KuqehR">const ParagraphUtils = require('#paragraph-utils');

const addDeleteAction = (paragraph) => {
  ParagraphUtils.addHeaderAction(paragraph, "delete-paragraph", () => {
      
    const name = paragraph.getAttribute("name");

    let message = "Do you really want to delete this paragraph?";
    if (name && name !== "") {
      message = "Do you really want to delete paragraph " + name + " ?";
    }
		
		const result = confirm(message, "Delete Paragraph");

		if (result instanceof Promise) {
			result.then(r => {
				if (r) {
					paragraph.remove();
				}
			});
    }
		else if (result) {
			paragraph.remove();
		}
  }, {
		tooltip: true
	});
};

document.liveQuerySelectorAll('.paragraph').added(addDeleteAction);</PRE></DIV><DIV class="paragraph code-paragraph collapsed" name="Lock Paragraph Code" run-on-load="true" draggable="false" style data-id="iqecX7XG" __wid="YZTVVRu2"><PRE data-type="content" type="text/javascript" contenteditable="true" __wid="5ZJCmCW3">const SectionUtils = require('#paragraph-utils');

const addLockAction = paragraph => {
  const lockElement = SectionUtils.addHeaderAction(paragraph, "lock-content", () => {
//     window.console.log('lock action');
    
    const content = paragraph.querySelector('[data-type="content"]');
    if (content) {
      if (!content.hasAttribute("contenteditable") || content.getAttribute("contenteditable") === "true") {
        content.setAttribute("contenteditable", "false");
      }
      else {
        content.setAttribute("contenteditable", "true");
      }
    }
  }, {
		tooltip: true
	});
  
  const content = paragraph.querySelector('[data-type="content"]');

//   window.console.log(content);

  if (content) {
    content.liveAttribute("contenteditable").changed((value, oldValue) => {
      const readOnly = value && value === "false" ? true : false;
      if (readOnly) {
        paragraph.classList.add("locked");
      }
      else {
        paragraph.classList.remove("locked");
      }
    });
  }
};

document.liveQuerySelectorAll('.paragraph').added(addLockAction);</PRE></DIV><DIV class="paragraph code-paragraph collapsed" name="Hash Scroll Code" run-on-load="true" style data-id="4rUSqsbU" __wid="vZVtYpaC"><PRE data-type="content" type="text/javascript" __wid="vpj9mX96">const element = document.getElementById(window.location.hash.substr(1));

if (element) {
  const scrollToElement = element.parentElement;

  window.addEventListener("codestrateloaded", () => {
    if (scrollToElement) {
      window.scrollTo(0, scrollToElement.getBoundingClientRect().top);
    }
  });
}</PRE></DIV></DIV><DIV class="section section-hidden" name="Fullscreen" data-type="system" data-group="editing" data-id="NhNX5mz9" __wid="iR6wWnRn"><DIV class="paragraph body-paragraph locked collapsed" draggable="false" name="Documentation" data-id="DExH2kba" __wid="UkW8q7ZK"><DIV data-type="content" type="text/html" codemirror="true" contenteditable="false" class="section-documentation" __wid="tBcr6DPi"><H2 __wid="7AJaaWtV">Description</H2>TODO</DIV></DIV><DIV class="paragraph data-paragraph locked collapsed" name="Properties" data-id="S5yMHJz2" __wid="Cihf96ea"><PRE data-type="content" type="application/json" class="section-properties" contenteditable="false" __wid="yYmakzmW">{
	"version": "1.0",
	"description": "Lorem ipsum",
	"changelog":
	{
		"1.0": "Initital Release"
	}
}</PRE></DIV>
<DIV class="paragraph code-paragraph collapsed" name="Paragraph Fullscreen Code" draggable="false" run-on-load="true" last-execution-state="success" style data-id="4nAY6Jw8" __wid="hL98ChWF"><PRE data-type="content" type="text/javascript" __wid="J5Fdbi8a">const FullscreenUtils = require('#fullscreen-utils');

importLib([
	"hammer.min.js",
	"hammer-time.min.js"
]).then(() => {
	
	const ParagraphUtils = require('#paragraph-utils');

	let addFullscreenButton = (paragraph) => {

		let header = ParagraphUtils.getHeaderElement(paragraph);

		// make sure to add action only once, e.g. triggered multiple times on paragraph drag and drop
		if (header.querySelector('.action.toggle-fullscreen')) {
			return;
		}

		let action = document.createElement("div");
		action.classList.add("action");
		action.classList.add("toggle-fullscreen");
		action.setAttribute("tooltip", "true");
		let icon = document.createElement("i");
		icon.classList.add("material-icons");
		action.appendChild(icon);
		header.appendChild(action);

		var mc = new Hammer.Manager(action);
		mc.add(new Hammer.Tap({
			event: 'tap',
			taps: 1
		}));
		mc.add(new Hammer.Press({
			event: 'longpress',
			time: 250
		}));

		mc.on("tap", () => {
			FullscreenUtils.toggleTransientFullscreen(paragraph);
		});
		mc.on("longpress", (event) => {
			FullscreenUtils.togglePersistedFullscreen(paragraph);
		});
	};

	document.liveQuerySelectorAll('.paragraph').added(addFullscreenButton);
});

importLib([
	"mousetrap.min.js",
	"mousetrap-global-bind.min.js"
]).then(() => {

	// combinations
	Mousetrap.bindGlobal('ctrl+shift+f', function (event) {
		let target = event.target;
		let paragraph = target.closest('.paragraph');
		
		if (!paragraph) {
			paragraph = document.querySelector('.paragraph.fullscreen:not([transient-fullscreen="false"]),.paragraph[transient-fullscreen="true"]');
		}
		
		if (paragraph) {
			FullscreenUtils.togglePersistedFullscreen(paragraph);
		}
		return false;
	});
});</PRE></DIV><DIV class="paragraph code-paragraph collapsed" draggable="false" style run-on-load="true" name="Update Fullscreen Indicator" last-execution-state="success" data-id="mBmpfXnA" __wid="MnpicUW6"><PRE data-type="content" type="text/javascript" __wid="KSsvdqed">const FullscreenUtils = require('#fullscreen-utils');

let indicator = document.createElement("transient");
indicator.setAttribute("id", "fullscreen-indicator");
indicator.classList.add("hidden");
indicator.addEventListener("click", (event) => {
	let paragraph = document.querySelector('.paragraph.fullscreen');
	FullscreenUtils.setPersistedFullscreen(true, paragraph);
});
document.body.appendChild(indicator);

const updateFullscreenIndicator = () => {
	let persistedFullscreenParagraph = document.querySelector('.paragraph.fullscreen');
	let transientFullscreenParagraph = document.querySelector('.paragraph[transient-fullscreen]');
// 	console.log('update here', persistedFullscreenParagraph);
	
	if (persistedFullscreenParagraph) {
		indicator.setAttribute("name", persistedFullscreenParagraph.getAttribute("name") || "No Name");
	}

	if (persistedFullscreenParagraph && transientFullscreenParagraph) {
		indicator.classList.remove("hidden");
	}
	else {
		indicator.classList.add("hidden");
	}
};

// update state for fullscreen indicator	
let liveSelector = document.liveQuerySelectorAll(".paragraph.fullscreen");
liveSelector.added(updateFullscreenIndicator);

document.documentElement.liveAttribute("class").changed(updateFullscreenIndicator);
document.documentElement.liveAttribute("transient-fullscreen").changed(updateFullscreenIndicator);</PRE></DIV><DIV class="paragraph code-paragraph collapsed" draggable="false" style name="Fullscreen Helper" data-id="SShXZSND" __wid="yjhfKweE"><PRE data-type="content" type="text/javascript" id="fullscreen-utils" __wid="2gRGQzzE">const setFullscreen = (paragraph, enable, enableFullscreen, disableFullscreen) => {
	
	if (paragraph.classList.contains("collapsed")) {
		paragraph.classList.remove("collapsed");
	}

	let paragraphs = document.querySelectorAll('.paragraph.fullscreen,.paragraph[transient-fullscreen]');
	if (enable) {
		// remove fullscreen from all paragraphs -> just in case
		Array.prototype.forEach.call(paragraphs, (paragraph) => disableFullscreen(paragraph));
		enableFullscreen();
	} else {
		disableFullscreen();

		// remove fullscreen from all paragraphs -> just in case
		Array.prototype.forEach.call(paragraphs, (paragraph) => disableFullscreen(paragraph));

		// refresh CodeMirror instances, otherwise they will be collapsed
		const contents = document.querySelectorAll('.section:not(.section-hidden) .paragraph:not(.collapsed) [data-type="content"]');
		Array.prototype.forEach.call(contents, (content) => {
			if (content && content.__editor && content.__editor.editor) {
				content.__editor.editor.refresh();
			}
		});
	}
};

const setPersistedFullscreen = (enable, paragraph) => {

	// disable transient fullscreen when set paragraph to real fullscreen
	if (enable) {
		setTransientFullscreen(false, paragraph, true);
	}

	const enableFullscreen = () => {
		paragraph.classList.add("fullscreen");
		document.body.classList.add("fullscreen");
		document.documentElement.classList.add("fullscreen");
	};

	const disableFullscreen = (paragraph) => {

		if (paragraph) {
			paragraph.classList.remove("fullscreen");
		} else {

			// Replace body fullscreen with html fullscreen
			let documentElement = document.documentElement;
			if (documentElement.classList.contains("fullscreen")) {
				documentElement.classList.remove("fullscreen");
			}

			// @deprecated body fullscreen will be removed because it is replaced
			// by html fullscreen
			let body = document.body;
			if (body.classList.contains("fullscreen")) {
				body.classList.remove("fullscreen");
			}
		}
	};

	setFullscreen(paragraph, enable, enableFullscreen, disableFullscreen);
};

const setTransientFullscreen = (enable, paragraph, removeAttribute = false) => {

	const enableFullscreen = () => {
		paragraph.setAttribute("transient-fullscreen", "true");
		document.body.setAttribute("transient-fullscreen", "true");
		document.documentElement.setAttribute("transient-fullscreen", "true");
	};

	const disableFullscreen = (paragraph) => {

		if (paragraph) {
			paragraph.setAttribute("transient-fullscreen", "false");

			if (removeAttribute) {
				paragraph.removeAttribute("transient-fullscreen");
			}
		} else {

			if (removeAttribute) {
				document.documentElement.removeAttribute("transient-fullscreen");
			}
			else {
				document.documentElement.setAttribute("transient-fullscreen", "false");
			}

			if (removeAttribute) {
				document.body.removeAttribute("transient-fullscreen");
			}
			else {
				document.body.setAttribute("transient-fullscreen", "false");
			}
		}
	};

	setFullscreen(paragraph, enable, enableFullscreen, disableFullscreen);
};

const togglePersistedFullscreen = (paragraph) => {
	const isFullscreen = paragraph.classList.contains("fullscreen");
	setPersistedFullscreen(!isFullscreen, paragraph);
};

const toggleTransientFullscreen = (paragraph) => {

	const isFullscreen = (
		// paragraph is in fullscreen but transient-fullscreen is not set
		(
			document.body.classList.contains("fullscreen") &&
			!document.body.hasAttribute("transient-fullscreen")
		) ||
		document.body.matches('[transient-fullscreen="true"]')
	);

	setTransientFullscreen(!isFullscreen, paragraph);
};

exports.setPersistedFullscreen = setPersistedFullscreen;
exports.setTransientFullscreen = setTransientFullscreen;
exports.togglePersistedFullscreen = togglePersistedFullscreen;
exports.toggleTransientFullscreen = toggleTransientFullscreen;</PRE></DIV><DIV class="paragraph style-paragraph locked collapsed" name="Fullscreen Indicator" style data-id="8deBC5eW" __wid="JwXwtpEn"><STYLE data-type="content" type="text/css" codemirror="true" contenteditable="false" __wid="6gWL2Bcz">#fullscreen-indicator {
	position: fixed;
	right: 0;
	top: 100px;
	width: 30px;
	height: 400px;
	cursor: pointer;
	
	color:  rgba(255, 255, 255, .2);
	background: rgba(0, 0, 0, .2);
	border-radius: 2px;
	z-index: 201;
}

#fullscreen-indicator:hover {
	color: inherit;
	background: rgba(0, 0, 0, .3);
}

#fullscreen-indicator:before {
	padding-left: 7px;
	padding-bottom: 7px;
	content: attr(icon);
	position: relative;
	display: inline-block;
	transform: rotate(90deg) translate3d(0, -100%, 0);
	transform-origin: 0 0 0;
	
	font-family: 'Material Icons';
	font-weight: normal;
	font-style: normal;
/* 	font-size: 24px; */
	display: inline-block;
	line-height: 1;
	text-transform: none;
	letter-spacing: normal;
	word-wrap: normal;
	white-space: nowrap;
	direction: ltr;
	-webkit-font-smoothing: antialiased;
	text-rendering: optimizeLegibility;
	-moz-osx-font-smoothing: grayscale;
	font-feature-settings: 'liga';
}

#fullscreen-indicator:after {
	padding: 5px;
	padding-left: 10px;
	content: attr(name);
	display: inline-block;
	width: 200px;
	position: relative;
	transform: rotate(90deg) translate3d(0, -100%, 0);
	transform-origin: 0 0 0;
}

#fullscreen-indicator.hidden {
	display: none;
}</STYLE></DIV></DIV><DIV class="section section-hidden" name="Text Tools" data-type="system" data-id="jFx9fAE8" __wid="DLLkwtuK"><DIV class="paragraph body-paragraph locked collapsed" data-id="xTzmxJRa" name="Documentation" __wid="G8nQwcWf"><DIV data-type="content" type="text/html" codemirror="true" contenteditable="false" class="section-documentation" __wid="bFaF5Bjw"><H2 __wid="wKWtWbKT">Description</H2><DIV __wid="X3dprWAZ">TODO</DIV></DIV></DIV><DIV class="paragraph data-paragraph locked collapsed" data-id="n3EQSCGL" name="Properties" __wid="HK2hRr3z"><PRE data-type="content" type="application/json" class="section-properties" contenteditable="false" __wid="KPC6iGgp">{
	"version": "1.0",
	"dependecies": [],
	"description": "Lorem Ipsum",
	"changelog":
	{
		"1.0": "Initital Release"
	}
}</PRE></DIV><DIV class="paragraph code-paragraph collapsed" name="Text Tools Code" run-on-load="true" last-execution-state="success" style draggable="false" data-id="AKmmSZjW" __wid="jtNyqZv7"><PRE data-type="content" type="text/javascript" __wid="zd7fUyj9">const ActionUtils = require('#action-utils');

const addExecCommandAction = (tools, command, options, formatBlock = false) => {
	const commandAction = ActionUtils.create((event) => {
		event.preventDefault();
		document.execCommand(command, null, formatBlock);
	}, options);

	// Need to prevent mousedown and touchstart or otherwise the event does not work.
	commandAction.addEventListener("mousedown", (event) => event.preventDefault());
	commandAction.addEventListener("touchstart", (event) => event.preventDefault());

	tools.appendChild(commandAction);
};

const augmentText = (textElement) => {

	if (textElement.parentElement.querySelector('.text-tools')) return;

	const tools = document.createElement("transient");
	tools.setAttribute("class", "text-tools");

	addExecCommandAction(tools, "bold", { classNames: "text-bold", tooltip: true });
	addExecCommandAction(tools, "italic", { classNames: "text-italic", tooltip: true });
	addExecCommandAction(tools, "underline", { classNames: "text-underline", tooltip: true });
	addExecCommandAction(tools, "strikethrough", { classNames: "text-strikethrough", tooltip: true });

	addExecCommandAction(tools, "InsertUnorderedList", { classNames: "text-list-bulleted", tooltip: true });
	addExecCommandAction(tools, "InsertOrderedList", { classNames: "text-list-numbered", tooltip: true });
	addExecCommandAction(tools, "indent", { classNames: "text-list-indent", tooltip: true });
	addExecCommandAction(tools, "outdent", { classNames: "text-list-outdent", tooltip: true });

	const clearFormattingAction = ActionUtils.create((event) => {
		if (window.getSelection && window.getSelection().getRangeAt) {
			
			// get selected text
			const selection = window.getSelection();
			const range = selection.getRangeAt(0);
			const selectedText = range.toString();

			// delete current selection
			range.deleteContents();

			// create temporary container
			const div = document.createElement("div");
			div.innerHTML = selectedText;

			// append children of temporary container to document fragment
			const fragment = document.createDocumentFragment();
			let child;
			while ((child = div.firstChild)) {
				fragment.appendChild(child);
			}
			
			// insert document fragment with clear text at selection
			range.insertNode(fragment);
		}
		else if (document.selection && document.selection.createRange) {
			throw new Error(`clear formatting is not supported with this browser`);
		}
	}, { classNames: "clear-format", tooltip: true });
	tools.appendChild(clearFormattingAction);
	
	addExecCommandAction(tools, "formatBlock", { classNames: "text-h1", text: "H1", tooltip: true }, "&lt;h1>");

	addExecCommandAction(tools, "formatBlock", { classNames: "text-h2", text: "H2", tooltip: true }, "&lt;h2>");

	addExecCommandAction(tools, "formatBlock", { classNames: "text-h3", text: "H3", tooltip: true }, "&lt;h3>");

	const addVariableAction = ActionUtils.create(() => {
		
		const addVariable = (name) => {
			const variable = document.createElement("div");
			variable.setAttribute("class", "variable");
			variable.setAttribute("tabindex", "-1");
			variable.setAttribute("contenteditable", "false");
			variable.setAttribute("data-name", name);
			
// 			variable.addEventListener("keyup", event => {
// 				const newVariableName = variable.innerText.trim();
				
// 				// Ignore if variable name did not change, e.g., key events
// 				const oldVariableName = variable.getAttribute("data-name");
// 				if (newVariableName === oldVariableName) return;
				
// 				// Delete variable when variable name is empty
// 				if (!newVariableName || newVariableName === "") {
// 					variable.remove();
// 					return;
// 				}
				
// 				// Set new variable name
// 				variable.setAttribute("data-name", newVariableName);
// 			});

			textElement.appendChildAtCaret(variable);
		};

		const result = prompt('Set variable name', "", "Add Variable");
		
		if (result instanceof Promise) {
			result.then(r => {
				if (r) {
					addVariable(r);
				}
			});
		}
		else {
			if (result) {
				addVariable(result);
			}
		}
	}, { classNames: "text-set-variable", text: "Add Variable", tooltip: true });
	tools.appendChild(addVariableAction);

	const hideVariableNamesAction = ActionUtils.create(() => {
		textElement.classList.toggle("hide-variable-names");
	}, { classNames: "text-hide-variable-names", text: "Hide Variable Names", tooltip: true });
	tools.appendChild(hideVariableNamesAction);

	const convertToHtmlAction = ActionUtils.create(() => {
		if (window.getSelection) {
			const text = window.getSelection().toString();
			HTMLUtils.pasteHtmlAtCaret(text);
		}
	}, { classNames: "text-convert-to-html", text: "Convert Html", tooltip: true });
	tools.appendChild(convertToHtmlAction);

	textElement.parentElement.insertBefore(tools, textElement);
};

document.liveQuerySelectorAll('.paragraph.body-paragraph [data-type="content"][contenteditable]').added(augmentText);</PRE></DIV><DIV class="paragraph code-paragraph collapsed" name="List Indent / Outdent" run-on-load="true" draggable="false" last-execution-state="success" style data-id="aCh6hNdg" __wid="zpRAURxN"><PRE data-type="content" type="text/javascript" __wid="pdfJQmhR">// add tab and shift+tab support to indent and outdent lists
importLib([
	"mousetrap.min.js",
	"mousetrap-global-bind.min.js"
]).then(() => {

	Mousetrap.bindGlobal("tab", (event) => {
		// 		console.log("1", event, event.target, event.target.closest('ul,ol'));
		// 		if (event.target.closest('ul,ol')) {
		event.preventDefault();
		event.stopPropagation();
		event.stopImmediatePropagation();
		document.execCommand("indent", null, false);
		// 		}
	});

	Mousetrap.bindGlobal("shift+tab", (event) => {
		// 		console.log("2", event, event.target, event.target.closest('ul,ol'));
		// 		if (event.target.closest('ul,ol')) {
		event.preventDefault();
		event.stopPropagation();
		event.stopImmediatePropagation();
		document.execCommand("outdent", null, false);
		// 		}
	});
});</PRE></DIV><DIV class="paragraph code-paragraph collapsed" name="Paste Plain Text to Body Paragraphs" run-on-load="true" last-execution-state="success" style draggable="false" data-id="Tc6JR26S" __wid="aqDtnUmT"><PRE data-type="content" type="text/javascript" __wid="HSDtd4dq">let shiftKeyDown = false;

window.addEventListener("keydown", (event) => {
	if (event.keyCode === 16) {
		shiftKeyDown = true;
	}
}, true);

window.addEventListener("keyup", (event) => {
	if (event.keyCode === 16) {
		shiftKeyDown = false;
	}
}, true);

document.body.addEventListener("paste", (event) => {
	
	// ignore paste handler on shift key up
	if (!shiftKeyDown) return;
	
	const target = event.target;
	
	// apply paste plain HTML to body paragraphs only
	if (!target.closest('[data-type="content"][contenteditable="true"]')) return;
	
	// prevent default paste
	event.preventDefault();
	
	// get plain text
	const text = event.clipboardData.getData("text/plain");
	
	// inser plain text without any formatting
	document.execCommand("insertHTML", false, text);
});</PRE></DIV></DIV><DIV class="section section-hidden" name="Code Execution UI" data-type="system" data-group="editing" data-id="q3HngXx6" __wid="CXChqhHw"><DIV class="paragraph body-paragraph locked collapsed" draggable="false" name="Documentation" data-id="qx646KUk" __wid="PL5CPd45"><DIV data-type="content" type="text/html" codemirror="true" contenteditable="false" class="section-documentation" __wid="5rCTnYnt"><H2 __wid="5XTJiYzd">Description</H2><DIV __wid="sg9RJAzi">TODO</DIV></DIV></DIV><DIV class="paragraph data-paragraph locked collapsed" name="Properties" data-id="RBUbyafL" __wid="gzBDf3St"><PRE data-type="content" type="application/json" class="section-properties" contenteditable="false" __wid="fvkkyewH">{
	"version": "1.0",
	"description": "Lorem ipsum",
	"changelog":
	{
		"1.0": "Initital Release"
	}
}</PRE></DIV>

<DIV class="paragraph code-paragraph collapsed" draggable="false" name="Paragraph Code Execution Actions" run-on-load="true" style last-execution-state="success" data-id="4JG7preM" __wid="UHQ6f5Xh"><PRE data-type="content" type="text/javascript" __wid="wZZfYbQY">const ParagraphUtils = require('#paragraph-utils');

const runOnLoadAttributeName = "run-on-load";

const addExecuteAction = (paragraph) => {
	ParagraphUtils.addHeaderAction(paragraph, "execute-paragraph", () => {
		Codestrate.runCode(paragraph);
	}, {
		tooltip: true
	});
};

const addExecuteOnLoadAction = (paragraph) => {
	ParagraphUtils.addHeaderAction(paragraph, "run-on-load-paragraph", () => {

		if (paragraph.hasAttribute(runOnLoadAttributeName)) {
			paragraph.removeAttribute(runOnLoadAttributeName);
		}
		else {
			paragraph.setAttribute(runOnLoadAttributeName, "true");
		}
	}, {
		tooltip: true
	});
};

const addToggleConsoleAction = (paragraph) => {
	ParagraphUtils.addHeaderAction(paragraph, "toggle-console-paragraph", () => {
		if (paragraph.console) {
			const console = paragraph.console;
			console.toggle();
		}
	}, {
		tooltip: true
	});
};

document.liveQuerySelectorAll('.code-paragraph').added(paragraph => {
	// Only apply action to code paragraphs.
	if (!paragraph.querySelector('pre[data-type="content"]')) return;
	
	const header = ParagraphUtils.getHeaderElement(paragraph);
	const content = ParagraphUtils.getContentElement(paragraph);
	ParagraphUtils.addEditableElement(header, "type", content);

	addExecuteOnLoadAction(paragraph);
	addToggleConsoleAction(paragraph);
	addExecuteAction(paragraph);
});</PRE></DIV><DIV class="paragraph code-paragraph collapsed" name="Code Failure Handling" run-on-load="true" last-execution-state="success" style draggable="false" data-id="yd2ZzdY9" __wid="TeKkr8C6"><PRE data-type="content" type="text/javascript" __wid="bsxVqXTv">Codestrate.addEventListener("successruncode", event => {
//   window.console.log(event);
  
  const { paragraph } = event;
  
  paragraph.setAttribute("last-execution-state", "success");
});

Codestrate.addEventListener("errorruncode", event => {
//   window.console.log(event);
  
  const { paragraph } = event;
  
  paragraph.setAttribute("last-execution-state", "error");
});</PRE></DIV></DIV><DIV class="section section-hidden" name="Style Disable UI" data-type="system" data-group="editing" data-id="dtu5Kyzx" __wid="LSeFwgZB"><DIV class="paragraph body-paragraph locked collapsed" draggable="false" name="Documentation" data-id="LY4pn3kw" __wid="BCubZWgd"><DIV data-type="content" type="text/html" codemirror="true" contenteditable="false" class="section-documentation" __wid="JBS26uNg"><H2 __wid="xZFbY6Gz">Description</H2>Adds a button to style paragraphs for dis- and enabling.<H2 __wid="zj8Q8Byy">How it works</H2><DIV __wid="8yYJpsvx">Disabling works by adding a 'meta="none"' attribute to the &lt;style> tag of the style paragraph.</DIV></DIV></DIV><DIV class="paragraph data-paragraph locked collapsed" name="Properties" data-id="ur4aqAMa" __wid="kxnVuTmk"><PRE data-type="content" type="application/json" class="section-properties" contenteditable="false" __wid="Am6gppcw">{
	"version": "1.0",
	"dependencies": [],
	"description": "Adds a button to style paragraphs for dis- and enabling.",
	"changelog":
	{
		"1.0": "Initital Release"
	}
}</PRE></DIV>

<DIV class="paragraph code-paragraph collapsed" name="Paragraph Style Disable Action" run-on-load="true" last-execution-state="success" data-id="tkSd3vCM" __wid="MnjcGpCX"><PRE data-type="content" type="text/javascript" __wid="QYQWg4ij">const SectionUtils = require('#paragraph-utils');

const addDisableStyleAction = paragraph => {
  const disableStyleElement = SectionUtils.addHeaderAction(paragraph, "disable-style-content", () => {
    
    const content = paragraph.querySelector('[data-type="content"]');
		
		if (content) {
			if (paragraph.classList.contains("style-disabled")) {
				paragraph.classList.remove("style-disabled");
				content.removeAttribute("media");
			}
			else {
				paragraph.classList.add("style-disabled");
				content.setAttribute("media", "none");
			}
		}
  }, {
		tooltip: true
	});
	
	const content = paragraph.querySelector('[data-type="content"]');

  if (content) {
		if (paragraph.classList.contains("style-disabled")) {
			content.setAttribute("media", "none");
		}
		else {
			content.removeAttribute("media");
		}
  }
};

document.liveQuerySelectorAll('.style-paragraph').added(addDisableStyleAction);</PRE></DIV></DIV><DIV name="Pull Sections" data-type="system" class="section section-hidden" data-group="editing" data-id="Zxahzqd7" __wid="rcthg5MG"><DIV class="paragraph body-paragraph locked collapsed" data-id="mJsZk2Ya" name="Documentation" __wid="tTXFkGWz"><DIV data-type="content" type="text/html" codemirror="true" contenteditable="false" class="section-documentation" __wid="eNnCJzmb"><H2 __wid="y78KSqV7">Description</H2><DIV __wid="sk5rJGPx">TODO</DIV></DIV></DIV><DIV class="paragraph data-paragraph locked" data-id="49WxAn6U" name="Properties" __wid="yNts36tY"><PRE data-type="content" type="application/json" class="section-properties" contenteditable="false" __wid="s3ee2ZdJ">{
	"version": "1.0",
	"description": "Lorem ipsum",
	"changelog":
	{
		"1.0": "Initital Release"
	}
}</PRE></DIV><DIV class="paragraph code-paragraph collapsed" draggable="false" style run-on-load="true" name="Codestrate Copied From" last-execution-state="success" data-id="J6dMfwfR" __wid="ueSk3YrC"><PRE data-type="content" type="text/javascript" __wid="t3tJeeUT">let fetched = false;
let parentId;

Object.defineProperty(Codestrate, "parent", {
	get: () => {
		if (!fetched) {
			return new Promise((resolve, reject) => {
				(async() => {
					let opsData = await fetch(`/${webstrate.webstrateId}/?ops`, { credentials: 'same-origin' });
					let ops = await opsData.json();

					// fetched flag is needed because webstrates create without the copy command do not have
					// the create id value causing the parent id always to be undefined
					fetched = true;
					parentId = ops[0].create.id;

					resolve(parentId);
				})();
			});
		}
		return parentId;
	}
});</PRE></DIV><DIV class="paragraph code-paragraph collapsed" last-execution-state="success" name="Adding Pull System Sections Action to Articles" style data-id="ygXKq2DZ" __wid="88uLCJmb"><PRE data-type="content" type="text/javascript" __wid="MBSKuesa">const ActionUtils = require('#action-utils');

const addUpdateAction = (section) => {
	
	if (webstrate.webstrateId === "Codestrate") {
		console.warn("The prototype of the Inventor's Notebook cannot be updated. Omitting the update feature.");
		return;
	}
	
	const header = section.querySelector('.section-header');
	
	if (!header) return;
	
	const updateAction = ActionUtils.create((event) => {
		console.log('update', webstrate);
	}, { classNames: 'update', text: 'Update' });
	
	header.appendChild(updateAction);
};

document.liveQuerySelectorAll('.section').added(addUpdateAction);</PRE></DIV><DIV class="paragraph code-paragraph collapsed" name="Adding Pull System Sections Action to Global Menu" last-execution-state="success" run-on-load="true" style data-id="Z8NrhdJ6" __wid="seNBrjHu"><PRE data-type="content" type="text/javascript" __wid="e7dZmZXh">const GlobalMenuUtils = require('#global-menu-utils');

const updateAction = document.createElement('button');
updateAction.innerHTML = "Pull System Sections";
updateAction.addEventListener("click", event => {
	const Puller = require('#pull-system-sections');

	const result = Codestrate.showPullSystemSectionsDialog();
	if (result instanceof Promise) {
		result.then(data => {
			if (data) {
				Puller.pull(data.pullFrom, data.pullClass, data.pullVersion);				
			}
		});
	}
	else if (result) {
		Puller.pull("Codestrate", "", tagOrVersion);
	}
});

GlobalMenuUtils.addMenuItem(updateAction);</PRE></DIV><DIV class="paragraph code-paragraph collapsed" name="Pull System Sections Code" style data-id="VLxnLBve" __wid="4NKxXusq"><PRE data-type="content" type="text/javascript" id="pull-system-sections" __wid="r6nrVYjg">const loadPrototype = (url) => {

	return new Promise((resolve, reject) => {

		const transient = document.createElement("transient");

		// Transclude prototype webstrate only once.
		let iframe = document.querySelector(`iframe[src="${url}"]`);
		if (iframe) {
			if (iframe.webstrate.transcluded) {
				resolve(iframe);
				return;
			}
		}
		else {
			iframe = document.createElement("iframe");
			iframe.setAttribute("src", url);
			iframe.style.display = "none";
			transient.appendChild(iframe);
			document.body.appendChild(transient);
		}

		iframe.webstrate.on("transcluded", (webstrateId) => {

			// Continue if it is not this webstrate that transcluded
			if (iframe.contentWindow.webstrate.webstrateId !== webstrateId) return;

			resolve(iframe);
			return;
		});
	});
};

exports.pull = (pullFrom, pullClass, pullVersion) => {
	
	alert("The codestrate will reload after pull sections completed", "Pulling Sections");
	
	// The head of the prototype is the webstrate without versionOrTag path
	let versionOrTag = pullVersion;
	if (versionOrTag === "HEAD") {
		versionOrTag = null;
	}
	
	let systemSectionQuerySelector = '.section[data-type="system"]';
	let pullQuerySelector = systemSectionQuerySelector;
	if (pullClass !== "") {
		pullQuerySelector += `.${pullClass}`;
	}

	// Assemble prototype url.
	const url = versionOrTag ? `/${pullFrom}/${versionOrTag}/` : `/${pullFrom}/`;

	loadPrototype(`${url}?exec=no`).then((iframe) => {
		
		const frameWindow = iframe.contentWindow;
		const frameDocument = frameWindow.document;
		
		webstrate.tag(`Tag of version ${webstrate.version} before update to ${url} version ${pullVersion}`);

		let oldSections = Array.from(document.querySelectorAll(pullQuerySelector));
		let newSections = Array.from(frameDocument.querySelectorAll(pullQuerySelector));
		
		let lastSectionInserted;
		
		// Replace old sections with new sections
		oldSections.forEach(oldSection => {
			
			// Replace new section with an old section as long as there are new sections
			// left. Otherwise, remove remaining old sections.
			if (newSections.length > 0) {
				// Create a clone of section!!!
				let section = newSections.splice(0, 1)[0];
				let newSection = section.cloneNode(true);
				oldSection.replaceWith(newSection);
				lastSectionInserted = newSection;
			}
			else {
				oldSection.remove();
			}
		});

		// Append all remaining new sections
		newSections.forEach(section => {
			
			// Create a clone of section!!!
			let newSection = section.cloneNode(true);
			
			// If no section was inserted then find the last system section in the document
			// to append the remaining new sections
			if (!lastSectionInserted) {
				let systemSections = document.querySelectorAll(systemSectionQuerySelector);
				if (systemSections.length > 0) {
					lastSectionInserted = systemSections[systemSections.length - 1];
				}
				else {
					lastSectionInserted = document.body.firstElementChild;
				}
			}
			
			let parentElement = lastSectionInserted.parentElement;
			parentElement.insertBefore(newSection, lastSectionInserted.nextSibling);
			lastSectionInserted = newSection;
		});
		
		// Force all connected clients to reload the codestrate after all DOM mutations happened and sharedb
		// synchronized changes to the server.
		setTimeout(() => {
			webstrate.signal({ cmd: "PullSections", completed: true });
		}, 0);
	});
};</PRE></DIV><DIV class="paragraph code-paragraph collapsed" run-on-load="true" last-execution-state="success" name="Pull System Sections Dialog" style data-id="wuJ7hFq4" __wid="zWVcGM9k"><PRE data-type="content" type="text/javascript" __wid="fDkDkD4Q">// use Codestrate prototype in general, but also try to get the webstrate id of the codestrate from
// which this codestrate was copied from
let parentId = "Codestrate";
(async() => {
	parentId = await Codestrate.parent || parentId;
})();

Codestrate.showPullSystemSectionsDialog = () => {

	return new Promise((resolve, reject) => {

		const transient = document.createElement("transient");

		const elements = require('#dialog-template', {
			title: "Codestrate Tags",
			message: `&lt;div>From what codestrate do you want to pull from?&lt;/div>
&lt;input class="pull-from" value="${parentId}">
&lt;div>What sections (class) do you want to pull? (Leave empty for all system sections)&lt;/div>
&lt;input class="pull-class" value="">
&lt;div>From what version do you want to pull from?&lt;/div>
&lt;input class="pull-version" value="HEAD">`,
			actions: `&lt;div class="button pull">Pull&lt;/div>
&lt;div class="button cancel">Cancel&lt;/div>`
		});

		elements.forEach(e => transient.appendChild(e));

		const pullBtn = transient.querySelector('.pull');
		const cancelBtn = transient.querySelector('.cancel');
		const pullFromInput = transient.querySelector('.pull-from');
		const pullClassInput = transient.querySelector('.pull-class');
		const pullVersionInput = transient.querySelector('.pull-version');
		
		const pull = () => {
			const pullFrom = pullFromInput.value;
			const pullClass = pullClassInput.value;
			const pullVersion = pullVersionInput.value;
			
			transient.remove();
			
			resolve({
				pullFrom,
				pullClass,
				pullVersion
			});
		}

		const cancel = () => {
			transient.remove();
			resolve(false);
		}

		pullBtn.addEventListener("click", pull);
		cancelBtn.addEventListener("click", cancel);
		
		const inputEventHandler = (e) => {
			e.stopPropagation();

			if (e.keyCode === 13) {
				e.preventDefault();
				pull();
			}
			else if (e.keyCode === 27) {
				e.preventDefault();
				cancel();
			}
		};

		pullFromInput.addEventListener("keydown", inputEventHandler);
		pullClassInput.addEventListener("keydown", inputEventHandler);
		pullVersionInput.addEventListener("keydown", inputEventHandler);

		document.body.appendChild(transient);

		pullFromInput.focus();
	});
};</PRE></DIV><DIV class="paragraph code-paragraph collapsed" name="Reload connected clients on pull section" run-on-load="true" last-execution-state="success" style data-id="W9iDbJbL" __wid="9vAzcGCM"><PRE data-type="content" type="text/javascript" __wid="iFMhYd6H">webstrate.on("signal", (message, senderId) => {
  if (message.cmd === "PullSections" && message.completed) {
		
		// inform users about reload after section pulled
		if (webstrate.clientId !== senderId) {
			alert("The codestrate will reload because it has been updated remotely", "Pulling Sections");
		}

    // add some delay to make sure all mutations have been synced with the server. Without
    // this timeout, pulling sections sometimes does not work
    setTimeout(() => {
      window.location.reload();
    }, 5000);
  }
});</PRE></DIV></DIV><DIV class="section section-hidden" name="Transformer" data-type="system" data-group="basic" data-id="rEpvSgsq" __wid="CtjxRwsz"><DIV class="paragraph body-paragraph locked collapsed" draggable="false" name="Documentation" data-id="fi4DiaeV" __wid="ki2XApB9"><DIV data-type="content" type="text/html" codemirror="true" contenteditable="false" class="section-documentation" __wid="dhH9dHqp"><H2 __wid="csag3Qrz">Description</H2>TODO</DIV></DIV><DIV class="paragraph data-paragraph locked collapsed" name="Properties" data-id="KDxhWYmz" __wid="RsWGBmg9"><PRE data-type="content" type="application/json" class="section-properties" contenteditable="false" __wid="AxxDZcmH">{
	"version": "1.0",
	"dependencies": [],
	"description": "Lorem ipsum",
	"changelog":
	{
		"1.0": "Initital Release"
	}
}</PRE></DIV>

<DIV class="paragraph code-paragraph collapsed" draggable="false" name="Number.prototype.toFixedNumber" last-execution-state="success" data-id="8PxQr3XN" __wid="YGJZTAgj"><PRE data-type="content" type="text/javascript" class="transformer" __wid="3Fv5XMPr">if (!Number.prototype.toFixedNumber) {
  Number.prototype.toFixedNumber = function (x, base) {
    var pow = Math.pow(base || 10, x);
    return +(Math.round(this * pow) / pow);
  };
}</PRE></DIV><DIV class="paragraph code-paragraph collapsed" name="Point" data-id="Kesc5XiM" __wid="hJHUeauh"><PRE data-type="content" type="text/javascript" class="transformer" __wid="wfd9UvuE">/**
 * A simple point class.
 * 
 * @class Point
 */
class Point {

  /**
   * Creates an instance of Point.
   * 
   * @param {any} x The x value.
   * @param {any} y The y value.
   * 
   * @memberOf Point
   */
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }

  /**
   * Returns the string representation of the point.
   * 
   * @returns The string representation of the point.
   * 
   * @memberOf Point
   */
  toString() {
    return `${Point.name} [x=${this.x},y=${this.y}]`;
  }
}</PRE></DIV><DIV class="paragraph code-paragraph collapsed" name="Matrix" data-id="Kny7FsRx" __wid="ptkmcK2j"><PRE data-type="content" type="text/javascript" class="transformer" __wid="vFTc6Zsj">/**
 * The matrix class provides convenient functions for affine transformations, e.g., translate, rotate,
 * and scale. It also offers functions like matrix multiplication or creating an inverse matrix.
 * 
 * @class Matrix
 */
class Matrix {

  /**
   * Creates an instance of Matrix. The matrix needs to be a two-dimensional array. The first index will
   * be rows and the second index will be columns. The array needs to be in a n x m format. For example,
   * an array [[1, 2, 3], [4, 5, 6], [7, 8 ,9]] will result in the following matrix:
   * 
   * 1   2   3
   * 4   5   6
   * 7   8   9
   * 
   * @param {any} M A two-dimensional array.
   * 
   * @memberOf Matrix
   */
  constructor(M) {

    if (typeof M === 'undefined' || !Array.isArray(M)) {
      throw new Error(`first parameter needs to be a two-dimensional array`);
    }
    this.matrix = M;
  }

  /**
   * Sets the matrix. The matrix needs to be a two-dimensional array. The first index will be rows and
   * the second index will be columns. The array needs to be in a n x m format.
   * 
   * @memberOf Matrix
   */
  set matrix(matrix) {
    this._matrix = matrix;
    this._rows = matrix.length;
    this._columns = matrix[0].length;
  }

  /**
   * Returns the matrix as a two-dimensional array.
   * 
   * @memberOf Matrix
   */
  get matrix() {
    return this._matrix;
  }

  /**
   * Returns number of rows of matrix.
   * 
   * @readonly
   * 
   * @memberOf Matrix
   */
  get rows() {
    return this._rows;
  }

  /**
   * Returns number of columns of matrix.
   * 
   * @readonly
   * 
   * @memberOf Matrix
   */
  get columns() {
    return this._columns;
  }

  get a() {
    return this.matrix[0][0];
  }

  get b() {
    return this.matrix[1][0];
  }

  get c() {
    return this.matrix[0][1];
  }

  get d() {
    return this.matrix[1][1];
  }

  get tx() {
    return this.matrix[0][2];
  }

  get ty() {
    return this.matrix[1][2];
  }

  get angle() {
    const rad = Math.atan2(this.b, this.a);
    return (rad * 180) / Math.PI;
  }

  get scaleX() {
    return this.a;
  }

  get scaleY() {
    return this.d;
  }

  /**
   * Translates the matrix by tx and ty.
   * 
   * @param {Number} tx The translation value in x.
   * @param {Number} ty The translation value in y.
   * 
   * @memberOf Matrix
   */
  translate(tx, ty, truncate = true) {
    const M = this.multiply(new Matrix([
      [1, 0, tx],
      [0, 1, ty],
      [0, 0, 1],
    ]), truncate).matrix;

    this.matrix = M;
  }

  /**
   * Rotates the matrix by angle. The rotation value has to be in degrees.
   * 
   * @param {Number} angle The rotation value in degrees.
   * 
   * @memberOf Matrix
   */
  rotate(angle, truncate = true) {
    const rad = angle * (Math.PI / 180);
    const costheta = Math.cos(rad);
    const sintheta = Math.sin(rad);

    const M = this.multiply(new Matrix([
      [costheta, -sintheta, 0],
      [sintheta, costheta, 0],
      [0, 0, 1],
    ]), truncate).matrix;

    this.matrix = M;
  }

  /**
   * Scales the matrix by sx and sy.
   * 
   * @param {Number} sx The scale value in x.
   * @param {Number} sy The scale value in y.
   * 
   * @memberOf Matrix
   */
  scale(sx, sy, truncate = true) {
    const M = this.multiply(new Matrix([
      [sx, 0, 0],
      [0, sy, 0],
      [0, 0, 1],
    ]), truncate).matrix;

    this.matrix = M;
  }

  /**
   * Skwes the matrix in degX and degY.
   * 
   * @param {Number} degX The skew value in x in degrees.
   * @param {Number} degY The skew value in y in degrees.
   * 
   * @memberOf Matrix
   */
  skew(degX, degY, truncate = true) {
    const radX = degX * (Math.PI / 180);
    const radY = degY * (Math.PI / 180);
    const x = Math.tan(radX);
    const y = Math.tan(radY);

    const M = this.multiply(new Matrix([
      [1, x, 0],
      [y, 1, 0],
      [0, 0, 1],
    ]), truncate).matrix;

    this.matrix = M;
  }

  /**
   * Multiplies a given matrix with this matrix and returns the result as new matrix instance. In order
   * to perform the matrix multiplication, rows of matrix M1 need to match columns of matrix M2 as well
   * as columns of matrix M1 need to match rows of matrix M2.
   * 
   * @param {any} M The matrix used to multiply with this matrix.
   * @returns The multipied matrix.
   * 
   * @memberOf Matrix
   */
  multiply(M, truncate = true) {

    if (this.rows !== M.columns || this.columns !== M.rows) {
      throw new Error(`cannot multiply because matrix dimensions do not match (n*m !== m*n)`);
    }

    const m = [];
    const m1 = this.matrix;
    const m2 = M.matrix;
    for (let i = 0; i &lt; m1.length; i++) {
      m[i] = [];
      for (let j = 0; j &lt; m2[0].length; j++) {
        let sum = 0;
        for (let k = 0; k &lt; m1[0].length; k++) {
          sum += m1[i][k] * m2[k][j];
        }
        // m[i][j] = sum;
        m[i][j] = truncate ? parseFloat(sum.toFixed(3)) : sum;
      }
    }

    return new Matrix(m);
  }

  /**
   * Multiplies this matrix by the given matrix and replaces this matrix by the resulting matrix.
   * 
   * @param {any} The matrix used to multiply with this matrix.
   * 
   * @memberOf Matrix
   */
  multiplyBy(M) {
    // const m = this.multiply(M).matrix;
    const m = M.multiply(this).matrix;
    this.matrix = m;
  }

  /**
   * Creates a copy of the matrix.
   * 
   * @returns The copy of this matrix.
   * 
   * @memberOf Matrix
   */
  copy() {
    const m = this.matrix;
    const copyM = JSON.parse(JSON.stringify(m));
    return new Matrix(copyM);
  }

  /**
   * Returns the inverse matrix of this matrix.
   * 
   * http://blog.acipo.com/matrix-inversion-in-javascript/
   * 
   * @readonly
   * 
   * @memberOf Matrix
   */
  get inverse() {
    // I use Guassian Elimination to calculate the inverse:
    // (1) 'augment' the matrix (left) by the identity (on the right)
    // (2) Turn the matrix on the left into the identity by elemetry row ops
    // (3) The matrix on the right is the inverse (was the identity matrix)
    // There are 3 elemtary row ops: (I combine b and c in my code)
    // (a) Swap 2 rows
    // (b) Multiply a row by a scalar
    // (c) Add 2 rows

    const M = this.matrix;

    //if the matrix isn't square: exit (error)
    if (M.length !== M[0].length) {
      throw new Error(`matrix is not squared`);
    }

    //create the identity matrix (I), and a copy (C) of the original
    var i = 0,
      ii = 0,
      j = 0,
      dim = M.length,
      e = 0,
      t = 0;
    var I = [],
      C = [];
    for (i = 0; i &lt; dim; i += 1) {
      // Create the row
      I[I.length] = [];
      C[C.length] = [];
      for (j = 0; j &lt; dim; j += 1) {

        //if we're on the diagonal, put a 1 (for identity)
        if (i == j) {
          I[i][j] = 1;
        } else {
          I[i][j] = 0;
        }

        // Also, make the copy of the original
        C[i][j] = M[i][j];
      }
    }

    // Perform elementary row operations
    for (i = 0; i &lt; dim; i += 1) {
      // get the element e on the diagonal
      e = C[i][i];

      // if we have a 0 on the diagonal (we'll need to swap with a lower row)
      if (e == 0) {
        //look through every row below the i'th row
        for (ii = i + 1; ii &lt; dim; ii += 1) {
          //if the ii'th row has a non-0 in the i'th col
          if (C[ii][i] != 0) {
            //it would make the diagonal have a non-0 so swap it
            for (j = 0; j &lt; dim; j++) {
              e = C[i][j]; //temp store i'th row
              C[i][j] = C[ii][j]; //replace i'th row by ii'th
              C[ii][j] = e; //repace ii'th by temp
              e = I[i][j]; //temp store i'th row
              I[i][j] = I[ii][j]; //replace i'th row by ii'th
              I[ii][j] = e; //repace ii'th by temp
            }
            //don't bother checking other rows since we've swapped
            break;
          }
        }
        //get the new diagonal
        e = C[i][i];
        //if it's still 0, not invertable (error)
        if (e == 0) {
          throw new Error(`matrix is not invertable`);
        }
      }

      // Scale this row down by e (so we have a 1 on the diagonal)
      for (j = 0; j &lt; dim; j++) {
        C[i][j] = C[i][j] / e; //apply to original matrix
        I[i][j] = I[i][j] / e; //apply to identity
      }

      // Subtract this row (scaled appropriately for each row) from ALL of
      // the other rows so that there will be 0's in this column in the
      // rows above and below this one
      for (ii = 0; ii &lt; dim; ii++) {
        // Only apply to other rows (we want a 1 on the diagonal)
        if (ii == i) {
          continue;
        }

        // We want to change this element to 0
        e = C[ii][i];

        // Subtract (the row above(or below) scaled by e) from (the
        // current row) but start at the i'th column and assume all the
        // stuff left of diagonal is 0 (which it should be if we made this
        // algorithm correctly)
        for (j = 0; j &lt; dim; j++) {
          C[ii][j] -= e * C[i][j]; //apply to original matrix
          I[ii][j] -= e * I[i][j]; //apply to identity
        }
      }
    }

    //we've done all operations, C should be the identity
    //matrix I should be the inverse:
    return new Matrix(I);
  }

  toJSON() {
    return JSON.stringify(this.matrix);
  }

  static fromJSON(json) {
    const matrix = JSON.parse(json);
    return new Matrix(matrix);
  }

  /**
   * Converts the matrix to a CSS matrix transform. It respects whether the matrix should be a
   * CSS matrix() or CSS matrix3d().
   * 
   * @returns The CSS transform.
   * 
   * @memberOf Matrix
   */
  toCss(fixed = true) {

    const M = this.matrix;

    const getFixedValue = (row, column) => {
      if (fixed) {
        return parseFloat(M[row][column].toFixed(3));
      }
      return M[row][column];
    };

    if (this.rows === 3 && this.columns === 3) {
      if (this.equals(Matrix.identity(3))) {
        return "none";
      }

      const a = getFixedValue(0, 0);
      const b = getFixedValue(1, 0);
      const c = getFixedValue(0, 1);
      const d = getFixedValue(1, 1);
      const tx = getFixedValue(0, 2);
      const ty = getFixedValue(1, 2);

      return `matrix(${a}, ${b}, ${c}, ${d}, ${tx}, ${ty})`;
    }

    if (this.equals(Matrix.identity(4))) {
      return "none";
    }

    const a1 = getFixedValue(0, 0);
    const b1 = getFixedValue(1, 0);
    const c1 = getFixedValue(2, 0);
    const d1 = getFixedValue(3, 0);
    const a2 = getFixedValue(0, 1);
    const b2 = getFixedValue(1, 1);
    const c2 = getFixedValue(2, 1);
    const d2 = getFixedValue(3, 1);
    const a3 = getFixedValue(0, 2);
    const b3 = getFixedValue(1, 2);
    const c3 = getFixedValue(2, 2);
    const d3 = getFixedValue(3, 2);
    const a4 = getFixedValue(0, 3);
    const b4 = getFixedValue(1, 3);
    const c4 = getFixedValue(2, 3);
    const d4 = getFixedValue(3, 3);

    return `matrix3d(${a1}, ${b1}, ${c1}, ${d1}, ${a2}, ${b2}, ${c2}, ${d2}, ${a3}, ${b3}, ${c3}, ${d3}, ${a4}, ${b4}, ${c4}, ${d4})`;
  }

  /**
   * Returns true if matrix M equals to this matrix.
   * 
   * @param {any} M A matrix to compare to.
   * @returns True if this matrix and matrix M are equal.
   * 
   * @memberOf Matrix
   */
  equals(M) {
    return Matrix.equals(this, M);
  }

  /**
   * Returns true if both matrix have the same matrix values, false otherwise.
   * 
   * @static
   * @param {any} M1 Matrix 1.
   * @param {any} M2 Matrix 2.
   * @returns True if matrix M1 and M2 are equal.
   * 
   * @memberOf Matrix
   */
  static equals(M1, M2) {
    return JSON.stringify(M1.matrix) === JSON.stringify(M2.matrix);
  }

  /**
   * Creates an n x n identity matrix.
   * 
   * @static
   * @param {any} n The number of rows and columns to create this n x n identity matrix.
   * @returns The identity matrix.
   * 
   * @memberOf Matrix
   */
  static identity(n) {

    let m = [];
    for (let row = 0; row &lt; n; row++) {
      let mRow = m[row] = [];

      for (let col = 0; col &lt; n; col++) {
        mRow[col] = col === row ? 1 : 0;
      }
    }

    return new Matrix(m);
  }

  /**
   * Creates a matrix from a DOM element (e.g., a HTMLElement or a SVGElement).
   * 
   * @static
   * @param {any} element A DOM element from which the matrix is created from.
   * @returns The matrix.
   * 
   * @memberOf Matrix
   */
  static from(element) {

    let rawTransform = "none";

    if (element instanceof SVGElement) {
      rawTransform = element.getAttribute("transform");

      // SAFARI does not return a proper transform with window.getComputedStyle for SVGElement.
      // TODO This is a nasty workaround.
      if (!rawTransform || rawTransform === "") {
        rawTransform = element.style.transform;
      }
    } else if (element.nodeType === 1) {
      rawTransform = window.getComputedStyle(element).transform;
    }

    if (rawTransform === "" || rawTransform === "none") {
      return Matrix.identity(3);
    } else {
      const regEx = /([-+]?[\d\.]+)/g;

      // console.log('rawTransform %o', rawTransform);

      if (rawTransform.indexOf("matrix3d") > -1) {
        // throw new Error(`matrix3d transformation not yet supported`);

        // https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/matrix3d
        const a1 = parseFloat(regEx.exec(rawTransform)[0]);
        const b1 = parseFloat(regEx.exec(rawTransform)[0]);
        const c1 = parseFloat(regEx.exec(rawTransform)[0]);
        const d1 = parseFloat(regEx.exec(rawTransform)[0]);
        const a2 = parseFloat(regEx.exec(rawTransform)[0]);
        const b2 = parseFloat(regEx.exec(rawTransform)[0]);
        const c2 = parseFloat(regEx.exec(rawTransform)[0]);
        const d2 = parseFloat(regEx.exec(rawTransform)[0]);
        const a3 = parseFloat(regEx.exec(rawTransform)[0]);
        const b3 = parseFloat(regEx.exec(rawTransform)[0]);
        const c3 = parseFloat(regEx.exec(rawTransform)[0]);
        const d3 = parseFloat(regEx.exec(rawTransform)[0]);
        const a4 = parseFloat(regEx.exec(rawTransform)[0]);
        const b4 = parseFloat(regEx.exec(rawTransform)[0]);
        const c4 = parseFloat(regEx.exec(rawTransform)[0]);
        const d4 = parseFloat(regEx.exec(rawTransform)[0]);

        return new Matrix([
          [a1, a2, a3, a4],
          [b1, b2, b3, b4],
          [c1, c2, c3, c4],
          [d1, d2, d3, d4]
        ]);
      } else {

        // https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/matrix
        const a = parseFloat(regEx.exec(rawTransform)[0]);
        const b = parseFloat(regEx.exec(rawTransform)[0]);
        const c = parseFloat(regEx.exec(rawTransform)[0]);
        const d = parseFloat(regEx.exec(rawTransform)[0]);
        const tx = parseFloat(regEx.exec(rawTransform)[0]);
        const ty = parseFloat(regEx.exec(rawTransform)[0]);

        return new Matrix([
          [a, c, tx],
          [b, d, ty],
          [0, 0, 1]
        ]);
      }
    }
  }

  /**
   * Returns the matrix in a human readable format. 
   * 
   * @returns The matrix in string format.
   * 
   * @memberOf Matrix
   */
  toString() {
    return `Matrix [rows=${this.rows},columns=${this.columns},matrix=${JSON.stringify(this.matrix)}]`;
  }
}</PRE></DIV><DIV class="paragraph code-paragraph collapsed" name="Transform" data-id="quFaQdBQ" __wid="HHRZyLhX"><PRE data-type="content" type="text/javascript" class="transformer" __wid="3Z8begfR">/**
 * The base class for a transforms.
 * 
 * @class Transform
 */
class Transform {

  /**
   * Creates an instance of Transform. It will create an instance with a default identity matrix.
   * 
   * @memberOf Transform
   */
  constructor() {
    this.matrix = Matrix.identity(3);
    this._centerPoint = new Point(0, 0);
  }

  get centerPoint() {
    return this._centerPoint;
  }

  /**
   * Applies this transform to the matrix given as parameter.
   * 
   * @param {any} matrix The matrix to which this transform will be applied.
   * 
   * @memberOf Transform
   */
  apply(matrix) {
    const centerPointMatrix = Matrix.identity(3);
    centerPointMatrix.translate(this._centerPoint.x, this._centerPoint.y);

    matrix.multiplyBy(centerPointMatrix.inverse);
    matrix.multiplyBy(this.matrix);
    matrix.multiplyBy(centerPointMatrix);
  }

  /**
   * Unapplies this transformation from the matrix given as paramter.
   * 
   * @param {any} matrix The matrix from which this transform will be unapplied.
   * 
   * @memberOf Transform
   */
  unapply(matrix) {
    const centerPointMatrix = Matrix.identity(3);
    centerPointMatrix.translate(this._centerPoint.x, this._centerPoint.y);

    matrix.multiplyBy(centerPointMatrix.inverse);
    // console.log('matrix1 %o', this.matrix.toString());
    matrix.multiplyBy(this.matrix.inverse);
    // console.log('matrix2 %o', this.matrix.toString());
    matrix.multiplyBy(centerPointMatrix);
  }

  get inverse() {
    throw new Error(`inverse not implemented for ${this.constructor.name}`);
  }

  reset() {
    this._centerPoint.x = 0;
    this._centerPoint.y = 0;
  }

  static from(matrix) {
    throw new Error(`inverse not implemented for transform`);
  }
}</PRE></DIV><DIV class="paragraph code-paragraph collapsed" name="TranslateTransform" data-id="vvdD8jr8" __wid="nvrx87Wy"><PRE data-type="content" type="text/javascript" class="transformer" __wid="xbs5Jh6h">/**
 * The translate transform.
 * 
 * @class TranslateTransform
 * @extends {Transform}
 */
class TranslateTransform extends Transform {

  /**
   * Creates an instance of TranslateTransform. It will translate a matrix by tx and ty.
   * 
   * @param {any} tx The translate value in x.
   * @param {any} ty The translate value in y.
   * 
   * @memberOf TranslateTransform
   */
  constructor(x = 0, y = 0) {
    super();
    this.set(x, y);
  }

  set(x, y) {
    this.x = x;
    this.y = y;

    this.matrix = new Matrix([
      [1, 0, x],
      [0, 1, y],
      [0, 0, 1]
    ]);
  }

  get inverse() {
    return TranslateTransform.from(this.matrix.inverse);
  }

  update(matrix) {

    if (!(matrix instanceof Matrix)) {
      throw new Error(`matrix needs to be of type ${Matrix.name}`);
    }

    const M = matrix;

    // http://math.stackexchange.com/questions/13150/extracting-rotation-scale-values-from-2d-transformation-matrix
    const tx = M.tx;
    const ty = M.ty;

    this.set(tx, ty);
  }

  /**
   * Reset translate transform.
   * 
   * @memberOf TranslateTransform
   */
  reset() {
    this.set(0, 0);
    super.reset();
  }

  static from(matrix) {
    const transform = new TranslateTransform();
    transform.update(matrix);
    return transform;
  }

  toString() {
    return `${this.constructor.name} [x=${this.x},y=${this.y}]`;
  }
}</PRE></DIV><DIV class="paragraph code-paragraph collapsed" name="RotateTransform" data-id="McadRmZp" __wid="GRFttVA5"><PRE data-type="content" type="text/javascript" class="transformer" __wid="LW6Z4N8F">/**
 * The rotate transform.
 * 
 * @class RotateTransform
 * @extends {Transform}
 */
class RotateTransform extends Transform {

  /**
   * Creates an instance of RotateTransform. It will rotate a matrix by an angle [in degrees].
   * 
   * @param {any} deg The rotate value in degrees.
   * 
   * @memberOf RotateTransform
   */
  constructor(angle = 0) {
    super();
    this.set(angle);
  }

  set(angle) {
    this.angle = angle;

    const rad = angle * (Math.PI / 180);
    const costheta = Math.cos(rad);
    const sintheta = Math.sin(rad);

    this.matrix = new Matrix([
      [costheta, -sintheta, 0],
      [sintheta, costheta, 0],
      [0, 0, 1]
    ]);
  }

  get inverse() {
    return RotateTransform.from(this.matrix.inverse);
  }

  update(matrix) {

    if (!(matrix instanceof Matrix)) {
      throw new Error(`matrix needs to be of type ${Matrix.name}`);
    }

    const M = matrix;

    // http://math.stackexchange.com/questions/13150/extracting-rotation-scale-values-from-2d-transformation-matrix
    // const psi1 = Math.atan2(-M.b, M.a);
    // const psi2 = Math.atan2(M.c, M.d);

    // if (psi1 !== psi2) {
    //     throw new Error(`matrix error ${psi1} !== ${psi2}`);
    // }

    // const angle = (psi2 * 180) / Math.PI;

    const rad = Math.atan2(M.b, M.a);
    const angle = (rad * 180) / Math.PI;

    this.set(angle);
  }

  /**
   * Reset rotate transform.
   * 
   * @memberOf RotateTransform
   */
  reset() {
    this.set(0);
    super.reset();
  }

  static from(matrix) {
    const transform = new RotateTransform();
    transform.update(matrix);
    return transform;
  }

  toString() {
    return `${this.constructor.name} [angle=${this.angle}]`;
  }
}</PRE></DIV><DIV class="paragraph code-paragraph collapsed" name="ScaleTransform" data-id="GfrFKqKY" __wid="VXpJrNaN"><PRE data-type="content" type="text/javascript" class="transformer" __wid="UB7FsRkc">/**
 * The scale transform.
 * 
 * @class ScaleTransform
 * @extends {Transform}
 */
class ScaleTransform extends Transform {

  /**
   * Creates an instance of ScaleTransform. It will scale a matrix by x and y.
   * 
   * @param {any} x The scale factor in x.
   * @param {any} y The scale factor in y.
   * 
   * @memberOf ScaleTransform
   */
  constructor(x = 1.0, y = 1.0) {
    super();
    this.set(x, y);
  }

  set(x, y) {
    this.x = x;
    this.y = y;

    this.matrix = new Matrix([
      [x, 0, 0],
      [0, y, 0],
      [0, 0, 1],
    ]);
  }

  get inverse() {
    return ScaleTransform.from(this.matrix.inverse);
  }

  update(matrix) {

    if (!(matrix instanceof Matrix)) {
      throw new Error(`matrix needs to be of type ${Matrix.name}`);
    }

    const M = matrix;

    // http://math.stackexchange.com/questions/13150/extracting-rotation-scale-values-from-2d-transformation-matrix
    // const sx = Math.sign(M.a) * Math.sqrt(Math.pow(M.a, 2) + Math.pow(M.b, 2));
    // const sy = Math.sign(M.d) * Math.sqrt(Math.pow(M.c, 2) + Math.pow(M.d, 2));

    const sx = Math.sqrt(Math.pow(M.a, 2) + Math.pow(M.b, 2));
    const sy = Math.sqrt(Math.pow(M.c, 2) + Math.pow(M.d, 2));

    this.set(sx, sy);
  }

  /**
   * Reset scale transform.
   * 
   * @memberOf ScaleTransform
   */
  reset() {
    this.set(1, 1);
    super.reset();
  }

  static from(matrix) {
    const transform = new ScaleTransform();
    transform.update(matrix);
    return transform;
  }

  toString() {
    return `${this.constructor.name} [x=${this.x},y=${this.y}]`;
  }
}</PRE></DIV><DIV class="paragraph code-paragraph collapsed" name="TransformOrigin" data-id="BuDXCNxm" __wid="8CdQiZaS"><PRE data-type="content" type="text/javascript" class="transformer" __wid="tnc4bPmR">class TransformOrigin extends Transform {

  constructor(element, ratioX = 0, ratioY = 0) {
    super();

    if (!element) {
      throw new Error(`element is null or undefined`);
    }

    this.element = element;
    this.set(ratioX, ratioY);
  }

  set(ratioX, ratioY) {
    this.ratioX = ratioX;
    this.ratioY = ratioY;
  }


  get inverse() {
    return TransformOrigin.from(this.element, this.matrix.inverse);
  }

  /**
   * Applies this transform to the matrix given as parameter.
   * 
   * @param {any} matrix The matrix to which this transform will be applied.
   * 
   * @memberOf TransformOrigin
   */
  apply(matrix) {

    // TODO Remove if a notifier to property clientWidth/clientHeight change has been
    // attached to element. Until then always reforce calculation of transform origin.
    const x = this.element.clientWidth * this.ratioX;
    const y = this.element.clientHeight * this.ratioY;

    this.matrix = new Matrix([
      [1, 0, x],
      [0, 1, y],
      [0, 0, 1]
    ]);

    super.apply(matrix);
  }

  /**
   * Unapplies this transformation from the matrix given as paramter.
   * 
   * @param {any} matrix The matrix from which this transform will be unapplied.
   * 
   * @memberOf TransformOrigin
   */
  unapply(matrix) {

    // TODO Remove if a notifier to property clientWidth/clientHeight change has been
    // attached to element. Until then always reforce calculation of transform origin.
    const x = this.element.clientWidth * this.ratioX;
    const y = this.element.clientHeight * this.ratioY;

    this.matrix = new Matrix([
      [1, 0, x],
      [0, 1, y],
      [0, 0, 1]
    ]);

    super.unapply(matrix);
  }

  update(matrix) {

    if (!(matrix instanceof Matrix)) {
      throw new Error(`matrix needs to be of type ${Matrix.name}`);
    }

    const M = matrix;

    this.set(M.tx, M.ty);
  }

  /**
   * Reset transform origin.
   * 
   * @memberOf TransformOrigin
   */
  reset() {
    this.set(0, 0);
    super.reset();
  }

  static from(element, matrix) {
    const transform = new TransformOrigin(element);
    transform.update(matrix);
    return transform;
  }

  toString() {
    return `${this.constructor.name} [ratioX=${this.ratioX}, ratioY=${this.ratioY}]`;
  }
}</PRE></DIV><DIV class="paragraph code-paragraph collapsed" name="TransformGroup" data-id="YTfEM79M" __wid="mLfguWMn"><PRE data-type="content" type="text/javascript" class="transformer" __wid="EQpArwHe">/**
 * The transform group can hold multiple transform of type TranslateTransform, RotateTransform,
 * ScaleTransform, or even another TransformGroup. When the apply function is called, it will apply all
 * added transform in the exact order in which they have been added to the transform group. The unapply
 * function will unapply all transform in the reverse order in which they have been added to the
 * transform group.
 * 
 * @class TransformGroup
 * @extends {Transform}
 */
class TransformGroup extends Transform {

  /**
   * Creates an instance of TransformGroup.
   * 
   * @memberOf TransformGroup
   */
  constructor() {
    super();

    this.transforms = [];
  }

  /**
   * Add a transform (e.g., TranslateTransform, RotateTransform, or ScaleTransform) to the transform
   * group. All transforms will be applied in the order they were added to the transform group. If a
   * transform group is unapplied, it will unapply all transforms in reverse order.
   * 
   * @param {Transform} transform A transform of type Transform (e.g., TranslateTransform, RotateTransform,
   * or ScaleTransform). Eventually, a TransformGroup can also be added.
   * 
   * @throws {Error} Throws an error if transform is not of type Transform.
   * 
   * @memberOf TransformGroup
   */
  add(transform, inverse = false) {

    // Check if transform is of proper type.
    if (!(transform instanceof Transform)) {
      throw new Error(`transform needs to be of type ${Transform.name}`);
    }

    // Add transform to transforms.
    this.transforms.push({
      inverse,
      transform
    });
  }

  /**
   * Remove a transform from this transform group. The transform has to be part of the transform group,
   * otherwise an error will be thrown.
   * 
   * @param {Transform} transform
   * 
   * @throws {Error} Throws an error if transform is not of type Transform and if transform is not part
   * of transform group.
   * 
   * @memberOf TransformGroup
   */
  remove(transform) {

    // Check if transform is of proper type.
    if (!(transform instanceof Transform)) {
      throw new Error(`transform needs to be of type ${Transform.name}`);
    }

    // Check if transform is part of transform group.
    if (!this.transforms.contains(transform)) {
      throw new Error(`transform is not part of this transform group`);
    }

    // Remove transform from transform group.
    const idx = this.transforms.indexOf(transform);
    this.transforms.splice(idx, 1);
  }

  /**
   * Applies all transforms in the order in which they have been added to this transform group. The
   * TransformGroup#apply function is specified in Transform ({@see Transform#apply}).
   * 
   * @param {any} matrix The matrix to which transforms are applied.
   * 
   * @memberOf TransformGroup
   */
  apply(matrix, type = null) {

    // Apply each transform to the matrix.
    this.transforms.forEach(({
      transform,
      inverse
    }) => {
      if (type && !(transform instanceof type) && !(transform instanceof TransformGroup)) {
        return;
      }
      // console.log('apply inverse=%o transform=%o', inverse, transform.toString());
      inverse ? transform.unapply(matrix, type) : transform.apply(matrix, type);
    });
  }

  /**
   * Unapplies all transforms in reverse order in which they have been added to this transform group. The
   * TransformGroup#unapply function is specified in Transform ({@see Transform#unapply}).
   * 
   * @param {any} matrix The matrix from which the transforms are unapplied.
   * 
   * @memberOf TransformGroup
   */
  unapply(matrix, type = null) {

    // Unapply each transform from the matrix in reverse order.
    this.transforms.slice().reverse().forEach(({
      transform,
      inverse
    }) => {
      if (type && !(transform instanceof type) && !(transform instanceof TransformGroup)) {
        return;
      }
      // console.log('unapply inverse=%o transform=%o', inverse, transform.toString());
      inverse ? transform.apply(matrix, type) : transform.unapply(matrix, type);
    });
  }

  /**
   * Reset transform group.
   * 
   * @memberOf TransformGroup
   */
  reset() {
    this.transforms.forEach(({
      transform
    }) => {
      transform.reset();
    });
  }

  /**
   * Transform group to string.
   * 
   * @returns Transform group in string representation.
   * 
   * @memberOf TransformGroup
   */
  toString() {
    return `${this.constructor.name} [transforms=[${this.transforms.map(({transform, inverse}) => {
			return inverse ? transform.inverse.toString() : transform.toString();
		}).join(", ")}]]`;
  }
}</PRE></DIV><DIV class="paragraph code-paragraph collapsed" draggable="false" name="Transformer" data-id="GNzZwswn" __wid="MuvZdTsJ"><PRE data-type="content" type="text/javascript" class="transformer" __wid="ZXVKzJLT">// Module object holding private variables.
const module = {};

(function () {

  const observerOptions = {
    attributes: true,
    subtree: true,
    attributeFilter: ['style']
  };

  const observer = new MutationObserver((mutations) => {

    mutations.forEach(mutation => {
      switch (mutation.type) {
      case "attributes":
        const target = mutation.target;
        if (target.transformer) {
					// check if transform property in style attribute changed
					let transformer = target.transformer;
					
					// only update if no update is in progress (update only happens on requestAnimationFrame)
					// and if current element matrix is different from transformer's current element matrix
					if (
						!transformer.updateInProgress &&
// 						target.style.transform !== transformer.elementMatrix.toCss()
						!Matrix.from(target).equals(transformer.elementMatrix)
					) {
						target.transformer.refreshTransforms();
					}
        }
        break;
      }
    });
  });

  let isConnected = false;

  module.connectObserver = function () {
    if (!isConnected) {
      observer.observe(document.body, observerOptions);
      isConnected = true;
    }
  };

  module.disconnectObserver = function () {
    if (isConnected) {
      observer.disconnect();
      isConnected = false;
    }
  };

  // Listening for DOM changes on style element.
  module.connectObserver();
})();

/**
 * The transform stack builds the base object responsible for transforming a DOM element. It takes an
 * element as constructor parameter and binds itself to this element. The transform stack allows push
 * and pop of transforms. A transform is immediately applied on the element and poping will immediately
 * unapply the transform from the element.
 * 
 * @class Transformer
 */
class Transformer {

  /**
   * Creates an instance of Transformer. It takes a DOM element as contstructor parameter to which
   * this transform stack will bind itself. The transform stack will receive the elements current 
   * transform as matrix, which will be used to apply transforms.
   * 
   * @param {any} element A DOM element to which transforms will be applied. 
   * 
   * @memberOf Transformer
   */
  constructor(element, callback, debug = false) {

    // Element needs to be in DOM to get its clientWidth and clientHeight.
    if (!element.parentElement) {
      throw new Error(`Element has no parent element. Is the element in the DOM?`);
    }

    // Check if callback is set and if it is a function.
    if (callback && typeof callback !== "function") {
      throw new Error(`callback needs to be a function`);
    }

    this.element = element;
    this.element.transformer = this;
    this.callback = callback;
    this.updateInProgress = false;

    let matrix = this.getTransformMatrix();

    // this._transformOrigin = new TransformOrigin(element);
    this._scaleTransform = ScaleTransform.from(matrix);
    this._rotateTransform = RotateTransform.from(matrix);
    this._translateTransform = TranslateTransform.from(matrix);

    const transformGroup = new TransformGroup();
    transformGroup.add(this._rotateTransform);
    transformGroup.add(this._scaleTransform);
    transformGroup.add(this._translateTransform);

    this._transforms = transformGroup;

    // Listen for Webstrates updates.
    // this.listenForUpdates();

    if (debug) {

      let visualTransformOrigin = this.element.querySelector(':scope > .transform-origin-point');

      if (!visualTransformOrigin) {
        // Create visual transform origin
        visualTransformOrigin = document.createElement("transient");
        visualTransformOrigin.setAttribute("class", "transform-origin-point");
        element.appendChild(visualTransformOrigin);
      }

      // const _transformOriginSet = this.transformOrigin.set;
      // this.transformOrigin.set = function(x, y) {
      //     visualTransformOrigin.style.zIndex = "99999";
      //     visualTransformOrigin.style.position = `absolute`;
      //     visualTransformOrigin.style.left = `${x * 100}%`;
      //     visualTransformOrigin.style.top = `${y * 100}%`;
      //     visualTransformOrigin.style.transform = `translate(-50%, -50%)`;
      //     _transformOriginSet.apply(this, arguments);
      // }
    }
  }

  /**
   * Get transform matrix from element transform.
   * 
   * @returns Element transform matrix.
   * 
   * @memberOf Transformer
   */
  getTransformMatrix() {
    return Matrix.from(this.element);
  }

  /**
   * Refresh transfroms from element transform.
   * 
   * @memberOf Transformer
   */
  refreshTransforms() {
    const matrix = this.getTransformMatrix();
    this._translateTransform.update(matrix);
    this._rotateTransform.update(matrix);
    this._scaleTransform.update(matrix);
  }

  /**
   * Reapplies all transforms again. This function should be used when any of the transforms in the transform
   * chain changed.
   * 
   * @memberOf TransformStack
   */
  reapplyTransforms(updateElementsTransform = true) {
    let matrix = Matrix.identity(3);

    if (this.element.renderTransform) {
      this.element.renderTransform.apply(matrix);
    }
    this._transforms.apply(matrix);

    this.elementMatrix = matrix;

    if (updateElementsTransform) {
      // Update element transform.
      return this.updateElement();
    } else {
      return new Promise((resolve, reject) => {
        resolve();
      });
    }
  }

  /**
   * Merge render transform to main transform and reset
   * render transform on success.
   * 
   * @memberOf Transformer
   */
  complete() {
    if (this.element.renderTransform) {
      this.refreshTransforms();
      this.element.renderTransform.reset();
    }
  }

  /**
   * Updates the element's transform matrix.
   * 
   * @returns A promise resolved when element updated successfully.
   * 
   * @memberOf TransformStack
   */
  updateElement() {

    return new Promise((resolve, reject) => {

      if (this.updateInProgress) {
        // reject(`update already in progress`);
        // resolve(this.elementMatrix);
        return;
      }

      window.requestAnimationFrame(() => {

        const updateElementTransform = () => {
          let elementTransform = this.elementMatrix.toCss();
          this.setCssTransform(elementTransform);
        };

        if (this.callback) {
          if (this.callback.call(this, this.elementMatrix)) {
            updateElementTransform();
          }
        } else {
          updateElementTransform();
        }

        this.updateInProgress = false;

        resolve(this.elementMatrix);
      });

      this.updateInProgress = true;
    });
  }

  /**
   * Sets the element's transform also compensating for various vendor prefixes.
   * 
   * @param {any} cssTansform The CSS transform.
   * 
   * @memberOf TransformStack
   */
  setCssTransform(cssTransform) {

    // Stop listening for DOM changes on style element.
    module.disconnectObserver();
		
		// Make sure the element is positioned absolute and its origin is at point (0, 0, 0).
		this.element.style.position = "absolute";
		this.element.style.transformOrigin = "0 0 0";

    if (this.element instanceof SVGElement) {
      cssTransform === "none" ? this.element.removeAttribute("transform") : this.element.setAttribute("transform", cssTransform);
    } else if (this.element.nodeType === 1) {
      this.element.style.webkitTransform = cssTransform;
      this.element.style.mozTransform = cssTransform;
      this.element.style.msTransform = cssTransform;
      this.element.style.oTransform = cssTransform;
      this.element.style.transform = cssTransform;
    }

    // Listening for DOM changes on style element.
    module.connectObserver();
  }

  /**
   * tbd.
   * 
   * @returns
   * 
   * @memberOf Transformer
   */
  getTransformHierarchy() {
    const allTransformers = [];

    // Also collect transforms of parents.
    let parent = this.element;
    do {
      if (parent.transformer) {
        allTransformers.push({
          transformer: parent.transformer,
          renderTransform: parent.renderTransform
        });
      }
    }
    while ((parent = parent.parentElement) !== null);

    // Reverse transform order to start with root transform.
    allTransformers.reverse();

    return allTransformers;
  }

  /**
   * tbd.
   * 
   * @returns
   *
   * @memberOf Transformer
   */
  getAncesterElementWithoutTransformer() {
    let parent = this.element;
    do {
      if (!parent.transformer) {
        return parent;
      }
    }
    while ((parent = parent.parentElement) !== null);

    return window.document.body;
  }

  /**
   * tbd.
   * 
   * @param {any} m
   * 
   * @memberOf Transformer
   */
  applyToLocalTransform(m, type = null) {
    this._transforms.apply(m, type);

    if (this.element.renderTransform) {
      this.element.renderTransform.apply(m, type);
    }
  }

  /**
   * tbd.
   * 
   * @param {any} m
   * 
   * @memberOf Transformer
   */
  applyToGlobalTransform(m, type = null) {
    const allTransformers = this.getTransformHierarchy();

    allTransformers.forEach(({
      transformer,
      renderTransform
    }) => {

      // Undo main transforms.
      if (transformer) {
        transformer._transforms.unapply(m, type);
      }

      // Undo render transforms.
      if (renderTransform) {
        renderTransform.unapply(m, type);
      }
    });
  }

  /**
   * tbd.
   * 
   * @param {any} m
   * 
   * @memberOf Transformer
   */
  unapplyFromGlobalTransform(m, type = null) {
    const allTransformers = this.getTransformHierarchy();

    allTransformers.forEach(({
      transformer,
      renderTransform
    }) => {

      // Apply render transforms.
      if (renderTransform) {
        renderTransform.apply(m, type);
      }

      // Apply main transforms.
      if (transformer) {
        transformer._transforms.apply(m, type);
      }
    });
  }

  /**
   * Converts a point from global coordinates to local coordinates.
   * 
   * @param {Point} point The point with global x- and y-coordinates.
   * @returns The point with local x- and y-coordinates.
   * 
   * @memberOf TransformStack
   */
  fromGlobalToLocal(point) {

    if (!(point instanceof Point)) {
      throw new Error(`point needs to be of instance ${Point.name}`);
    }

    // adjust x and y according to ancestor element offset
    let ancestor = this.getAncesterElementWithoutTransformer();
    let {
      left,
      top
    } = ancestor.getBoundingClientRect();
    let x = left ? point.x - left : point.x;
    let y = top ? point.y - top : point.y;

    let m = Matrix.identity(3);
    m.translate(x, y);

    this.applyToGlobalTransform(m);

    return new Point(m.tx, m.ty);
  }

  /**
   * Converts a point from local coordinates to global coordinates.
   * 
   * @param {any} point The point with local x- and y-coordinates.
   * @returns The point with global x- and y-coordinates.
   * 
   * @memberOf TransformStack
   */
  fromLocalToGlobal(point) {
		
    if (!(point instanceof Point)) {
      throw new Error(`point needs to be of instance ${Point.name}`);
    }

    let m = Matrix.identity(3);
    m.translate(point.x, point.y);

    this.unapplyFromGlobalTransform(m);
		
		// adjust x and y according to ancestor element offset
    let ancestor = this.getAncesterElementWithoutTransformer();
    let {
      left,
      top
    } = ancestor.getBoundingClientRect();
    let x = left ? m.tx + left : m.tx;
    let y = top ? m.ty + top : m.ty;

    return new Point(x, y);
  }

  /**
   * Converts a delta point from global coordinates to local coordinates.
   * 
   * @param {any} point The delta point with global x- and y-coordinates.
   * @returns The delta point with local x- and y-coordinates.
   * 
   * @memberOf TransformStack
   * 
   * @see TransformStack#fromGlobalToLocal
   */
  fromGlobalToLocalDelta(deltaPoint) {

    if (!(deltaPoint instanceof Point)) {
      throw new Error(`delta point needs to be of instance ${Point.name}`);
    }

    const allTransforms = this.getTransformHierarchy();

    let m = Matrix.identity(3);
    m.translate(deltaPoint.x, deltaPoint.y);

    allTransforms.forEach(({
      transformer,
      renderTransform
    }) => {

      // Undo main transforms.
      if (transformer) {
        transformer._transforms.unapply(m, ScaleTransform);
        transformer._transforms.unapply(m, RotateTransform);
      }
    });

    return new Point(m.tx, m.ty);
  }

  /**
   * tbd.
   * 
   * @readonly
   * 
   * @memberOf Transformer
   */
  get localRotation() {
    let m = Matrix.identity(3);
    this.applyToLocalTransform(m, RotateTransform);
    return m.angle;
  }

  /**
   * tbd.
   * 
   * @readonly
   * 
   * @memberOf Transformer
   */
  get globalRotation() {
    let m = Matrix.identity(3);
    this.applyToGlobalTransform(m, RotateTransform);
    return m.angle;
  }

  /**
   * tbd.
   * 
   * @readonly
   * 
   * @memberOf Transformer
   */
  get localScale() {
    let m = Matrix.identity(3);
    this.applyToLocalTransform(m, ScaleTransform);
    return new Point(m.scaleX, m.scaleY);
  }

  /**
   * tbd.
   * 
   * @readonly
   * 
   * @memberOf Transformer
   */
  get globalScale() {
    let m = Matrix.identity(3);
    this.applyToGlobalTransform(m, ScaleTransform);
    return new Point(m.scaleX, m.scaleY);
  }

  /**
   * tbd.
   * 
   * @readonly
   * 
   * @memberOf Transformer
   */
  get globalScaleTest() {
    let m = Matrix.identity(3);
    m.scale(1, 1);

    const allTransformers = [];

    // Also collect transforms of parents.
    let parent = this.element;
    do {
      if (parent.transformer) {
        allTransformers.push({
          transformer: parent.transformer,
          renderTransform: parent.renderTransform
        });
      }
    }
    while ((parent = parent.parentElement) !== null);

    // Apply all transforms in reverse order.
    allTransformers.reverse().forEach(({
      transformer,
      renderTransform
    }) => {

      // Undo main transforms.
      if (transformer) {
        transformer._transforms.apply(m, ScaleTransform);
      }

      // Undo render transforms.
      if (renderTransform) {
        renderTransform.apply(m, ScaleTransform);
      }
    });

    const scaleX = m.a;
    const scaleY = m.d;

    return new Point(scaleX, scaleY);
  }

  /**
   * tbd.
   * 
   * @memberOf Transformer
   */
  destroy() {
    delete this._scaleTransform;
    delete this._rotateTransform;
    delete this._translateTransform;
    delete this._transforms;
  }
}</PRE></DIV><DIV class="paragraph code-paragraph collapsed" name="Transformer Export" data-id="NbE5yABd" __wid="ehebja4p"><PRE data-type="content" type="text/javascript" class="transformer" __wid="rDunp2yK">// Export the transform classes to window.Transformer.
exports.Transformer = {
	Point,
	Matrix,
	TranslateTransform,
	RotateTransform,
	ScaleTransform,
	TransformGroup,
	bindElement: (element, callback, debug) => {

		// check for Promise support
		if (!Promise) {
			throw new Error(`The Transformer library requires Promise support`);
		}

		return new Promise((resolve, reject) => {

			if (element.transformer) {
				return resolve(element.transformer);
			}

			const oldVisbilityValue = element.style.visibility;
			// element.style.visibility = "hidden";

			const makeStack = () => {
				const transformer = new Transformer(element, callback, debug);

				(async() => {
					await transformer.reapplyTransforms();
					resolve(transformer);
				})();
			};

			let runs = 60 * 5; // ca. 5 seconds
			function waitFor() {
				--runs;

				if (runs > 0 && (element.offsetWidth === 0 || element.offsetHeight === 0)) {
					return window.requestAnimationFrame(waitFor);
				}

				if (runs &lt;= 0) {
					console.warn(`could not identify element size width=${element.offsetWidth}, height=${element.offsetHeight}`);
				}
				makeStack();
			}
			waitFor();
		});
	}
};</PRE></DIV></DIV><DIV class="section section-hidden" name="Drawing" data-type="system" data-group="basic" data-id="Kw6McUkB" __wid="tA6hH7Ae"><DIV class="paragraph body-paragraph locked collapsed" name="Documentation" data-id="34EydchL" __wid="9fxns28J"><DIV data-type="content" type="text/html" codemirror="true" contenteditable="false" class="section-documentation" __wid="5v5YTBUM"><H2 __wid="E5MjJ8sh">Description</H2><DIV __wid="PNCRUvEc">TODO</DIV></DIV></DIV><DIV class="paragraph data-paragraph locked collapsed" name="Properties" data-id="MqSH2XDP" __wid="SVwKmZw2"><PRE data-type="content" type="application/json" class="section-properties" contenteditable="false" __wid="KQgBGweE">{
	"version": "1.0",
	"dependencies": [
		{
			"id": "rEpvSgsq",
			"name": "Transformer"
		}
	],
	"description": "Lorem ipsum",
	"changelog":
	{
		"1.0": "Initital Release"
	}
}</PRE></DIV>

<DIV class="paragraph body-paragraph" draggable="false" data-id="KVCXKNxU" __wid="bfS2mDW7">
			<DIV data-type="content" type="text/html" codemirror="true" contenteditable="true" __wid="Q6U4qnVM"><DIV key="canvas-paragraph" class="paragraph-prototype" __wid="DGq3QWD7">
	<I class="material-icons" __wid="LKWuLyDK">gesture</I>
	<DIV class __wid="G6KLAdGR">Canvas Paragraph</DIV>

	<DIV class="template" __wid="R2RkjdQW">
		<DIV class="paragraph body-paragraph" data-id="3n74Rq2r" __wid="DztthVFq">
			<DIV class="canvas" data-type="content" type="text/html" codemirror="true" contenteditable="true" __wid="iZBcZNuR"></DIV>
		</DIV>
	</DIV>
</DIV></DIV>
		</DIV><DIV class="paragraph body-paragraph locked" draggable="false" data-id="fbspmVgB" __wid="3vkLzGP5">
			<DIV data-type="content" type="text/html" codemirror="true" contenteditable="false" __wid="tYqsGpRk">The Canvas Mutation Observer code paragraph is <I __wid="qn2Bak4Z">run-on-load</I> and observes the codestrate for body paragraphs that have the class <I __wid="YxiHR282">canvas</I>. A body paragraph will be <I __wid="nBbD3D9d">upgraded</I> in a canvas when the canvas class is set; and <I __wid="CbE4u28L">downgraded</I> when the <I __wid="GvD4dn5c">canvas</I> class is removed.</DIV>
		</DIV><DIV class="paragraph code-paragraph collapsed" name="Canvas Mutation Observer" last-execution-state="success" run-on-load="true" data-id="Bt6rHkFc" __wid="iRmyqLMh">
        <PRE data-type="content" type="text/javascript" __wid="YeRewTWd">importLib([
  "quadtree.js"
]).then(() => {
  const { Canvas } = require('#canvas');
  const { ToolPalette, ColorTool } = require('#canvas-instruments');

  const createInstruments = (target) => {
    if (!target.__canvas) {
      let canvas = new Canvas(target);
      target.__canvas = canvas;

      let toolPalette = new ToolPalette(target);
			target.__toolPalette = toolPalette;
			
			let colorTool = new ColorTool("color");
			colorTool.on("change", (event) => {
        if (event.type === "color") {
          canvas.penColor = event.value;
        }
      });
			toolPalette.addTool(colorTool);
    }
  };

  const destroyInstruments = (target) => {
    if (target.__canvas) {
      target.__canvas.destroy();
      delete target.__canvas;
			
			target.__toolPalette.destroy();
			delete target.__toolPalette;
    }
  };

  document.liveQuerySelectorAll('.paragraph.body-paragraph .canvas[data-type="content"]')
    .added(createInstruments)
    .removed(destroyInstruments);

  let canvasSelector = document.liveQuerySelectorAll('.paragraph.body-paragraph [data-type="content"]');

  canvasSelector.added(target => {
    target.liveAttribute("class").changed(() => {

      if (target.matches('.canvas')) {
        createInstruments(target);
      }
			else {
        destroyInstruments(target);
      }
    });
  });
});</PRE>
      </DIV><DIV class="paragraph body-paragraph locked" name="Felt Pen" data-id="u53iewMe" __wid="vpFERwiD">
			<DIV data-type="content" type="text/html" codemirror="true" contenteditable="false" __wid="HBEkH3ag">The Pen Tips code paragraph implements a felt pen algorithm that generates felt-pen-like stroke paths.</DIV>
		</DIV><DIV class="paragraph code-paragraph collapsed" name="Pen Tips" data-id="DaKNkN4T" __wid="y8rYVFed">
        <PRE data-type="content" type="text/javascript" id="pen-tips" __wid="aXJdNRj3">/**
 * Calculates the mid-point between the two points A and B and then returns
 * the mid-point.
 *
 * @param {any} pointA The point A.
 * @param {any} pointB The point B.
 * @returns The mid-point between point A and point B.
 */
const midPointBetween = (pointA, pointB) => {
	return {
		x: pointA.x + (pointB.x - pointA.x) / 2,
		y: pointA.y + (pointB.y - pointA.y) / 2
	};
};

exports.FeltPen = {

	/**
   * Generates a path with regard to thickness of each point in path. This
   * implementation was done by @clemens.
   *
   * @param {any} points Path points with x- and y-position and a thickness per
   * point.
   * @returns The path as string.
   */
	generateD: (points, pressureFactor) => {

		const newPoints = [];
		newPoints.push(points[0]);

		for (let j = 1; j &lt; points.length - 1; j++) {
			let p1 = points[j - 1];
			let p = points[j];
			let p2 = points[j + 1];
			let c = {
				x: p2.x - p1.x,
				y: p2.y - p1.y
			};
			let n = {
				x: -c.y,
				y: c.x
			};
			let len = Math.sqrt(n.x * n.x + n.y * n.y);
			if (len == 0) continue;
			let u = {
				x: n.x / len,
				y: n.y / len
			};
			
			let thickness = p.pressure * pressureFactor;

			newPoints.push({
				x: p.x + u.x * thickness,
				y: p.y + u.y * thickness
			});
		}
		newPoints.push(points[points.length - 1]);

		for (let j = points.length - 2; j > 0; j--) {
			let p1 = points[j + 1];
			let p = points[j];
			let p2 = points[j - 1];
			let c = {
				x: p2.x - p1.x,
				y: p2.y - p1.y
			};
			let n = {
				x: -c.y,
				y: c.x
			};
			let len = Math.sqrt(n.x * n.x + n.y * n.y);
			if (len == 0) continue;
			let u = {
				x: n.x / len,
				y: n.y / len
			};
			
			let thickness = p.pressure * pressureFactor;

			newPoints.push({
				x: p.x + u.x * thickness,
				y: p.y + u.y * thickness
			});
		}
		let p1 = newPoints[0];
		let p2 = newPoints[1];
		let pathString = "M" + p1.x + " " + p1.y;
		for (let j = 1; j &lt; newPoints.length; j++) {
			let midPoint = midPointBetween(p1, p2);
			if (isNaN(p1.x) || isNaN(p1.y) || isNaN(midPoint.x) || isNaN(midPoint.y)) {
				console.log("NaN");
			}
			pathString = pathString += " Q " + p1.x + " " + p1.y + " " + midPoint.x + " " + midPoint.y;
			p1 = newPoints[j];
			p2 = newPoints[j + 1];
		}

		return pathString;
	}
};</PRE>
      </DIV><DIV class="paragraph body-paragraph locked" name="Canvas" data-id="sFpH6puY" __wid="p48HhqGF">
			<DIV data-type="content" type="text/html" codemirror="true" contenteditable="false" __wid="sQnQgqWf">The Canvas code paragraph modifies a body paragraph of class canvas to allow whiteboard-like drawing. Therefore, it adds a SVG element to the body paragraph, if it does not exist. It further adds event listeners to the body paragraph to listen for pen and eraser events. Currently these events are hard-coded, but may be dynamically assignable by the user. On pen down event, it generates a path and on pen move it generates a stroke based on the pen points. On eraser move events, it checks for intersections of the eraser movement and path elements in the SVG element. If the eraser movement and a path element intersect, the path element will be removed.</DIV>
		</DIV><DIV class="paragraph code-paragraph collapsed" name="Canvas" data-id="NqCrNXKW" __wid="5nn5K9PA">
        <PRE data-type="content" type="text/javascript" id="canvas" __wid="dZxGHjWA">const { Transformer } = require('.transformer');
const { Pen } = require('#pen');
const EraserUtils = require('#eraser-utils');
const svgNS = "http://www.w3.org/2000/svg";

const DEFAULT_OPTIONS = {
	isElementsIndexEnabled: true,
	isAllowedPenEvent: [
		// pen event
		(event) => {
			if (event.pointerType === "pen") {
				event.preventDefault();
				return true;
			}
			return false;
		},
		// ctrl+mouse event
		(event) => {
			if (event.shiftKey && event.pointerType === "mouse") {
				event.preventDefault();
				return true;
			}
			return false;
		}
	],
	isAllowedEraserEvent: [
		// touch event
		(event) => {
			if (event.pointerType === "touch") {
				event.preventDefault();
				return true;
			}
			return false;
		},
		// alt+mouse event
		(event) => {
			if (event.altKey && event.pointerType === "mouse") {
				event.preventDefault();
				return true;
			}
			return false;
		}
	],
	correctPoint: (point) => {
		return point;
	}
};

exports.Canvas = class Canvas {

	constructor(target, options = {}) {
		this.target = target;

		// Merge options with default options
		this.options = Object.assign({}, DEFAULT_OPTIONS, options);

		this.penColor = "black";
		this.tools = {};

		this.target.liveQuerySelectorAll('svg').added((svg) => {
			
			// only initialize elements index for svg of this canvas
			if (svg.parentElement === this.target) {
				// Initialize elements index if enabled, but not initialized
				if (this.options.isElementsIndexEnabled && !this._elementsIndex) {
					this._initElementsIndex(svg);
				}
			}
		}).removed((svg) => {
			// only clear element index for svg of this canvas
			if (svg.parentElement === this.target && this._elementsIndex) {
				try {
					this._elementsIndex.clear();
					this._elementsIndex = null;
				}
				catch (error) {
					console.warn(`error when svg element removed ${error}`);
				}
			}
		});

		this.offset = this.target.getBoundingClientRect();

		// Update offset on scroll
		let ticking = false;
		window.addEventListener("scroll", () => {
			if (!ticking) {
				window.requestAnimationFrame(() => {
					this.offset = this.target.getBoundingClientRect();
					ticking = false;
				});
			}
			ticking = true;
		});

		// Also update offset on class change, e.g., fullscreen change
		let paragraph = target.closest('.paragraph');
		paragraph.liveAttribute("class").changed(() => {
			this.offset = this.target.getBoundingClientRect();
		});

		// in case the canvas transitions
		this.target.addEventListener("transitionend", (e) => {
			this.offset = this.target.getBoundingClientRect();
		});

		if (!!window.PointerEvent) {
			this.target.addEventListener("pointerdown", (e) => this._onPointerDown(e));
			this.target.addEventListener("pointermove", (e) => this._onPointerMove(e));
			this.target.addEventListener("pointerup", (e) => this._onPointerUp(e));
			
			// enabling to draw on canvas by entering it
			this.target.addEventListener("pointerover", (e) => {
				// on any button down
				if (e.buttons > 0) {
					this._onPointerDown(e);
				}
			});

			// stop drawing on canvas when leaving it
			this.target.addEventListener("pointerout", (e) => {
				// on any button down
				if (e.buttons > 0) {
					this._onPointerUp(e);
				}
			});
		}
		else {
			this.target.addEventListener("touchstart", (e) => {
				this._dispatchTouchEvent(e, this._onPointerDown);
			});
			this.target.addEventListener("touchmove", (e) => {
				this._dispatchTouchEvent(e, this._onPointerMove);
			});
			this.target.addEventListener("touchend", (e) => {
				this._dispatchTouchEvent(e, this._onPointerUp);
			});
		}
	}

	/**
	 * Upgrade touch events with pointer event properties
	 */
	_dispatchTouchEvent(event, dispatch) {
		Array.prototype.forEach.call(event.changedTouches, touch => {
			touch.pointerId = touch.identifier + 2;
			touch.pressure = (touch.force && touch.force > 0.1 ? touch.force : 0) * 2;
			touch.preventDefault = function() {
				event.preventDefault();
			};
			touch.stopPropagation = function() {
				event.stopPropagation();
			};
			touch.stopImmediatePropagation = function() {
				event.stopImmediatePropagation();
			};
			if (touch.touchType === "direct") {
				touch.pointerType = "touch";
			}
			else if (touch.touchType === "stylus") {
				touch.pointerType = "pen";
			}
			
// 			window.console.log("pointerType", touch.pointerType);

			dispatch.call(this, touch);
		});
	}
	
	_isValidPenEvent(event) {
		// only process events that are on the target
		if (event.target !== this.target) return false;
							
		let allowed = this.options.isAllowedPenEvent;
		let len = allowed.length;
		for (let i = 0; i &lt; len; i++) {
			if (allowed[i].call(this, event)) {
				event.preventDefault();
				return true;
			}
		}
		
		return false;
	}
	
	_isValidEraserEvent(event) {
		// only process events that are on the target
		if (event.target !== this.target) return false;
		
		let allowed = this.options.isAllowedEraserEvent;
		let len = allowed.length;
		for (let i = 0; i &lt; len; i++) {
			if (allowed[i].call(this, event)) {
				event.preventDefault();
				return true;
			}
		}
		
		return false;
	}

	_getSVG() {
		// Check if target already has an svg element
		let svg = Array.from(this.target.children).find(e => {
			return e.tagName.toLowerCase() === "svg";
		});

		// Create an svg element if it does not have one
		if (!svg) {
			svg = document.createElementNS(svgNS, "svg");
			svg.setAttribute("xmlns", svgNS);
			svg.setAttribute("xlink", "http://www.w3.org/1999/xlink");
			svg.setAttribute("xmlns:xlink", "");
			svg.setAttribute("class", "drawing-canvas");

			this.target.insertBefore(svg, this.target.firstElementChild);
		}

		return svg;
	}

	_initElementsIndex(svg) {
		let svgBounds = svg.getBoundingClientRect();

		this._elementsIndex = new Quadtree({
			x: 0,
			y: 0,
			width: svgBounds.width,
			height: svgBounds.height
		}, 4);

		svg.liveQuerySelectorAll('path').added(path => {
			path.__observer = path.liveAttribute("complete").changed((value, oldValue) => {
				if (value === "true") {
					// 					window.console.log("path complete");
					this._addElementsToIndex(svg, [path]);
				}
			});
		}).removed(path => {
			if (path.__indexObject) {
				this._elementsIndex.removeObject(path.__indexObject);
				this._elementsIndex.cleanup();
				path.__observer.stop();
			}
		});

		// Add existing paths to index
// 		let elementsToIndex = svg.querySelector('[index="true"]');
// 		this._addElementsToIndex(svg, elementsToIndex);
	}

	_calculateBounds(svgBounds, element) {
		let globalBounds = element.getBoundingClientRect();
		return {
			x: globalBounds.left - svgBounds.left,
			y: globalBounds.top - svgBounds.top,
			width: globalBounds.width,
			height: globalBounds.height
		};
	}

	_addElementsToIndex(svg, elements) {
		let svgBounds = svg.getBoundingClientRect();

		Array.prototype.forEach.call(elements, element => {
			let bounds = this._calculateBounds(svgBounds, element);
			bounds.element = element;
			element.__indexObject = bounds;
			this._elementsIndex.insert(bounds);
		});
	}

	_createPen(event) {

		let pen = new Pen((path) => this.onPathAdded(path), {
			color: this.penColor,
			pressureFactor: 1.5
		});

		this.tools[event.pointerId] = pen;

		return pen;
	}

	_getPen(event) {
		return this.tools[event.pointerId];
	}

	_getPoint(event) {
		
		let point;
		
		// check if target element is using Transformer
		if (this.target.transformer) {
			let transformerPoint = new Transformer.Point(event.clientX, event.clientY);
			point = this.target.transformer.fromGlobalToLocal(transformerPoint);
		}
		else {
			point = {
				x: event.clientX - this.offset.left,
				y: event.clientY - this.offset.top
			};
		}
		
		return this.options.correctPoint(point);
	}

	_onPointerDown(event) {
		if (this._isValidPenEvent(event)) {
			this.onPenDown(event);
		}
		else if (this._isValidEraserEvent(event)) {
			this.onEraserDown(event);
		}
	}

	_onPointerMove(event) {
		if (this._isValidPenEvent(event)) {
			this.onPenMove(event);
		}
		else if (this._isValidEraserEvent(event)) {
			this.onEraserMove(event);
		}
	}

	_onPointerUp(event) {
		if (this._isValidPenEvent(event)) {
			this.onPenUp(event);
		}
		else if (this._isValidEraserEvent(event)) {
			this.onEraserUp(event);
		}
	}

	onPenDown(event) {
		let pen = this._createPen(event);
		let point = this._getPoint(event);
		point.pressure = event.pressure || 1.0;
		pen.addPoint(point);
	}

	onPenMove(event) {
		let pen = this._getPen(event);
		if (pen) {
			let point = this._getPoint(event);
			point.pressure = event.pressure || 1.0;
			pen.addPoint(point);
		}
	}

	onPenUp(event) {
		let pen = this._getPen(event);
		
		if (pen && pen instanceof Pen) {
			let point = this._getPoint(event);
			point.pressure = event.pressure || 1.0;
			pen.addPoint(point);
			pen.destroy();
		}
		
		delete this.tools[event.pointerId];
	}

	onEraserDown(event) {
		this.tools[event.pointerId] = {
			type: "eraser",
			point: this._getPoint(event)
		};
	}

	onEraserMove(event) {
		let eraser = this.tools[event.pointerId];
		if (eraser) {
			// Get svg element
			let svg = this._getSVG();
			let point = this._getPoint(event);
			let eraserPoint = eraser.point;
			eraser.point = point;
			
			let thickness = 5;

			setTimeout(() => {
				
// 				let bounds = {
// 					x: point.x - thickness,
// 					y: point.y - thickness,
// 					width: thickness * 2,
// 					height: thickness * 2
// 				};
				
				let x1 = Math.min(eraserPoint.x, point.x);
				let y1 = Math.min(eraserPoint.y, point.y);
				let x2 = Math.max(eraserPoint.x, point.x);
				let y2 = Math.max(eraserPoint.y, point.y);
				let width = x2 - x1 || 1;
				let height = y2 - y1 || 1;
				
				let bounds = {
					x: x1,
					y: y1,
					width: width,
					height: height,
					point1: {
						x: x1,
						y: y1
					},
					point2: {
						x: x1 + width,
						y: y1 + height
					}
				};
				
// 				window.console.log(bounds);

				let candidates = this._elementsIndex.retrieve(bounds).map((item) => {
					return item.element;
				});
				
// 				window.console.log(`children: ${svg.childNodes.length}, candidates: ${candidates.length}, subset: ${Math.round((candidates.length / svg.childNodes.length) * 100)}`);
				
// 				window.console.log(candidates);
				
				let promise = EraserUtils.eraseIntersectingPaths(bounds, candidates);
				promise.then((intersectingPaths) => {
					Array.prototype.forEach.call(intersectingPaths, ip => {
						this._elementsIndex.removeObject(ip.__indexObject);
						this._elementsIndex.cleanup();
						ip.remove();
					});
				});
			}, 0);
		}
	}

	onEraserUp(event) {
		delete this.tools[event.pointerId];
	}

	onPathAdded(path) {
		// Get svg element
		let svg = this._getSVG();
		svg.appendChild(path);
	}

	destroy() {

		// TODO Removing event listeners does not work because in the constructor event
		// handlers are anonymous functions
		// 		this.target.removeEventListener("pointerdown", this.onPenDown);
		// 		this.target.removeEventListener("pointermove", this.onPenMove);
		// 		this.target.removeEventListener("pointerup", this.onPenUp);
	}
};</PRE>
      </DIV><DIV class="paragraph code-paragraph collapsed" name="Pen" data-id="yxxxBQKW" __wid="eiNvdwWB">
        <PRE data-type="content" type="text/javascript" id="pen" __wid="PPRfawxJ">const svgNS = "http://www.w3.org/2000/svg";
const pathCutLength = 100;
const connectingPointsOnCut = 5;

const DEFAULT_OPTIONS = {
	penTip: require('#pen-tips').FeltPen,
	color: "black",
	pressureFactor: 1.0
};

exports.Pen = class Pen {

	constructor(onPathCreated, options = {}) {
		this.onPathCreated = onPathCreated;
		
		// Merge options with default options
		this.options = Object.assign(DEFAULT_OPTIONS, options);

		this._paths = [];
		this._points = [];
	}
	
	get paths() {
		return this._paths;
	}

	addPoint(point) {

		// Also reset path when > pathCutLength to circumvent performance issue when
		// drawing long paths
		let len = this._points.length;
		if (!len || len > pathCutLength) {

			// Remove previous points except for # of connecting points to connect new path
			// with previous path
			if (len > pathCutLength) {
				this._points.splice(0, pathCutLength - connectingPointsOnCut);
				this._pathComplete();
			}

			this._path = document.createElementNS(svgNS, "path");
			this._path.setAttribute("fill", this.options.color);
			this._paths.push(this._path);
			
			this.onPathCreated(this._path);
		}

		this._points.push(point);

		let d = this.options.penTip.generateD(this._points, this.options.pressureFactor);
		this._path.setAttribute("d", d);
	}
	
	_pathComplete() {
		if (this._path) {
			
			// Only complete path if bounds larger than 0, otherwise remove
			let bounds = this._path.getBoundingClientRect();

			if (bounds.width > 0 || bounds.height > 0) {
				this._path.setAttribute("complete", "true");
			}
			else {
				this._path.remove();
			}
		}
	}

	destroy() {
		this._pathComplete();
		this._points.length = 0;
		this._paths.length = 0;
	}
};</PRE>
      </DIV><DIV class="paragraph code-paragraph collapsed" name="Canvas Instruments" data-id="ujr23FGQ" __wid="esrWNy9B">
        <PRE data-type="content" type="text/javascript" id="canvas-instruments" __wid="R8jTXpgb">class EventHandler {
	
	constructor() {
		this._listeners = [];
	}
	
	on(name, handler) {
		this._listeners.push({
			name: name,
			handler: handler
		});
	}

	off(name, listener) {
		throw new Error(`Not yet implemented`);
	}

	triggerEvent(name, event) {
		this._listeners.forEach((listener) => {
			if (listener.name === name) {
				listener.handler.call(this, event);
			}
		});
	}
}

class Tool extends EventHandler {

  constructor(name) {
		super();
		
		if (typeof name !== "string") {
			throw new Error(`parameter name needs to be of type string`);
		}
		
		this.name = name;
		this.element = this.createElement();
		this.element.classList.add("tool");
  }
	
	createElement() {
		throw new Error(`createElement not implemented, but it should return a container element`);
	}
	
	set visible(value) {
		if (value) {
			this.element.classList.remove("hide");
		}
		else {
			this.element.classList.add("hide");
		}
	}
	
	get visible() {
		return !this.element.classList.contains("hide");
	}

  destroy() {
    // empty
  }
}

exports.Tool = Tool;

class ColorTool extends Tool {

	constructor(name, options) {
		super(name);
		
		this.options = Object.assign({}, {
			colors: ["black", "red", "green", "blue"],
			className: "colors",
			eventName: "change",
			eventType: "color"
		}, options);

		// add class name to element
		this.element.classList.add(this.options.className);

		this.options.colors.forEach((c, idx) => {
			const color = document.createElement("li");
			color.classList.add("color");
			color.style.backgroundColor = c;
			this.element.appendChild(color);
			
			if (!idx) {
				this._selectColor(color);
			}
		});

		this.element.addEventListener("pointerdown", (e) => {
			this._consumeEvent(e);
			this._onPointerDown(e);
		});
		this.element.addEventListener("pointermove", this._consumeEvent);
		this.element.addEventListener("pointerup", this._consumeEvent);
		
		this.element.addEventListener("touchstart", (e) => {
			this._consumeEvent(e);
			this._onPointerDown(e);
		});
		this.element.addEventListener("touchmove", this._consumeEvent);
		this.element.addEventListener("touchend", this._consumeEvent);
	}
	
	createElement() {
		return document.createElement("ul");
	}
	
	_getColor(event) {
		return event.target.closest('.color');
	}
	
	select(colorValue) {
		let colors = Array.from(this.element.querySelectorAll('.color'));
		let color = colors.find((c) => c.style.backgroundColor === colorValue);
		if (color) {
			this._selectColor(color);
			return true;
		}
		return false;
	}
	
	_selectColor(color) {
		Array.prototype.forEach.call(this.element.querySelectorAll('.color'), (c) => {
			c.classList.remove("active");
		});
		color.classList.add("active");

		// dispatch change event
		this.triggerEvent(this.options.eventName, {
			type: this.options.eventType,
			value: color.style.backgroundColor
		});
	}

	_onPointerDown(event) {
		let color = this._getColor(event);
		if (color) {
			this._selectColor(color);
		}
	}

	_consumeEvent(event) {
		event.preventDefault();
		event.stopPropagation();
		event.stopImmediatePropagation();
	}
}

exports.ColorTool = ColorTool;

class ToolPalette {

	constructor(target) {
		this.target = target;

		this.element = document.createElement("transient");
		this.element.classList.add("tool-palette");

		this._tools = {};

		target.insertBefore(this.element, target.firstElementChild);
	}
	
	addTool(tool) {
		if (!(tool instanceof Tool)) {
			throw new Error(`tool needs to be instanceof Tool`);
		}
		
		if (this._tools[tool.name]) {
			throw new Error(`tool with the same name already exists`);
		}
		
		// add tool
		this._tools[tool.name] = tool;
		
		// add tool's element to tool palette
		this.element.appendChild(tool.element);
	}
	
	get tools() {
		// do not allow to modify tools from outside tool palette
		return Object.freeze(this._tools);
	}
	
	getTool(name) {
		if (!name) {
			throw new Error(`name parameter is required`);
		}
		
		// return named tool
		return this._tools[name];
	}
	
	destroy() {
		// destroy each tool
		for (let n in this._tools) {
			let tool = this._tools[n];
			
			// remove element from parent
			this.element.remove();
			
			// destroy tool
			tool.destroy();
			
			// delete tool from tools object
			delete this._tools[n];
		}
	}
}

exports.ToolPalette = ToolPalette;</PRE>
      </DIV><DIV class="paragraph style-paragraph collapsed" name="Canvas Style" data-id="FygJSFcB" __wid="Ydf4KmBw">
			<STYLE data-type="content" type="text/css" codemirror="true" __wid="B3QvteVD">#test-canvas,
.canvas {
	position: relative;
	min-height: 300px;
	background-color: white;

	overflow: hidden;
	touch-action: none;
	/*  	cursor: none; */
	cursor: pointer;
	overflow: hidden !important;
}

#test-canvas > svg.drawing-canvas,
.canvas > svg.drawing-canvas {
	position: absolute;
	z-index: 1;

	top: 0;
	left: 0;
	bottom: 0;
	right: 0;
	border: 0;
	padding: 0;
	margin: 0;
	box-sizing: border-box;
	width: 100%;
	height: 100%;
	pointer-events: none;

	/*  	background-color: hotpink; */
}

#test-canvas > .tool-palette,
.canvas > .tool-palette {
	position: absolute;
	bottom: 0;
	left: 50%;
	z-index: 2;

	transform: translate3d(-50%, -10px, 0);

	/* 	transform: translate3d(-50%, 100%, 0);
	transition: transform 250ms ease-in-out; */
	/* 	background-color: orange; */
}

@media only screen 
	and (min-device-width : 768px) 
	and (max-device-width : 1024px)  {
		#test-canvas > .tool-palette,
		.canvas > .tool-palette {
			top: 0;
			
			/* height 0 fixes 100% height issue on iOS */
			height: 0;
			
			transform: translate3d(-50%, 10px, 0);
		}
}

/* #test-canvas:hover > .tool-palette,
.canvas:hover > .tool-palette {
transform: translate3d(-50%, -10px, 0);
} */

#test-canvas > .tool-palette .colors,
.canvas > .tool-palette .colors {
	list-style: none;
	margin: 0;
	padding: 0;
}

#test-canvas > .tool-palette .colors .color,
.canvas > .tool-palette .colors .color {
	position: relative;
	float: left;
	width: 30px;
	height: 30px;
	border-radius: 50%;
	margin: 5px;

	box-sizing: border-box;
}

#test-canvas > .tool-palette .colors .color.active:after,
.canvas > .tool-palette .colors .color.active:after {
	content: "";
	position: absolute;
	left: -5px;
	top: -5px;
	width: 40px;
	height: 40px;
	
	border: 3px solid rgba(0, 0, 0, .75);
	border-radius: 50%;
	box-sizing: border-box;
}</STYLE>
		</DIV><DIV class="paragraph code-paragraph collapsed" last-execution-state="success" name="Drawing Main Code" draggable="false" data-id="txWtHcbH" __wid="y3vmwc3s"><PRE data-type="content" type="text/javascript" __wid="k7XeY5Zm">const enableDrawing = drawable => {
// 	console.log(drawable);

	let penColor = "white";
	let ctx;
	
	const begin = point => {
		const DrawingUtil = require('#drawing-util');
		ctx = DrawingUtil.begin(drawable, penColor);
		ctx.addPoint(point);
	};
	
	const move = point => {
		ctx.addPoint(point);
	};
	
	const end = point => {
		// empty
	};
	
	const MouseHandler = require('#drawing-mouse-handler');
	MouseHandler.enable(drawable, {
		begin,
		move,
		end
	});
	
	const ApplePenHandler = require('#drawing-apple-pen-handler');
	ApplePenHandler.enable(drawable, {
		begin,
		move,
		end
	});
};

document.liveQuerySelectorAll('.drawable').added(enableDrawing);</PRE></DIV><DIV class="paragraph code-paragraph collapsed" name="Drawing Event Utils" draggable="false" data-id="YzesPAT2" __wid="i3wE5VGt"><PRE data-type="content" type="text/javascript" id="event-util" __wid="miHWjLKA">exports.getCoordinate = (target, event) => {

	const rect = target.getBoundingClientRect();

	return {
		x: Math.floor(event.clientX - rect.left),
		y: Math.floor(event.clientY - rect.top)
	};
};</PRE></DIV><DIV class="paragraph style-paragraph collapsed" draggable="false" name="No Cursor in Fullscreen" data-id="GLCTkjwd" __wid="8ebjPUKe"><STYLE data-type="content" type="text/css" codemirror="true" __wid="Lc86TYcF">/*
@media (pointer: fine) and (hover: hover) {
	.canvas {
		background-color: limegreen;
		cursor: auto;
	}
}

@media (pointer: fine) and (hover: none) {
	.canvas {
		background-color: hotpink !important;
		cursor: none !important;
	}
}
*/

/* .body-paragraph.fullscreen .canvas {
	cursor: none !important;
} */</STYLE></DIV><DIV class="paragraph code-paragraph collapsed" name="Intersection Utils" data-id="bpPfV4Uj" __wid="nr9jEwCF">
        <PRE data-type="content" type="text/javascript" id="intersection-utils" __wid="PTrVGjRq">const calculateQuadraticLineIntersect = (p1, p2, p3, a1, a2) => {
	var lerp = function(a, b, x) { return (a + x * (b - a)); };

	var intersections = [];

	// inverse line normal
	var normal = {
		x: a1.y - a2.y,
		y: a2.x - a1.x,
	};

	// Q-coefficients
	var c2 = {
		x: p1.x + p2.x * -2 + p3.x,
		y: p1.y + p2.y * -2 + p3.y
	};

	var c1 = {
		x: p1.x * -2 + p2.x * 2,
		y: p1.y * -2 + p2.y * 2,
	};

	var c0 = {
		x: p1.x,
		y: p1.y
	};

	// Transform to line 
	var coefficient = a1.x * a2.y - a2.x * a1.y;
	var a = normal.x * c2.x + normal.y * c2.y;
	var b = (normal.x * c1.x + normal.y * c1.y) / a;
	var c = (normal.x * c0.x + normal.y * c0.y + coefficient) / a;

	// solve the roots
	var roots = [];
	d = b * b - 4 * c;
	if (d > 0) {
		var e = Math.sqrt(d);
		roots.push((-b + Math.sqrt(d)) / 2);
		roots.push((-b - Math.sqrt(d)) / 2);
	}
	else if (d == 0) {
		roots.push(-b / 2);
	}

	// calc the solution points
	for (var i = 0; i &lt; roots.length; i++) {
		var minX = Math.min(a1.x, a2.x);
		var minY = Math.min(a1.y, a2.y);
		var maxX = Math.max(a1.x, a2.x);
		var maxY = Math.max(a1.y, a2.y);
		var t = roots[i];
		if (t >= 0 && t &lt;= 1) {
			// possible point -- pending bounds check
			var point = {
				x: lerp(lerp(p1.x, p2.x, t), lerp(p2.x, p3.x, t), t),
				y: lerp(lerp(p1.y, p2.y, t), lerp(p2.y, p3.y, t), t)
			};
			var x = point.x;
			var y = point.y;
			// bounds checks
			if (a1.x == a2.x && y >= minY && y &lt;= maxY) {
				// vertical line
				intersections.push(point);
			}
			else if (a1.y == a2.y && x >= minX && x &lt;= maxX) {
				// horizontal line
				intersections.push(point);
			}
			else if (x >= minX && y >= minY && x &lt;= maxX && y &lt;= maxY) {
				// line passed bounds check
				intersections.push(point);
			}
		}
	}
	return intersections;
};

const parseQuadraticSegments = (svgPath) => {
	var pathData = svgPath.getAttributeNS(null, "d");

	var segments = [];

	var startPointMatch = pathData.match(/M(\s*)(\S+) (\S+)/);

	var startPoint = {
		x: parseInt(startPointMatch[1]),
		y: parseInt(startPointMatch[2])
	};

	var quadraticPattern = /Q (\S+) (\S+) (\S+) (\S+)/;
	var quadraticPatternGlobal = /Q (\S+) (\S+) (\S+) (\S+)/g;

	var quadraticMatches = pathData.match(quadraticPatternGlobal);

	quadraticMatches.forEach(function (v) {
		var result = v.match(quadraticPattern);

		var controlPoint = {
			x: parseInt(result[1]),
			y: parseInt(result[2])
		};

		var endPoint = {
			x: parseInt(result[3]),
			y: parseInt(result[4])
		};

		segments.push({
			start: startPoint,
			control: controlPoint,
			end: endPoint
		});

		startPoint = endPoint;
	});

	return segments;
};

exports.intersect = (svgPath, a1, a2) => {
	var pathElements = parseQuadraticSegments(svgPath);

	var intersected = false;

	pathElements.forEach(function(segment) {
		var intersections = calculateQuadraticLineIntersect(segment.start, segment.control, segment.end, a1, a2);

		if(intersections.length > 0) {
			intersected = true;
		}
	});

	return intersected;
};</PRE>
      </DIV><DIV class="paragraph code-paragraph collapsed" draggable="false" name="Eraser Utils" data-id="zsS4m8J3" __wid="fEcJNnKg"><PRE data-type="content" type="text/javascript" id="eraser-utils" __wid="Xirw6ttR">const Intersection = require('#intersection-utils');

exports.eraseIntersectingPaths = (bounds, paths) => {

	return new Promise((resolve, reject) => {
		let result = Array.prototype.filter.call(paths, child => {
			try {
				if(Intersection.intersect(child, bounds.point1, bounds.point2)) {
					return child;
				}
			}
			catch(error) {
				console.log(error);
			}
			return null;
		});

		resolve(result);
	});
};</PRE></DIV></DIV><DIV name="Shared Pointers" class="section section-hidden" data-type="system" data-group="basic" data-id="mhzRF233" __wid="6yrXrdAH"><DIV class="paragraph body-paragraph locked collapsed" name="Documentation" data-id="XUF62tu7" __wid="bczuDqsC"><DIV data-type="content" type="text/html" codemirror="true" contenteditable="false" class="section-documentation" __wid="Xb6nWjcS"><H2 __wid="qc4BSrWU">Description</H2><DIV __wid="tt6uD7KS">TODO</DIV></DIV></DIV><DIV class="paragraph data-paragraph locked collapsed" name="Properties" data-id="xVmNyYKM" __wid="LqSp8Y5E"><PRE data-type="content" type="application/json" class="section-properties" contenteditable="false" __wid="bpP4LwZz">{
	"version": "1.0",
	"dependencies": [],
	"description": "Lorem ipsum",
	"changelog":
	{
		"1.0": "Initital Release"
	}
}</PRE></DIV>

<DIV class="paragraph code-paragraph collapsed" name="Shared Pointers Code" run-on-load="true" last-execution-state="success" data-id="KaMxKCbr" __wid="usFffJUA"><PRE data-type="content" type="text/javascript" __wid="QNTHqwwR">const ClientManager = require('#client-manager');

var clients = {};

const adjustCoords = (x, y) => {
  //returns an object with the position relative to the body and relative to a given
  //paragraph. If the cursor is not on top of a paragraph the paraId will be null

  const rect = document.body.getBoundingClientRect();
  const elemAtPoint = document.elementFromPoint(window.innerWidth / 2, y - document.body.scrollTop);
  const paragraphAtCursor = elemAtPoint ? elemAtPoint.closest(".paragraph") : null;

  let paraX = 0;
  let paraY = 0;
  let paraId = null;

  if (paragraphAtCursor !== null) {
    paraId = paragraphAtCursor.webstrate.id;
    let paraRect = paragraphAtCursor.getBoundingClientRect();
    paraX = x - paraRect.left;
    paraY = y - paraRect.top - document.body.scrollTop;
  }

  return {
    paraId: paraId,
    paraX: paraX,
    paraY: paraY,
    x: x - rect.left,
    y: y
  };
};

document.addEventListener("mousedown", function (e) {
  const pos = adjustCoords(e.pageX, e.pageY);
  throttledSignal({
    cmd: "click",
    data: pos
  });
});

document.addEventListener("touchstart", function (e) {
  if (e.touches.length > 0) {
    const touch = e.touches[0];
    const pos = adjustCoords(touch.pageX, touch.pageY);
    throttledSignal({
      cmd: "click",
      data: pos
    });
  }
});

document.addEventListener("mousemove", function (e) {
  const pos = adjustCoords(e.pageX, e.pageY);
  throttledSignal({
    cmd: "pos",
    data: pos
  });
});

document.addEventListener("touchmove", function (e) {
  if (e.touches.length > 0) {
    const touch = e.touches[0];
    const pos = adjustCoords(touch.pageX, touch.pageY);
    throttledSignal({
      cmd: "pos",
      data: pos
    });
  }
});

document.body.webstrate.on("signal", function (msg, clientId) {
  if (clientId == window.webstrate.clientId) return;
  if (msg.cmd === undefined) return;
  else if (msg.cmd === "pos") {

    if (clients[clientId] === undefined) return;
    clients[clientId].classList.remove("hidden");


    const remoteCursorPostion = getRemoteCursorPostion(msg);

    clients[clientId].style.left = remoteCursorPostion.x + "px";
    clients[clientId].style.top = remoteCursorPostion.y + "px";

    // Hide cursor after five seconds of inactivity
    if (clients[clientId].__timeout) clearTimeout(clients[clientId].__timeout);
    clients[clientId].__timeout = setTimeout(function () {
      if (!clients[clientId]) return;
      clients[clientId].classList.add("hidden");
    }, 5000);

  } else if (msg.cmd === "click") {
    clicked(msg, clientId);
  }
});

webstrate.on("signal", (message, senderId) => {

  if (message.type === "IdleTimer") {

    if (message.cmd === "awake") {
      clientJoin(senderId);
    } else if (message.cmd === "idle") {
      clientPart(senderId);
    }
  }
});

webstrate.on("clientJoin", function (clientId) {
  clientJoin(clientId);
});

webstrate.on("clientPart", function (clientId) {
  clientPart(clientId);
});

function clientJoin(clientId) {
  // Ignore own cursor
  if (clientId === webstrate.clientId) return;

  clients[clientId] = createCursor(clientId);
}

function clientPart(clientId) {
  if (!clients.hasOwnProperty(clientId)) return;
  clients[clientId].parentElement.removeChild(clients[clientId]);
  delete clients[clientId];
}

function createCursor(clientId) {
	let client = ClientManager.getClient(clientId);
	
  var cursor = document.createElement("transient");
  cursor.classList.add("remote-cursor");
  cursor.setAttribute("client-id", clientId);
	cursor.setAttribute("username", client.username);
  cursor.style.borderColor = client.color;
  document.body.appendChild(cursor);
  //   console.log(cursor);
  return cursor;
}

Codestrate.on("clientUpdateProperty", ({ property, client }) => {
	let cursor = document.querySelector(`.remote-cursor[client-id="${client.id}"]`);
	if (cursor) {
		cursor.setAttribute("username", client.username);
		cursor.style.borderColor = client.color;
	}
});

function clicked(msg, clientId) {

  //const rect = document.body.getBoundingClientRect();
  //const x = msg.data.x;// + rect.left;
  //const y = msg.data.y; // + rect.top;

  const remoteCursorPostion = getRemoteCursorPostion(msg);

  const click = document.createElement("transient");
  click.classList.add("remote-click");
  click.style.left = remoteCursorPostion.x + "px";
  click.style.top = remoteCursorPostion.y + "px";
  click.style.borderColor = clients[clientId].style.borderColor;
  click.addEventListener("transitionend", function (event) {
    if (event.propertyName === "transform") {
      click.remove();
    }
  });
  document.body.appendChild(click);

  // Add animation with timeout to make it actually animate
  setTimeout(() => {
    click.classList.add("animate");
  }, 10);

  setTimeout(() => {
    click.remove();
  }, 200);
}

function getRemoteCursorPostion(msg) {
  let x = msg.data.x;
  let y = msg.data.y;
  if (msg.paraId !== null) {
    let paragraphs = document.querySelectorAll(".paragraph");
    let paragraph = null;
    for (var i = 0; i &lt; paragraphs.length; i++) {
      if (paragraphs[i].webstrate.id === msg.data.paraId) {
        paragraph = paragraphs[i];
        break;
      }
    }

    if (paragraph !== null) {
      let paraRect = paragraph.getBoundingClientRect();
      let bodyRect = document.body.getBoundingClientRect();
      x = msg.data.paraX + paraRect.left - bodyRect.left;
      y = msg.data.paraY + paraRect.top - bodyRect.top;
    }
  }

  return {
    x: x,
    y: y
  };
}

var count = 0;

function signal(msg, clientId) {
  if (clientId) document.body.webstrate.signal(msg, clientId);
  else document.body.webstrate.signal(msg);
}

const throttledSignal = throttleFn(signal, 100);

function throttleFn(fn, limit) {
  var timeout;
  var lastCall = 0;
  return function (...args) {
    var now = Date.now();
    var delay = lastCall + limit - now;
    if (delay &lt;= 0) {
      fn(...args);
      lastCall = now;
    } else {
      clearTimeout(timeout);
      timeout = setTimeout(function () {
        fn(...args);
        lastCall = now;
      }, delay);
    }
  };
}

/*
for (var i = 0; i&lt;webstrate.clients.length; i++) {
  if (webstrate.clients[i] == webstrate.clientId) continue;
  clientJoin(webstrate.clients[i]); 
}*/
webstrate.clients.forEach(clientJoin);</PRE></DIV><DIV class="paragraph style-paragraph collapsed" name="Shared Pointers Style" data-id="GfyCc8Cd" __wid="fJx3dNjt"><STYLE data-type="content" type="text/css" codemirror="true" __wid="eeL2py2j">.remote-cursor {
  position: absolute;
	
	/* Set the cursor offscreen initially. If top is not set then cursor will be appended like regular position: initial */
	top: -100px;
	
  z-index: 999;
  width: 12px;
  height: 12px;
  background-color: transparent;
  border-left: 4px solid;
  border-top: 4px solid;
  box-sizing: border-box;
	pointer-events: none;
/* 	transition: top 1ms, left 1ms;*/
/*   transform: translate3d(20px, -0px, 0); */
	transition: all 0.05s ease 0s;
	opacity: 1;
	transition: opacity 150ms ease-in;
}

.remote-cursor:after {
	content: attr(username);
	position: absolute;
	transform: translate3d(5px, 0px, 0);
	font-size: .6em;
}

.remote-cursor.hidden {
	opacity: 0;	
}

.remote-click {
  position: absolute;
  z-index: 998;
  width: 50px;
  height: 50px;
/*   background-color: orange; */
  transform: translate3d(-25px, -25px, 0) scale(0);
  transition: transform 150ms ease-in-out, opacity 150ms ease-in;
  border-radius: 50%;
  border: 4px solid orange;
  pointer-events: none;
	filter: blur(2px);
	opacity: 1.0;
}

.remote-click.animate {
/*   width: 50px;
  height: 50px; */
  transform: translate3d(-25px, -25px, 0) scale(1.0);
	opacity: 0;
}</STYLE></DIV></DIV><DIV class="section section-hidden" name="Remote Cursors" data-type="system" data-group="basic" data-id="XmZFpkT7" __wid="JceAdjqB"><DIV class="paragraph body-paragraph locked collapsed" name="Documentation" data-id="R7n9mXrD" __wid="5LCWeg7t"><DIV data-type="content" type="text/html" codemirror="true" contenteditable="false" class="section-documentation" __wid="8FCq9qNK"><H2 __wid="X7hWxPYy">Description</H2>TODO</DIV></DIV><DIV class="paragraph data-paragraph locked collapsed" name="Properties" data-id="auHPMEdC" __wid="T6vruPxf"><PRE data-type="content" type="application/json" class="section-properties" contenteditable="false" __wid="QVYKjJE6">{
	"version": "1.0",
	"dependencies": [],
	"description": "Lorem ipsum",
	"changelog":
	{
		"1.0": "Initital Release"
	}
}</PRE></DIV>

<DIV class="paragraph code-paragraph collapsed" name="Levenshtein" run-on-load="true" last-execution-state="success" draggable="false" data-id="M7kDfXK2" __wid="5kEKN6ud"><PRE data-type="content" type="text/javascript" __wid="ibGaBxBw">String.prototype.levenshtein = function(b) {
	a = this;
	if (a.length == 0) return b.length; 
	if (b.length == 0) return a.length;

	// swap to save some memory O(min(a,b)) instead of O(a) what do you think of my coding?
	if (a.length > b.length) {
		var tmp = a;
		a = b;
		b = tmp;
	}

	var row = [];
	// init the row
	for (var i = 0; i &lt;= a.length; i++){
		row[i] = i;
	}

	// fill in the rest
	for (var i = 1; i &lt;= b.length; i++){
		var prev = i;
		for (var j = 1; j &lt;= a.length; j++){
			var val;
			if (b.charAt(i-1) == a.charAt(j-1)){
				val = row[j-1]; // match
			} else {
				val = Math.min(row[j-1] + 1, // substitution
											 prev + 1,     // insertion
											 row[j] + 1);  // deletion
			}
			row[j - 1] = prev;
			prev = val;
		}
		row[a.length] = prev;
	}

	return row[a.length];
};</PRE></DIV><DIV class="paragraph code-paragraph collapsed" draggable="false" last-execution-state="success" name="Remote Cursor Utils" data-id="ZxiHZbSb" __wid="TJUnsX7U"><PRE data-type="content" type="text/javascript" id="remote-cursor-utils" __wid="stcm6HN8">// Function used to find a textnode in the children of a node that's most like the string given
const findClosestTextNode = (parent, str) => {
	// If there's only one textnode return that.
	var textNodes = [];
	for (var i = 0; i&lt;parent.childNodes.length; i++) {
		if (parent.childNodes[i].nodeType !== 3) continue;
		textNodes.push(parent.childNodes[i]);
	}
	if (textNodes.length === 1) return textNodes[0];

	// Lets see if there's one of them that's very close in length
	var closeCount = 0;
	var close;
	for (var i = 0; i&lt;textNodes.length; i++) {
		if (Math.abs(str.length -  textNodes[i].textContent.length) &lt;= 3) {
			closeCount++;
			close = textNodes[i];
		}
	}
	if (closeCount == 1) return close;

	// Else we have to find the one that's closest to the one given
	// (This is pretty slow...)
	var closest;
	var minLev = Infinity;
	for (var i = 0; i&lt;textNodes.length; i++) {
		var lev = textNodes[i].textContent.levenshtein(str);
		if (lev &lt; minLev) {
			closest = textNodes[i];
			minLev = lev;
		}
	}
	return closest;
};

const findNodeFromWID = (wid) => {
	var allElements = document.querySelectorAll("*");
	for (var i = 0; i&lt;allElements.length; i++) {
		if (allElements[i].webstrate && allElements[i].webstrate.id == wid) {
			return(allElements[i]);
		}
	}

};

const findTextNodeFromWIDandString = (wid, str) => {
	var parent = findNodeFromWID(wid);
	if (parent === null || parent === undefined) return null;
	return findClosestTextNode(parent, str);
};

exports.findClosestTextNode = findClosestTextNode;
exports.findNodeFromWID = findNodeFromWID;
exports.findTextNodeFromWIDandString = findTextNodeFromWIDandString;</PRE></DIV><DIV class="paragraph code-paragraph collapsed" draggable="false" run-on-load="true" last-execution-state="success" name="Remote Cursor" data-id="dsGvJuyb" __wid="TPpxDeDS"><PRE data-type="content" type="text/javascript" __wid="uY2K6eqf">const ClientManager = require('#client-manager');

const {
	findClosestTextNode,
	findNodeFromWID,
	findTextNodeFromWIDandString
} = require('#remote-cursor-utils');

// Get the display name from the user object, if the user is not logged in use anonymous
var displayName = webstrate.user ? webstrate.user.displayName : "Anonymous";

// Keeps track of all current cursor elements.
var clientCursors = {};

// Keeps track of the last cursor signal received from a client
var lastSignals = {};

// Keeps track of the last selection.
var lastSelection;

// Run through clients already connected and create their cursors
for (var i = 0; i&lt;webstrate.clients.length; i++) {
	addClient(webstrate.clients[i]);
}

// When a client joins create a cursor element and send your selection
webstrate.on("clientJoin", function(clientId) {
	if (clientId == webstrate.clientId) return;
	addClient(clientId);
	signalSelection(lastSelection);
});


// When a client leaves we delete its cursor
webstrate.on("clientPart", function(clientId) {
	if (clientCursors[clientId] && clientCursors[clientId].parentElement) {
		clientCursors[clientId].parentElement.removeChild(clientCursors[clientId]);    
	}
	delete clientCursors[clientId];
	delete lastSignals[clientId];
});

// When the window resizes redraw the cursors based on the last cursor signal received from the other clients.
window.addEventListener("resize", function() {
	var clients = Object.keys(lastSignals);
	for (var i = 0; i&lt;clients.length; i++) {
		drawCursor(lastSignals[clients[i]], clients[i]);
	}
});

// Timer used to send an extra signal when interaction stops
var signalTimeout;
var lastSignal;

// Compose a message based on the selection and send it off
var signalSelection = function(selection) {
	if (!selection) return;
	var msg = {
		cmd: "remote-cursor"
	};

	// We have to send the WID of the anchor, extent and focus node. We also send the text of the nodes
	// Because we need it to find the proper text node on the other side. 
	// As soon as text nodes will have WIDs we will not need to do this.
	msg.anchorNode = selection.anchorNode.nodeType == 3 ? selection.anchorNode.parentNode.webstrate.id : selection.anchorNode.webstrate.id;
	msg.extentNode = selection.extentNode.nodeType == 3 ? selection.extentNode.parentNode.webstrate.id : selection.extentNode.webstrate.id;
	msg.focusNode = selection.focusNode.nodeType == 3 ? selection.focusNode.parentNode.webstrate.id : selection.focusNode.webstrate.id;
	msg.anchorOffset = selection.anchorOffset;
	msg.extentOffset = selection.extentOffset;
	msg.focusOffset = selection.focusOffset;
	msg.anchorText = selection.anchorNode.nodeType == 3 ? selection.anchorNode.textContent : null;
	msg.extentText = selection.extentNode.nodeType == 3 ? selection.extentNode.textContent : null;
	msg.focusText = selection.focusNode.nodeType == 3 ? selection.focusNode.textContent : null;
	msg.type = "selectionchanged";
	msg.anchorNodeType = selection.anchorNode.nodeType;
	msg.extentNodeType = selection.extentNode.nodeType;
	msg.focusNodeType = selection.focusNode.nodeType;
	msg.displayName = displayName;
	document.body.webstrate.signal(msg);
	// To make sure that the signal to move the cursor doesn't arrive before the edit done to the text,
	// We send an extra signal after waiting 50ms
	lastSignal = msg;

	if (signalTimeout) clearTimeout(signalTimeout);
	signalTimeout = setTimeout(function() {
		document.body.webstrate.signal(lastSignal);
	}, 50);
};

// When selection change, get it and send it
document.addEventListener("selectionchange", function(event) {
	lastSelection = getSelection();

	// only signal body paragraphs
	let anchorNode = lastSelection.anchorNode;
	if (
		anchorNode &&
		anchorNode.parentElement.closest('.paragraph.body-paragraph') &&
		anchorNode.parentElement.closest('[data-type="content"][contenteditable="true"]')
	) {
		signalSelection(lastSelection);	
	}
});


// Handles when we receive a signal
document.body.webstrate.on("signal", function(msg, clientId) {
	// If the client doesn't have a cursor return.
	if (msg.cmd !== "remote-cursor" || !clientCursors[clientId]) return;
	lastSignals[clientId] = msg;
	drawCursor(msg, clientId);
});

function drawCursor(msg, clientId) {
	// Now we have to find the anchor and focus from the WIDs in the signal
	// As textNodes currently have no WIDs we have to do some ugly stuff that I've parked in the levenshtein script
	var anchor, focus;
	if (msg.anchorNodeType === 3) {
		anchor = findTextNodeFromWIDandString(msg.anchorNode, msg.anchorText);
	} else {
		anchor = findNodeFromWID(msg.anchorNode);
	}
	if (msg.focusNodeType === 3) {
		focus = findTextNodeFromWIDandString(msg.focusNode, msg.focusText);
	} else {
		focus = findNodeFromWID(msg.focusNode, msg.focusText);
	}
	if (!anchor || !focus) return; // No nodes !

	// We check the order of the anchor and focus (to see if it is a backwards selection)
	try {
		var preceding = (anchor.compareDocumentPosition(focus) == 4) || (anchor.compareDocumentPosition(focus) == 0 && msg.focusOffset > msg.anchorOffset);
	} catch (err) {
		return;  
	}

	// If its a backwards selection we switch. This can throw an exception if anchor and focus are the same.
	var range = document.createRange();
	try {
		if (preceding) {
			range.setStart(anchor, msg.anchorOffset);
			range.setEnd(focus, msg.focusOffset);
		} else {
			range.setStart(focus, msg.focusOffset);
			range.setEnd(anchor, msg.anchorOffset);          
		}
	} catch (err) {
		return;  
	}
	// If the cursor is already somewhere in the document we detach it from its parent
	if (clientCursors[clientId].parentElement) clientCursors[clientId].parentElement.removeChild(clientCursors[clientId]);
	// Get the rects from the newly created range
	var allRects = range.getClientRects();
	// Prune out rects from elements with display block (fills the whole width of the screen)
	var rects = [];
	for (var i = 0; i&lt;allRects.length; i++) {
		if (allRects[i].width !== window.innerWidth) rects.push(allRects[i]);        	
	}

	// If there's no rects in the range we create one that can be used for the cursor.
	// We use the left side of the anchor node to do this.
	if (rects.length === 0) {
		if (!anchor.getBoundingClientRect) return; // The anchor is a text node, we shouldn't be here. Perhaps the content has display: none.
		var anchorBounds = anchor.getBoundingClientRect();
		anchorBounds = {left: anchorBounds.left, right: anchorBounds.left, top: anchorBounds.top, bottom: anchorBounds.bottom, height: anchorBounds.height, width: 0};
		rects.push(anchorBounds);
	}
	// Now we insert the cursor just before the anchornode
	anchor.parentElement.insertBefore(clientCursors[clientId], anchor);
	var cursorBounds = clientCursors[clientId].getBoundingClientRect();
	var rectsDiv = clientCursors[clientId].querySelector(".rects");
	// We clear the rects of the cursor
	rectsDiv.innerHTML = "";
	// Generate a div for each of the rects in the range
	for (var i = 0; i&lt;rects.length; i++) {
		var rect = document.createElement("div");
		rect.style.position = "absolute";
		rect.style.left = rects[i].left - cursorBounds.left + "px";
		rect.style.top = rects[i].top - cursorBounds.top + "px";
		rect.style.width = rects[i].width + "px";
		rect.style.height = rects[i].height + "px";
		rect.setAttribute("class", "rect");
		rect.style.backgroundColor = ClientManager.getClientColor(clientId);
		rect.style.borderColor = ClientManager.getClientColor(clientId);
		rectsDiv.appendChild(rect);
	}
	// At the end we place "the cursor" that is a vertical bar that also includes the display name
	var endRect = rects[rects.length-1];
	var cursorEnd = clientCursors[clientId].querySelector(".end");
	var displayName = clientCursors[clientId].querySelector(".displayName");
	displayName.innerText = msg.displayName;
	cursorEnd.style.position = "absolute";
	cursorEnd.style.left = endRect.right - cursorBounds.right + "px";
	cursorEnd.style.top = endRect.top - cursorBounds.top + "px";
	cursorEnd.style.height = endRect.height + "px";
	cursorEnd.setAttribute("class", "end");
	cursorEnd.style.backgroundColor = ClientManager.getClientColor(clientId);
	cursorEnd.style.borderColor = ClientManager.getClientColor(clientId);

}

function addClient(clientId) {

	// If the client is this one, return.
	if (clientId == webstrate.clientId) return; 

	// Get user's color
	var color = ClientManager.getClientColor(clientId);

	// Create the main cursor element
	var cursor = document.createElement("transient");

	// Create the end of the cursor (what's shown if nothing is selected
	var cursorEnd = document.createElement("div");

	// Create the element for the display name
	var displayName = document.createElement("div");
	displayName.setAttribute("class", "displayName");
	displayName.style.backgroundColor = color;
	cursorEnd.appendChild(displayName);
	cursorEnd.setAttribute("class", "end");
	cursor.setAttribute("class", "cursor");
	cursor.style.backgroundColor = color;
	cursor.setAttribute("data-clientid", clientId);
	cursor.setAttribute("contenteditable", "false");
	
	// Create the element containing the rects for selection
	var rects = document.createElement("div");
	rects.setAttribute("class", "rects");
	cursor.appendChild(rects);
	cursor.appendChild(cursorEnd);
	clientCursors[clientId] = cursor;
	
	// When we mouse over the cursor we want the display name to show (and then hide after a while
	// through CSS)
	cursor.addEventListener("mouseover", function() {
		// Easiest way to retrigger an animation is to clone and replace the node
		var clone = displayName.cloneNode(true);
		displayName.parentNode.replaceChild(clone, displayName);
		displayName = clone;
	});
	
	Codestrate.on("clientUpdateProperty", ({ client, propertyName }) => {
		if (propertyName === "color") {
			displayName.style.backgroundColor = client.color;
		}
	});
}</PRE></DIV></DIV><DIV name="CodeMirror" class="section section-hidden" data-type="system" data-group="editing" data-id="w3Chj5iH" __wid="wV2DBJLF"><DIV class="paragraph body-paragraph locked" draggable="false" name="Documentation" data-id="WFLXUc55" __wid="Q6aWgQdN"><DIV data-type="content" contenteditable="false" class="section-documentation hide-variable-names" __wid="HRfc5Xs9"><H2 __wid="44hydTFJ">Description</H2><DIV __wid="u8rnEw2u">CodeMirror integration, touching the code below should be done with <I __wid="3VvN95Wa">serious </I>care :-D</DIV><DIV __wid="AAQr83tV"><BR __wid="zRMjtPGM"/></DIV><DIV __wid="ugVCPxyY">Using CodeMirror versionÂ <DIV class="variable" contenteditable="false" data-name="version" __wid="xLzzXZKY"></DIV><SPAN style="font-size: 11pt;" __wid="Jjpm4kTE">.</SPAN></DIV><H2 __wid="sxcsg9CJ">Modes</H2><DIV __wid="7ipcMK3J"><SPAN style="font-size: 11pt;" __wid="NvTgLPyc"><DIV class="variable" contenteditable="false" data-name="modes" __wid="5L8uQPTy"></DIV></SPAN></DIV></DIV></DIV><DIV class="paragraph data-paragraph collapsed" name="Properties" data-id="Ldb88iyx" __wid="vKXvw8ZY"><PRE data-type="content" type="application/json" class="section-properties" contenteditable="true" __wid="ZVsRg3qh">{
	"version": "1.0",
	"description": "Lorem ipsum",
	"changelog":
	{
		"1.0": "Initital Release"
	}
}</PRE></DIV>

<DIV class="paragraph code-paragraph collapsed" draggable="false" name="Base Editor" data-id="CvXXTasc" __wid="G8JEzWaS"><PRE data-type="content" type="text/javascript" id="base-editor" class="editors" __wid="H5djMTrh">const ClientManager = require('#client-manager');

/**
 * Base class for editors.
 */
class Editor {

  constructor(target, editorOptions) {
    this.target = target;

    const contenteditable = target.getAttribute("contenteditable");
    let readOnly = contenteditable && contenteditable === "false" ? true : false;

    // Allow custom editor options.
    this.editorOptions = Object.assign({
      autoCloseBrackets: true,
      autoCloseTags: true,
      matchBrackets: true,
      matchTags: true,
      styleActiveLine: true,
      /*highlightSelectionMatches: {
      	showToken: /\w/
      },*/
      theme: "monokai",
      indentUnit: 2,
      tabSize: 2,
      indentWithTabs: true,
      lineWrapping: true,
      lineNumbers: true,
      extraKeys: {},
      readOnly: readOnly,
      foldGutter: true,
      gutters: ["CodeMirror-lint-markers", "CodeMirror-linenumbers", "CodeMirror-foldgutter"],
      lint: {
        esversion: 6
      }
    }, editorOptions);

    target.liveAttribute("contenteditable").changed(value => {
      let readOnly = value && value === "false" ? true : false;
      //         window.console.log(value, this.editor);
      this.readOnly = readOnly;
    });

    target.liveAttribute("type").changed(mode => {
      // live attribute is also triggered for inital value when editor has
      // not been instantiated
      if (mode && this.editor) {
        this.editor.setOption("mode", mode);
      }
    });

    // wait to set mode on codestrateloaded because additional CodeMirror modes
    // can be loaded after CodeMirror integration
    const updateModeOnLoaded = () => {
      let mode = target.getAttribute("type");
      this.editor.setOption("mode", mode);
      window.removeEventListener("codestrateloaded", updateModeOnLoaded);
    };
    window.addEventListener("codestrateloaded", updateModeOnLoaded);

    // this is a hack because the this.editor is available after subclass initialized the CodeMirror
    // editor
    setTimeout(() => {
      let keyMap = this.buildKeyMap();

      // normalize key map
      let normalizedKeyMap = CodeMirror.normalizeKeyMap(keyMap);

      // A convenient shortcut to format content
      this.editor.addKeyMap(normalizedKeyMap);
    }, 0);

    // add cursor activity only if target is not in a transient subtree
    if (!target.closest('transient')) {

      // this is a hack because the this.editor is available after subclass initialized the CodeMirror
      // editor
      setTimeout(() => {
        // shared cursors / markers
        this.editor.on("cursorActivity", () => {
          var range = this.editor.doc.sel.ranges[0];
          target.webstrate.signal(range);
        });

        const markers = {};
        target.webstrate.on("signal", (sel, clientId) => {
          if (clientId === webstrate.clientId) return;

          if (markers[clientId]) markers[clientId].clear();

          const color = ClientManager.getClientColor(clientId);
          const backgroundColor = ClientManager.getClientColorInRGBA(clientId, 0.3);

          if (sel.anchor.line > sel.head.line || (sel.anchor.line == sel.head.line && sel.anchor.ch > sel.head.ch)) { // Backwards selection
            let temp = sel.anchor;
            sel.anchor = sel.head;
            sel.head = temp;
          }
          if (sel.anchor.line == sel.head.line && sel.anchor.ch == sel.head.ch) {
            var widget = document.createElement("span");
            widget.classList.add("remoteCursor");
            widget.setAttribute("style", `outline: 1px solid ${color}`);
            markers[clientId] = this.editor.doc.setBookmark(sel.anchor, {
              widget: widget
            });
          } else {
            markers[clientId] = this.editor.doc.markText(sel.anchor, sel.head, {
              className: "remoteSelection",
              css: `background-color: ${backgroundColor};`
            });
          }
        });

        webstrate.on("clientPart", (clientId) => {
          if (!markers[clientId]) return;
          markers[clientId].clear();
          delete markers[clientId];
        });
      }, 0);
    }
  }

  /**
   * Returns formatted content.
   *
   * @param {string} content Content to format.
   *
   * @return {string} Formatted content.
   */
  formatContent(content) {
    return content;
  }

  buildKeyMap() {

    let keyMap = {
			// code formatting within paragraph that has focus
      "Shift-Alt-F": (cm) => {
        let content = cm.getValue();
        content = this.formatContent(content);
        cm.setValue(content);
        return true;
      }
    };

    if (Codestrate.OS.isMac()) {
      keyMap = Object.assign({}, keyMap, {
        // avoid browser save website dialog
        "Cmd-S": (cm) => {
          return true;
        }
      });
    } else {
      keyMap = Object.assign({}, keyMap, {
				// avoid browser save website dialog
        "Ctrl-S": (cm) => {
          return true;
        }
      });
    }

    return keyMap;
  }

  set readOnly(readOnly) {
    if (this.editor) {
      this.editor.setOption("readOnly", readOnly);
    }
  }

  get readOnly() {
    if (this.editor) {
      return this.editor.getOption("readOnly");
    }
    throw new Error("editor not initialized");
  }
}

exports.Editor = Editor;</PRE></DIV><DIV class="paragraph code-paragraph collapsed" draggable="false" name="Code Editor" data-id="Gy9JEzBe" __wid="knYXqbjB"><PRE data-type="content" type="text/javascript" id="code-editor" class="editors" __wid="EKYPRXdX">const {
  Editor
} = require('#base-editor');

/**
 * Code editor
 */
class CodeEditor extends Editor {

  constructor(target, parent, editorOptions) {

    super(target, editorOptions);

    // window.console.log('default editor');

    this.suppress = false;
    this.timer = null;

    if (parent === undefined) parent = target;

    this.textNode = target.firstChild;

    //       window.console.log(this.textNode, target);

    if (!this.textNode || this.textNode.nodeType !== 3) {
      console.error("First child node of target is not a text node", target);
      throw Error("First child node of target is not a text node");
    }
    const transient = document.createElement("transient");
    transient.setAttribute("class", "default-editor");

    const textArea = document.createElement("textarea");
    transient.appendChild(textArea);

    // Insert code editor before console
    if (parent.console && parent.console.container) {
      const consoleContainer = parent.console.container;
      parent.insertBefore(transient, consoleContainer);
    } else {
      parent.appendChild(transient);
    }

    this.editor = CodeMirror.fromTextArea(textArea, this.editorOptions);

    this.editor.setValue(this.textNode.textContent);
    setTimeout(() => {
      this.editor.refresh();
    }, 0);

    // add text events only if target (and text node) is not in a transient subtree
    if (!target.closest('transient')) {

      const insertTextCallback = (pos, val) => {
        this.editor.off("change", editorChangeCallback);
        this.editor.replaceRange(val, this.editor.posFromIndex(pos));
        this.editor.on("change", editorChangeCallback);
      };

      const deleteTextCallback = (pos, val) => {
        var from = this.editor.posFromIndex(pos);
        var to = this.editor.posFromIndex(pos + val.length);
        this.editor.off("change", editorChangeCallback);
        this.editor.replaceRange('', from, to);
        this.editor.on("change", editorChangeCallback);
      };

      this.textNode.webstrate.on("insertText", insertTextCallback);
      this.textNode.webstrate.on("deleteText", deleteTextCallback);
    }

    const editorChangeCallback = () => {
      var newVal = this.editor.getValue();
      newVal = newVal.length === 0 ? ' ' : newVal;
      this.textNode.textContent = newVal;
    };

    this.editor.on("change", editorChangeCallback);

    // Update the editor on paste. This fixes a bug that occurs sometimes
    // When pasting large portions of code into the editor.
    this.editor.on("paste", () => {
      setTimeout(() => {
        this.editor.refresh();
      }, 0);
    });
  }

  /**
   * Returns formatted content.
   *
   * @param {string} content Content to format.
   *
   * @return {string} Formatted content.
   */
  formatContent(content) {
    const type = this.editorOptions.mode;

    const beautifyOptions = {
      indent_size: 2,
      indent_char: " ",
      indent_with_tabs: false,
      eol: "\n",
      end_with_newline: false,
      indent_level: 0,
      preserve_newlines: true,
      max_preserve_newlines: 5,
      space_in_paren: false,
      space_in_empty_paren: false,
      jslint_happy: true,
      space_after_anon_function: false,
      brace_style: "collapse",
      break_chained_methods: false,
      keep_array_indentation: false,
      unescape_strings: false,
      wrap_line_length: 0,
      e4x: false,
      comma_first: false,
      operator_position: "before-newline"
    };

    switch (type) {
    case "text/javascript":
      return js_beautify(content, beautifyOptions);
    case "text/css":
      return css_beautify(content, beautifyOptions);
    default:
      console.log(`no beautifier for ${type} installed`);
      break;
    }
    return content;
  }
}
exports.CodeEditor = CodeEditor;</PRE></DIV><DIV class="paragraph code-paragraph collapsed" draggable="false" name="HTML Editor" data-id="5HXrC3wK" __wid="ntNfnx4u"><PRE data-type="content" type="text/javascript" id="html-editor" class="editors" __wid="J4KTu9AY">const {
  Editor
} = require('#base-editor');

/**
 * HTML editor synchronizing content between contenteditable element and
 * a CodeMirror instance.
 */
class HTMLEditor extends Editor {

  constructor(target, editorOptions) {

    super(target, Object.assign({
      mode: "htmlmixed"
    }, editorOptions));

    //window.console.log('html editor');

    const parent = target.parentElement;

    const transient = document.createElement("transient");
    transient.setAttribute("class", "html-editor hidden");

    const textArea = document.createElement("textarea");
    transient.appendChild(textArea);

    // Insert code editor before console
    if (parent.console && parent.console.container) {
      const consoleContainer = parent.console.container;
      parent.insertBefore(transient, consoleContainer);
    } else {
      parent.appendChild(transient);
    }

    this.editor = CodeMirror.fromTextArea(textArea, this.editorOptions);

    const updateEditor = () => {
      let html = target.innerHTML;
      this.editor.setValue(html);
      setTimeout(() => {
        this.editor.refresh();
      }, 0);
    };

    let observer;
    const enableMutationObserver = () => {

      // Only allow one observer
      if (observer) return;

      // Listen to any updates that happen inside of the target element and update
      // the CodeMirror instance accordingly. For now, any update will override 
      // contents of the CodeMirror and transient changes get lost.
      observer = new MutationObserver(mutations => {
        updateEditor();
      });
      observer.observe(target, {
        childList: true,
        characterData: true,
        subtree: true,
        attributes: true
      });
    };

    const disableMutationObserver = () => {
      if (observer) {
        observer.disconnect();
        observer = null;
      }
    };

    // Update the editor on paste. This fixes a bug that occurs sometimes
    // When pasting large portions of code into the editor.
    this.editor.on("paste", () => {
      setTimeout(() => {
        this.editor.refresh();
      }, 0);
    });

    // Add actions to save html and to toggle html to paragraph header. This
    // code might move at some point to the actual active essay code.
    const ParagraphUtils = require('#paragraph-utils');

    ParagraphUtils.addHeaderAction(parent, "save-html", () => {
      this.saveHtml();
    }, {
      tooltip: true
    });

    ParagraphUtils.addHeaderAction(parent, "toggle-html", () => {
      transient.classList.toggle("hidden");

      // Disable and enable mutation observer
      if (transient.classList.contains("hidden")) {
        disableMutationObserver();
      } else {
        enableMutationObserver();
        updateEditor();
      }
    }, {
      tooltip: true
    });
  }

  /**
   * Returns formatted content.
   *
   * @param {string} content Content to format.
   *
   * @return {string} Formatted content.
   */
  formatContent(content) {
    return html_beautify(content, {
      indent_size: 2,
      indent_char: " ",
      indent_with_tabs: false,
      eol: "\n",
      end_with_newline: false,
      indent_level: 0,
      preserve_newlines: true,
      max_preserve_newlines: 5,
      space_in_paren: false,
      space_in_empty_paren: false,
      jslint_happy: false,
      space_after_anon_function: false,
      brace_style: "collapse",
      break_chained_methods: false,
      keep_array_indentation: false,
      unescape_strings: false,
      wrap_line_length: 0,
      e4x: false,
      comma_first: false,
      operator_position: "before-newline"
    });
  }

  buildKeyMap() {
    let keyMap = super.buildKeyMap();
		
		if (Codestrate.OS.isMac()) {
			keyMap = Object.assign({}, keyMap, {
				// A convenient save option to save html instead of showing the open
				// file dialog.
				"Cmd-S": (cm) => {
					this.saveHtml();
				}				
			});
		}
		else {
			keyMap = Object.assign({}, keyMap, {
				// A convenient save option to save html instead of showing the open
				// file dialog.
				"Ctrl-S": (cm) => {
					this.saveHtml();
				}
			});
		}

    return keyMap;
  }


  // Save html and persist it with Webstrates.
  saveHtml() {
    const cursor = this.editor.getCursor();

    let html = this.editor.getValue();
    this.target.innerHTML = html;

    setTimeout(() => {
      this.editor.setCursor(cursor);
    }, 0);
  }
}

exports.HTMLEditor = HTMLEditor;</PRE></DIV><DIV class="paragraph code-paragraph collapsed" name="CodeMirror integration code" run-on-load="true" last-execution-state="success" style draggable="false" data-id="yvE9WeT6" __wid="TjdJntJD"><PRE data-type="content" type="text/javascript" __wid="9WRcRLKJ">// Import CodeMirror basics style.
importStyle([
	"codemirror.css",

	"codemirror-addon-simplescrollbars.css",
	"codemirror-addon-dialog.css", // remove when using custom dialog implementation
	"codemirror-addon-show-hint.css",
	"codemirror-addon-foldgutter.css",
	"codemirror-addon-matchesonscrollbar.css",
	"codemirror-addon-lint.css"
]);

importLib([
	"codemirror.js",

	//"codemirror-addon-dialog.js", // use custom dialog implementation

	"codemirror-addon-annotatescrollbar.js",
	"codemirror-addon-simplescrollbars.js",
	"codemirror-addon-scrollpastend.js",

	"codemirror-addon-show-hint.js",
	"codemirror-addon-javascript-hint.js",
	"codemirror-addon-xml-hint.js",
	"codemirror-addon-html-hint.js",
	"codemirror-addon-css-hint.js",
	"codemirror-addon-anyword-hint.js",

	"codemirror-addon-comment.js",
	"codemirror-addon-continuecomment.js",

	"codemirror-addon-foldcode.js",
	"codemirror-addon-foldgutter.js",
	"codemirror-addon-brace-fold.js",
	"codemirror-addon-xml-fold.js",
	"codemirror-addon-markdown-fold.js",
	"codemirror-addon-comment-fold.js",
	"codemirror-addon-indent-fold.js",

	"codemirror-addon-matchbrackets.js",
	"codemirror-addon-matchtags.js",
	"codemirror-addon-closebrackets.js",
	"codemirror-addon-closetag.js",

	"codemirror-addon-searchcursor.js",
	"codemirror-addon-match-highlighter.js",
	"codemirror-addon-matchesonscrollbar.js",
	"codemirror-addon-jump-to-line.js",
	"codemirror-addon-search.js",
	"codemirror-addon-active-line.js",
	
	"codemirror-linter-jshint.js",
	"codemirror-linter-htmlhint.js",
	"codemirror-linter-csslint.js",
	"codemirror-linter-jsonlint.js",
	
	//"codemirror-addon-lint.js", // Use transient version instead
	"codemirror-addon-javascript-lint.js",
	"codemirror-addon-html-lint.js",
	"codemirror-addon-css-lint.js",
	"codemirror-addon-json-lint.js",

	"codemirror-mode-xml.js",
	"codemirror-mode-htmlmixed.js",
	"codemirror-mode-javascript.js",
	"codemirror-mode-css.js",
	"codemirror-mode-go.js",

	"beautify.js",
	"beautify-css.js",
	"beautify-html.js"
]).then(() => {
	
	// customized linter that uses transient overlays when hovering over a linter error or linter info
	require("#codemirror-addon-lint-transient"); // Use transient version

	// Print CodeMirror version.
	Variable("version").set(`&lt;transient>${CodeMirror.version}&lt;/transient>`);

	// Print installed CodeMirror modes.
	let modes = Object.keys(CodeMirror.modes).filter((m) => m !== "null");
	modes = modes.map(m => { return `&lt;li>${m}&lt;/li>`; }).join('\r\n');
	Variable("modes").set(`&lt;transient>&lt;ul>${modes}&lt;/ul>&lt;/transient>`);

	const { CodeEditor } = require('#code-editor');
	const { HTMLEditor } = require('#html-editor');

	const extraKeys = {
		"Ctrl-Space": "autocomplete",
		"Cmd-/": "toggleComment"
	};

	//////////
	// magic
	//////////

	const sectionSelector = '.section';
	const sectionHiddenClass = "section-hidden";

	const codeSelectors = [
		'pre[type]',
		'*[codemirror="true"]'
	];

	const createEditor = function (element) {

		// 		debugger;

		//     window.console.log("create editor for element %o", element);

		if (!element.__editor) {
			const codeType = element.getAttribute("type");

			let editor;
			if ((!codeType || codeType === "text/html") && element.hasAttribute("contenteditable")) {
				editor = new HTMLEditor(element, { extraKeys });
			}
			else {
				editor = new CodeEditor(element, element.parentElement, {
					mode: codeType,
					extraKeys
				});
			}

			element.__editor = editor;
		}
	};

	const hasCodeType = (node) => {
		return node.matches(codeSelectors.join(","));
	};

	const isSectionVisible = (node) => {
		// Only create editor if section is visible
		const section = node.closest(sectionSelector);
		// 		console.log('isSectionVisible', section, section.classList.contains(sectionHiddenClass));
		return section && !section.classList.contains(sectionHiddenClass);
	};

	const isCodeEditor = (node) => {
		return hasCodeType(node) && node.__editor;
	};

	const destroyEditor = (node) => {
		node.__editor.editor.toTextArea();
	};

	const magic = (node) => {
		// Continue if section is not visible
		if (!isSectionVisible(node)) return;

		if (!isCodeEditor(node) && hasCodeType(node)) {
			createEditor(node);
		}
		else {
			const subNodes = node.querySelectorAll(codeSelectors.join(","));
			Array.prototype.forEach.call(subNodes, (subNode) => {

				// Continue if section is not visible
				if (!isSectionVisible(subNode)) return;

				// ignore sub nodes if any of the ancestor nodes have a class template
				if (subNode.closest('.template')) return;

				if (!isCodeEditor(subNode) && hasCodeType(subNode)) {
					createEditor(subNode);
				}
			});
		}
	};

	document.liveQuerySelectorAll(codeSelectors.join(",")).added(code => {
		// 		console.log('code', code);
		magic(code);
	});

	document.liveQuerySelectorAll(sectionSelector).added(section => {
		// 		console.log('section', section);

		section.liveAttribute("class").changed(() => {
			// 			console.log('section hidden? ', section.classList.contains(sectionHiddenClass));

			if (!section.classList.contains(sectionHiddenClass)) {
				magic(section);
			}
		});
	});
});</PRE></DIV><DIV class="paragraph code-paragraph collapsed" draggable="false" name="CodeMirror OpenDialog" run-on-load="true" last-execution-state="success" data-id="Ki28VD7x" __wid="6M82MBsw"><PRE data-type="content" type="text/javascript" __wid="mrsQjaph">// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

// Open simple dialogs on top of an editor. Relies on dialog.css.

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
  function dialogDiv(cm, template, bottom) {
    var wrap = cm.getWrapperElement();
    var dialog;
    dialog = wrap.appendChild(document.createElement("div"));
    if (bottom)
      dialog.className = "CodeMirror-dialog CodeMirror-dialog-bottom";
    else
      dialog.className = "CodeMirror-dialog CodeMirror-dialog-top";

    if (typeof template == "string") {
      dialog.innerHTML = template;
    } else { // Assuming it's a detached DOM element.
      dialog.appendChild(template);
    }
    return dialog;
  }

  function closeNotification(cm, newVal) {
    if (cm.state.currentNotificationClose)
      cm.state.currentNotificationClose();
    cm.state.currentNotificationClose = newVal;
  }

  CodeMirror.defineExtension("openDialog", function(template, callback, options) {
    if (!options) options = {};

    closeNotification(this, null);

    var dialog = dialogDiv(this, template, options.bottom);
    var closed = false, me = this;
    function close(newVal) {
      if (typeof newVal == 'string') {
        inp.value = newVal;
      } else {
        if (closed) return;
        closed = true;
        dialog.parentNode.removeChild(dialog);
        me.focus();

        if (options.onClose) options.onClose(dialog);
      }
    }

    var inp = dialog.getElementsByTagName("input")[0], button;
    if (inp) {
      inp.focus();

      if (options.value) {
        inp.value = options.value;
        if (options.selectValueOnOpen !== false) {
          inp.select();
        }
      }

      if (options.onInput)
        CodeMirror.on(inp, "input", function(e) { options.onInput(e, inp.value, close);});
      if (options.onKeyUp)
        CodeMirror.on(inp, "keyup", function(e) {options.onKeyUp(e, inp.value, close);});

      CodeMirror.on(inp, "keydown", function(e) {
        if (options && options.onKeyDown && options.onKeyDown(e, inp.value, close)) { return; }
        if (e.keyCode == 27 || (options.closeOnEnter !== false && e.keyCode == 13)) {
          inp.blur();
          CodeMirror.e_stop(e);
          close();
        }
        if (e.keyCode == 13) callback(inp.value, e);
      });

      if (options.closeOnBlur !== false) CodeMirror.on(inp, "blur", close);
    } else if (button = dialog.getElementsByTagName("button")[0]) {
      CodeMirror.on(button, "click", function() {
        close();
        me.focus();
      });

      if (options.closeOnBlur !== false) CodeMirror.on(button, "blur", close);

      button.focus();
    }
    return close;
  });

  CodeMirror.defineExtension("openConfirm", function(template, callbacks, options) {
    closeNotification(this, null);
    var dialog = dialogDiv(this, template, options && options.bottom);
    var buttons = dialog.getElementsByTagName("button");
    var closed = false, me = this, blurring = 1;
    function close() {
      if (closed) return;
      closed = true;
      dialog.parentNode.removeChild(dialog);
      me.focus();
    }
    buttons[0].focus();
    for (var i = 0; i &lt; buttons.length; ++i) {
      var b = buttons[i];
      (function(callback) {
        CodeMirror.on(b, "click", function(e) {
          CodeMirror.e_preventDefault(e);
          close();
          if (callback) callback(me);
        });
      })(callbacks[i]);
      CodeMirror.on(b, "blur", function() {
        --blurring;
        setTimeout(function() { if (blurring &lt;= 0) close(); }, 200);
      });
      CodeMirror.on(b, "focus", function() { ++blurring; });
    }
  });

  /*
   * openNotification
   * Opens a notification, that can be closed with an optional timer
   * (default 5000ms timer) and always closes on click.
   *
   * If a notification is opened while another is opened, it will close the
   * currently opened one and open the new one immediately.
   */
  CodeMirror.defineExtension("openNotification", function(template, options) {
    closeNotification(this, close);
    var dialog = dialogDiv(this, template, options && options.bottom);
    var closed = false, doneTimer;
    var duration = options && typeof options.duration !== "undefined" ? options.duration : 5000;

    function close() {
      if (closed) return;
      closed = true;
      clearTimeout(doneTimer);
      dialog.parentNode.removeChild(dialog);
    }

    CodeMirror.on(dialog, 'click', function(e) {
      CodeMirror.e_preventDefault(e);
      close();
    });

    if (duration)
      doneTimer = setTimeout(close, duration);

    return close;
  });
});</PRE></DIV><DIV class="paragraph code-paragraph collapsed" name="Editor Utils" data-id="Sc5xz6BJ" __wid="aRsAPnjx"><PRE data-type="content" type="text/javascript" id="editor-utils" __wid="vVTu7F23">exports.editorDragDrop = (bool) => {
	const contents = document.querySelectorAll('[data-type="content"]');
	Array.prototype.forEach.call(contents, (content) => {
		if (content.__editor) {
			content.__editor.editor.setOption('dragDrop', bool);
		}
	});
};</PRE></DIV><DIV class="paragraph code-paragraph collapsed" name="Codemirror Addon Lint Transient" data-id="tLZkwit3" __wid="GqEKUjNG"><PRE data-type="content" type="text/javascript" id="codemirror-addon-lint-transient" __wid="KBqsUiK6">// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
  "use strict";
  var GUTTER_ID = "CodeMirror-lint-markers";

  function showTooltip(e, content) {
    var tt = document.createElement("div");
    tt.className = "CodeMirror-lint-tooltip";
    tt.appendChild(content.cloneNode(true));		
    //document.body.appendChild(tt);
		var transient = document.createElement("transient");
		transient.appendChild(tt);
		document.body.appendChild(transient);

    function position(e) {
      if (!tt.parentNode) return CodeMirror.off(document, "mousemove", position);
      tt.style.top = Math.max(0, e.clientY - tt.offsetHeight - 5) + "px";
      tt.style.left = (e.clientX + 5) + "px";
    }
    CodeMirror.on(document, "mousemove", position);
    position(e);
    if (tt.style.opacity != null) tt.style.opacity = 1;
    return tt;
  }
  function rm(elt) {
    //if (elt.parentNode) elt.parentNode.removeChild(elt);
		var pelt = elt.parentNode;
		if (pelt) {
			if (pelt.parentNode) pelt.parentNode.removeChild(pelt);
		}
  }
  function hideTooltip(tt) {
    if (!tt.parentNode) return;
    if (tt.style.opacity == null) rm(tt);
    tt.style.opacity = 0;
    setTimeout(function() { rm(tt); }, 600);
  }

  function showTooltipFor(e, content, node) {
    var tooltip = showTooltip(e, content);
    function hide() {
      CodeMirror.off(node, "mouseout", hide);
      if (tooltip) { hideTooltip(tooltip); tooltip = null; }
    }
    var poll = setInterval(function() {
      if (tooltip) for (var n = node;; n = n.parentNode) {
        if (n && n.nodeType == 11) n = n.host;
        if (n == document.body) return;
        if (!n) { hide(); break; }
      }
      if (!tooltip) return clearInterval(poll);
    }, 400);
    CodeMirror.on(node, "mouseout", hide);
  }

  function LintState(cm, options, hasGutter) {
    this.marked = [];
    this.options = options;
    this.timeout = null;
    this.hasGutter = hasGutter;
    this.onMouseOver = function(e) { onMouseOver(cm, e); };
    this.waitingFor = 0
  }

  function parseOptions(_cm, options) {
    if (options instanceof Function) return {getAnnotations: options};
    if (!options || options === true) options = {};
    return options;
  }

  function clearMarks(cm) {
    var state = cm.state.lint;
    if (state.hasGutter) cm.clearGutter(GUTTER_ID);
    for (var i = 0; i &lt; state.marked.length; ++i)
      state.marked[i].clear();
    state.marked.length = 0;
  }

  function makeMarker(labels, severity, multiple, tooltips) {
    var marker = document.createElement("div"), inner = marker;
    marker.className = "CodeMirror-lint-marker-" + severity;
    if (multiple) {
      inner = marker.appendChild(document.createElement("div"));
      inner.className = "CodeMirror-lint-marker-multiple";
    }

    if (tooltips != false) CodeMirror.on(inner, "mouseover", function(e) {
      showTooltipFor(e, labels, inner);
    });

    return marker;
  }

  function getMaxSeverity(a, b) {
    if (a == "error") return a;
    else return b;
  }

  function groupByLine(annotations) {
    var lines = [];
    for (var i = 0; i &lt; annotations.length; ++i) {
      var ann = annotations[i], line = ann.from.line;
      (lines[line] || (lines[line] = [])).push(ann);
    }
    return lines;
  }

  function annotationTooltip(ann) {
    var severity = ann.severity;
    if (!severity) severity = "error";
    var tip = document.createElement("div");
    tip.className = "CodeMirror-lint-message-" + severity;
    if (typeof ann.messageHTML != 'undefined') {
        tip.innerHTML = ann.messageHTML;
    } else {
        tip.appendChild(document.createTextNode(ann.message));
    }
    return tip;
  }

  function lintAsync(cm, getAnnotations, passOptions) {
    var state = cm.state.lint
    var id = ++state.waitingFor
    function abort() {
      id = -1
      cm.off("change", abort)
    }
    cm.on("change", abort)
    getAnnotations(cm.getValue(), function(annotations, arg2) {
      cm.off("change", abort)
      if (state.waitingFor != id) return
      if (arg2 && annotations instanceof CodeMirror) annotations = arg2
      updateLinting(cm, annotations)
    }, passOptions, cm);
  }

  function startLinting(cm) {
    var state = cm.state.lint, options = state.options;
    /*
     * Passing rules in `options` property prevents JSHint (and other linters) from complaining
     * about unrecognized rules like `onUpdateLinting`, `delay`, `lintOnChange`, etc.
     */
    var passOptions = options.options || options;
    var getAnnotations = options.getAnnotations || cm.getHelper(CodeMirror.Pos(0, 0), "lint");
    if (!getAnnotations) return;
    if (options.async || getAnnotations.async) {
      lintAsync(cm, getAnnotations, passOptions)
    } else {
      var annotations = getAnnotations(cm.getValue(), passOptions, cm);
      if (!annotations) return;
      if (annotations.then) annotations.then(function(issues) {
        updateLinting(cm, issues);
      });
      else updateLinting(cm, annotations);
    }
  }

  function updateLinting(cm, annotationsNotSorted) {
    clearMarks(cm);
    var state = cm.state.lint, options = state.options;

    var annotations = groupByLine(annotationsNotSorted);

    for (var line = 0; line &lt; annotations.length; ++line) {
      var anns = annotations[line];
      if (!anns) continue;

      var maxSeverity = null;
      var tipLabel = state.hasGutter && document.createDocumentFragment();

      for (var i = 0; i &lt; anns.length; ++i) {
        var ann = anns[i];
        var severity = ann.severity;
        if (!severity) severity = "error";
        maxSeverity = getMaxSeverity(maxSeverity, severity);

        if (options.formatAnnotation) ann = options.formatAnnotation(ann);
        if (state.hasGutter) tipLabel.appendChild(annotationTooltip(ann));

        if (ann.to) state.marked.push(cm.markText(ann.from, ann.to, {
          className: "CodeMirror-lint-mark-" + severity,
          __annotation: ann
        }));
      }

      if (state.hasGutter)
        cm.setGutterMarker(line, GUTTER_ID, makeMarker(tipLabel, maxSeverity, anns.length > 1,
                                                       state.options.tooltips));
    }
    if (options.onUpdateLinting) options.onUpdateLinting(annotationsNotSorted, annotations, cm);
  }

  function onChange(cm) {
    var state = cm.state.lint;
    if (!state) return;
    clearTimeout(state.timeout);
    state.timeout = setTimeout(function(){startLinting(cm);}, state.options.delay || 500);
  }

  function popupTooltips(annotations, e) {
    var target = e.target || e.srcElement;
    var tooltip = document.createDocumentFragment();
    for (var i = 0; i &lt; annotations.length; i++) {
      var ann = annotations[i];
      tooltip.appendChild(annotationTooltip(ann));
    }
    showTooltipFor(e, tooltip, target);
  }

  function onMouseOver(cm, e) {
    var target = e.target || e.srcElement;
    if (!/\bCodeMirror-lint-mark-/.test(target.className)) return;
    var box = target.getBoundingClientRect(), x = (box.left + box.right) / 2, y = (box.top + box.bottom) / 2;
    var spans = cm.findMarksAt(cm.coordsChar({left: x, top: y}, "client"));

    var annotations = [];
    for (var i = 0; i &lt; spans.length; ++i) {
      var ann = spans[i].__annotation;
      if (ann) annotations.push(ann);
    }
    if (annotations.length) popupTooltips(annotations, e);
  }

  CodeMirror.defineOption("lint", false, function(cm, val, old) {
    if (old && old != CodeMirror.Init) {
      clearMarks(cm);
      if (cm.state.lint.options.lintOnChange !== false)
        cm.off("change", onChange);
      CodeMirror.off(cm.getWrapperElement(), "mouseover", cm.state.lint.onMouseOver);
      clearTimeout(cm.state.lint.timeout);
      delete cm.state.lint;
    }

    if (val) {
      var gutters = cm.getOption("gutters"), hasLintGutter = false;
      for (var i = 0; i &lt; gutters.length; ++i) if (gutters[i] == GUTTER_ID) hasLintGutter = true;
      var state = cm.state.lint = new LintState(cm, parseOptions(cm, val), hasLintGutter);
      if (state.options.lintOnChange !== false)
        cm.on("change", onChange);
      if (state.options.tooltips != false && state.options.tooltips != "gutter")
        CodeMirror.on(cm.getWrapperElement(), "mouseover", state.onMouseOver);

      startLinting(cm);
    }
  });

  CodeMirror.defineExtension("performLint", function() {
    if (this.state.lint) startLinting(this);
  });
});</PRE></DIV></DIV><DIV name="Avatars" data-type="system" class="section section-hidden" data-group="basic" data-id="USSKFQPD" __wid="BktPxg3q"><DIV class="paragraph body-paragraph locked collapsed" draggable="false" name="Documentation" data-id="rVwMQEUm" __wid="T48Uyi4k"><DIV data-type="content" type="text/html" codemirror="true" contenteditable="false" class="section-documentation" __wid="4Cbd3BM7"><H2 __wid="iPiivuhi">Description</H2><DIV __wid="8HsK63CL">TODO</DIV></DIV></DIV><DIV class="paragraph data-paragraph locked collapsed" name="Properties" data-id="7kcnKK3R" __wid="SH64zHrJ"><PRE data-type="content" type="application/json" class="section-properties" contenteditable="false" __wid="ADKDaMjY">{
	"version": "1.0",
	"dependencies": [],
	"description": "Lorem ipsum",
	"changelog":
	{
		"1.0": "Initital Release"
	}
}</PRE></DIV>

<DIV class="paragraph body-paragraph collapsed" draggable="false" name="Documentation and Example Rendering" data-id="BqxeuLNK" __wid="HeQJZTAA"><DIV data-type="content" type="text/html" codemirror="true" contenteditable="true" __wid="3rcfZtbt"><H2 __wid="bGDg3xAt">Example of user list<BR __wid="mhSKPWdZ"/></H2>

<DIV class="avatars-test" __wid="7mfcJmQu">
	<DIV class="avatar" client-id="test3" username="unknown" style="background-image: url(&quot;unknown.jpg&quot;); border-color: rgb(99, 178, 252);" __wid="7D5qAfSN"></DIV>

	<DIV class="avatar" client-id="test2" username="cklokmose" style="background-image: url(&quot;https://avatars.githubusercontent.com/u/1607207?v=3&quot;); border-color: rgb(254, 83, 124);" __wid="PuhvSLms"></DIV>

	<DIV class="avatar self" client-id="test1" username="raedle" style="background-image: url(&quot;https://avatars.githubusercontent.com/u/489051?v=3&quot;); border-color: rgb(226, 178, 252);" __wid="nejDwqQv"></DIV>
</DIV></DIV></DIV><DIV class="paragraph code-paragraph collapsed" name="Avatars Code" run-on-load="true" last-execution-state="success" data-id="QSCmBY4t" __wid="3seNQSwb"><PRE data-type="content" type="text/javascript" __wid="MqCvR8D4">const ClientManager = require('#client-manager');
const FlashScreen = require('#flash-screen');

const anonymousUrl = "unknown.jpg";

// How often the idle time is updated (in milliseconds)
const UPDATE_IDLE_TIME_INTERVAL = 10 * 1000;

// Add avatars element
const avatars = document.createElement("transient");
avatars.classList.add("avatars");
document.body.appendChild(avatars);

/**
 * Get other client ids (all connected client ids except for own client id).
 */
const otherClientIds = () => {
  return webstrate.clients.filter(c => c !== webstrate.clientId);
};

/**
 * Add a client's avatar to the avatars list.
 */
const addAvatar = (client) => {

  if (avatars.querySelector(`.avatar[client-id=${client.id}]`)) return;

  const avatar = document.createElement("div");
  avatar.classList.add("avatar");
  avatar.setAttribute("client-id", client.id);
  avatar.setAttribute("username", client.username || client.id);
  avatar.style.backgroundImage = `url(${client.avatarUrl})`;
  avatar.style.borderColor = ClientManager.getClientColor(client.id);

  // Send flash screen command to sender
  avatar.addEventListener("click", (event) => {
    webstrate.signal({
      cmd: "flashScreen"
    }, client.id);
  });
	
	if (client.id === webstrate.clientId) {
    avatar.classList.add("self");
		avatars.insertBefore(avatar, avatars.firstElementChild);
  }
	else {
		avatars.appendChild(avatar);
	}
};

/**
 * Update a client's avatar
 */
const updateAvatar = (client) => {
  const avatar = avatars.querySelector(`.avatar[client-id="${client.id}"]`);
  if (avatar) {
    avatar.setAttribute("username", client.username || client.id);
    avatar.style.backgroundImage = `url(${client.avatarUrl})`;
    avatar.style.borderColor = ClientManager.getClientColor(client.id);
  }
};

/**
 * Removes an avatar from the avatars list.
 *
 * @param {string} clientId The client's id associated with the avatar.
 */
const removeAvatar = (client) => {
  stopUpdateIdleTime(client.id);

  const avatar = avatars.querySelector(`.avatar[client-id="${client.id}"]`);
  if (avatar) {
    avatar.remove();
  }
};

const updateIdleTime = (senderId, idleTime) => {

  // 	console.log(senderId, idleTime);

  const avatar = avatars.querySelector(`.avatar[client-id="${senderId}"]`);

  if (!avatar) {
    // 		console.warn(`Client ${senderId} keeps pinging but avatar does not exist anymore... Why?`);
    return;
  }

  var snoozeBox = avatar.querySelector(".snooze");
  if (idleTime > 0) {
    avatar.classList.add("snoozed");
    if (!snoozeBox) {
      snoozeBox = document.createElement("div");
      snoozeBox.classList.add("snooze");
      avatar.appendChild(snoozeBox);
    }
    snoozeBox.innerHTML = `${(idleTime/1000/60)|0}m`;
  } else if (snoozeBox) {
    avatar.classList.remove("snoozed");
    snoozeBox.remove();
  }
};

const idleClients = [];

const stopUpdateIdleTime = (clientId) => {
  // Clear update interval
  const clients = idleClients.filter((c) => c.clientId === clientId)
    .forEach((c) => clearInterval(c.interval));
};

/**
 * Clear all update idle timers.
 */
const clearUpdateIdleTimers = () => {
  idleClients.forEach((c) => clearInterval(c.interval));
};

/**
 * Listen for other client to signal their avatar url.
 */
webstrate.on("signal", (message, senderId) => {

  if (message.type === "IdleTimer") {
    // 		console.log(message, senderId);

    if (message.cmd === "awake") {
      stopUpdateIdleTime(senderId);
      updateIdleTime(senderId, 0);
    } else if (message.cmd === "idle") {

      const lastAction = Date.now() - message.idleTime;

      updateIdleTime(senderId, Date.now() - lastAction);
      const interval = setInterval(() => {
        updateIdleTime(senderId, Date.now() - lastAction);
      }, UPDATE_IDLE_TIME_INTERVAL);

      idleClients.push({
        clientId: senderId,
        interval: interval
      });
    }

    return;
  }

  if (message.cmd === "flashScreen") {

    // Ignore own message -> remove when code is stable.
    if (webstrate.clientId === senderId) {
      // 			throw new Error("This should not happen");
      return;
    }

    // Flash, flash!
    FlashScreen.flash();

    // Show little star next to whoever flashed.
    senderAvatar = avatars.querySelector(`.avatar[client-id="${senderId}"]`);
    var div = document.createElement("div");
    div.classList.add("star");
    div.innerHTML = "&#10039;";
    senderAvatar.appendChild(div);
    setTimeout(() => div.remove(), 5000);
  }
});

// add existing clients
Codestrate.clients.forEach((client) => addAvatar(client));

// add clients added later on
Codestrate.on("clientAdd", (client) => addAvatar(client));

// update avatars
Codestrate.on("clientUpdate", (client) => updateAvatar(client));

// update avatars
Codestrate.on("clientUpdateProperty", ({propertyName, client}) => updateAvatar(client));

// remove leaving clients
Codestrate.on("clientRemove", (client) => removeAvatar(client));

// Clear all update idle timers and remove all avatars.
webstrate.on("disconnect", () => {

  // Clear all update idle timers.
  clearUpdateIdleTimers();

  // Clear all avatars
  avatars.innerHTML = "";
});</PRE></DIV><DIV class="paragraph style-paragraph collapsed" name="Avatars Style" data-id="ZDQNSSqu" __wid="Y4MEDAHd"><STYLE data-type="content" type="text/css" codemirror="true" __wid="3Tk8CcEP">.avatars {
	position: fixed;
	bottom: 5px;
	right: 5px;
}

/* Make the .avatars-test only occupy minimal space */
.avatars-test {
	float: left;
	position: relative;
	bottom: 10px;
	left: 10px;
}

.avatars .avatar,
.avatars-test .avatar {
	box-sizing: content-box;
	position: relative;
	width: 45px;
	height: 45px;
	margin-top: 10px;
	background-size: contain;
	border-radius: 50%;
	border: 2px solid white;
	box-shadow: 0px 0px 5px #000;
}
.avatars .avatar:not(.self) {
	cursor: pointer;
}
.avatars:hover .avatar:after,
.avatars-test:hover .avatar:after {
	content: attr(username);
	display: inline-block;
	background: #000;
	padding: 2px 6px;
	font-size: .8em;
	transform: translate3d(-100%, 10px, 0) translate3d(-10px, 0, 0) rotate(-4deg);
}
.avatars .avatar > div.star {
	color: rgba(255,255,255,.3);
	position: absolute;
	margin-left: 47px;
	margin-top: 47px;
}
.avatars .avatar > div.snooze {
	color: #fff;
	font-size: 65%;
	font-weight: bold;
	text-shadow: 1px 1px #000;
	position: absolute;
	margin-left: 53px;
	margin-top: -3px;
}
.avatars .avatar.snoozed {
	opacity: .25;
}
@media only screen and (max-width: 950px) {
	.avatars {
		display: none;
	}
/* 	.avatars {
		top: 5px;
		left: 5px;
	}
	.avatars .avatar {
		width: 30px;
		height: 30px;
		margin-bottom: 5px;
		border-width: 1px;
	}
	.avatars:hover .avatar:after {
		font-size: 60%;
	}
	.avatar > div.star {
		font-size: 40%;
	  margin-left: 23px;
	  margin-top: 23px;
	}
	.avatar > div.snooze {
		display: none;
	} */
}
@media only screen and (max-width: 875px) {
	.avatars {
		display: none;
	}
}</STYLE></DIV><DIV class="paragraph code-paragraph collapsed" name="Flash Screen Code" last-execution-state="success" data-id="CUrR76Lw" __wid="Y5WXxLT9"><PRE data-type="content" type="text/javascript" id="flash-screen" __wid="CEfUXZ4b">exports.flash = () => {
	const overlay = document.createElement("transient");
	overlay.classList.add("flash-overlay");
	setTimeout(() => overlay.remove(), 200);
	document.body.appendChild(overlay);
};</PRE></DIV><DIV class="paragraph style-paragraph collapsed" name="Flash Screen Style" data-id="PyhaWPuz" __wid="RPpn4ZTB"><STYLE data-type="content" type="text/css" codemirror="true" __wid="GRNdkRru">@keyframes pulse {
  0% {
    background: transparent;
  }
  50% {
    background: rgba(255,255,255,.3);
  }
  100% {
    background: transparent;
  }
}

.flash-overlay {
	position: fixed;
	top: 0;
	left: 0;
	right: 0;
	bottom: 0;
	max-width: 100vw;
	max-height: 100vh;
  animation: pulse 0.2s ease-in-out;
}</STYLE></DIV><DIV class="paragraph code-paragraph collapsed" name="Idle Time Code" last-execution-state="success" data-id="sx5rdbHz" __wid="RYDC5Z9q"><PRE data-type="content" type="text/javascript" id="idle-time" __wid="BvTSXuCK">var lastAction = Date.now();
const updateLastAction = () => lastAction = Date.now();
//document.addEventListener("keydown", updateLastAction);
document.addEventListener("mousemove", updateLastAction);
document.addEventListener("touchstart", updateLastAction);
exports.get = () => ((Date.now() - lastAction) / 1000) | 0;</PRE></DIV></DIV><DIV class="section section-hidden" name="WebRTC Video on Avatar" data-type="system" data-group="basic" data-id="JvywitDB" __wid="c7yiTXka"><DIV class="paragraph body-paragraph locked collapsed" name="Documentation" data-id="3gpHCaHH" __wid="qaAaBGFf"><DIV data-type="content" type="text/html" codemirror="true" contenteditable="false" class="section-documentation" __wid="w7kdBQe6"><H2 __wid="VHSfxhTS">Description</H2>TODO</DIV></DIV><DIV class="paragraph data-paragraph locked collapsed" name="Properties" data-id="r79E9WYH" __wid="HSuNK8bW"><PRE data-type="content" type="application/json" class="section-properties" contenteditable="false" __wid="gaP8pkXR">{
	"version": "1.0",
	"dependencies": [
		{
			"id": "USSKFQPD",
			"name": "Avatar"
		}
	],
	"description": "Lorem ipsum",
	"changelog":
	{
		"1.0": "Initital Release"
	}
}</PRE></DIV>

<DIV class="paragraph style-paragraph collapsed" draggable="false" name="WebRTC Style" data-id="KQw7yyGg" __wid="9JHbJ8Pk"><STYLE data-type="content" type="text/css" codemirror="true" __wid="uYGkvxjj">.avatars .avatar .video-wrapper {
	position: absolute;
	top: 0;
	left: 0;
	width: 100%;
	height: 100%;
	border-radius: 50%;
	-webkit-mask-image: -webkit-radial-gradient(circle, white 100%, black 100%); 
	-webkit-transform: rotate(0.000001deg); 
	-webkit-border-radius: 50%; 
	-moz-border-radius: 50%;
	transform: translateZ(0);
}

.avatars .avatar .video-wrapper video {
	position: absolute;
	left: 50%;
	top: 50%;
	height: 100%;
	transform: translate3d(-50%, -50%, 0);
}

.avatars .avatar.self .video-wrapper video {
	transform: translate3d(-50%, -50%, 0) scaleX(-1);
}</STYLE></DIV><DIV class="paragraph code-paragraph collapsed" name="Event Handling" run-on-load="true" last-execution-state="success" data-id="rjKcVvbm" __wid="a7t5K2Jt"><PRE data-type="content" type="text/javascript" __wid="mSet7wsr">webstrate.on("signal", (message, senderId) => {

	if (message.type === "Call") {

		// Received request for video call.
		if (message.cmd === "video") {
			console.log("Requesting video");
			
			const result = confirm(`User ${senderId} calls you. Do you want to accept the call?`);
			
			if (result) {
				VideoManager.start(senderId);

				// Signal accept
				webstrate.signal({ type: "Call", cmd: "accept" }, senderId);
			}
			else {
				// Signal reject
				webstrate.signal({ type: "Call", cmd: "reject" }, senderId);
			}
		}
		// Approved video call request.
		else if (message.cmd === "accept") {
			console.log("Accepting video");
			
			VideoManager.start(senderId);
		}
		else if (message.cmd === "reject") {
			console.log("Rejecting video");
			alert(`User ${senderId} rejected call.`);
		}

		return;
	}
});

const createUserVideo = (clientId) => {
	const avatar = document.querySelector(`.avatars .avatar[client-id="${clientId}"]`);

	var videoWrapper = document.createElement("div");
	videoWrapper.classList.add("video-wrapper");
	
	var video = document.createElement("video");
	video.classList.add("remote-video");
	videoWrapper.appendChild(video);
	avatar.appendChild(videoWrapper);
	
	return video;
};

const listenForStreams = (clientId, meta, accept) => {
	console.log('create user video', clientId);
	const videoElement = createUserVideo(clientId);

	if (videoElement) {
		console.log('create user element', videoElement);
		
		var conn = accept(function(stream) {
			// Add stream to video element and play it.
			videoElement.srcObject = stream;
			videoElement.play();
			
			conn.onclose(function() {
				if (stream) {
					stream.getVideoTracks().forEach(t => t.stop());
					stream.getAudioTracks().forEach(t => t.stop());
				}

				videoElement.closest('.video-wrapper').remove();
				
				//document.body.webstrate.on("signalStream", listenForStreams);
			});
		});
	}
	
// 	// Listen for further streams...
// 	document.body.webstrate.on("signalStream", listenForStreams);
};

document.body.webstrate.on("signalStream", listenForStreams);</PRE></DIV><DIV class="paragraph code-paragraph collapsed" name="Video Manager" data-id="AjDjPGuu" __wid="NYQfcLBA"><PRE data-type="content" type="text/javascript" id="video-manager" __wid="iAziSrRN">const createUserVideo = (clientId) => {
	const avatar = document.querySelector(`.avatar[client-id="${clientId}"]`);

	// no avatar for client id found
	if (!avatar) return;

	let video = avatar.querySelector('video');
	if (video) {
		return video;
	}

	const videoWrapper = document.createElement("div");
	videoWrapper.classList.add("video-wrapper");

	video = document.createElement("video");
	video.classList.add("local-video");
	video.setAttribute("muted", "");

	videoWrapper.appendChild(video);
	avatar.appendChild(videoWrapper);

	return video;
};

const signalStream = (clientId, accept) => {
	// Get audio and video feed.
	
	if (clientId === webstrate.clientId) return;

	try {
		const videoElement = createUserVideo(webstrate.clientId);

		if (!videoElement.__cons) {
			videoElement.__cons = [];
		}

		if (videoElement.__stream) {
			// And send it to the requesting client.
			var meta = { title: "My Video Stream" };
			var conn = accept(videoElement.__stream, meta, function() {
				// Connection has been established.
			});

			videoElement.__cons.push(conn);
		}
		else {
			const mediaDevices = navigator.mediaDevices;
			mediaDevices.getUserMedia({ audio: true, video: true })
				.then(function(stream) {

				videoElement.__stream = stream;
				videoElement.srcObject = stream;
				videoElement.play();

				// And send it to the requesting client.
				var meta = { title: "My Video Stream" };
				var conn = accept(stream, meta, function() {
					// Connection has been established.
				});

				videoElement.__cons.push(conn);
			});
		}
	}
	catch (error) {
		console.error(error);
	}
};

exports.hearMe = () => {
	document.body.webstrate.signalStream(signalStream);
};

exports.stopHearMe = () => {
	document.body.webstrate.stopStreamSignal(signalStream);

	const video = createUserVideo(webstrate.clientId);
	if (video.__cons) {
		video.__cons.forEach(c => c.close());
		delete video.__cons;
	}

	if (video.__stream) {
		const stream = video.__stream;
		stream.getVideoTracks().forEach(t => t.stop());
		stream.getAudioTracks().forEach(t => t.stop());
		delete video.__stream;
	}

	video.closest('.video-wrapper').remove();
};</PRE></DIV><DIV class="paragraph code-paragraph collapsed" name="Augment Avatar" run-on-load="true" last-execution-state="success" data-id="FpYrQpAQ" __wid="eEeikcfp"><PRE data-type="content" type="text/javascript" __wid="ac3FirrK">const VideoManager = require('#video-manager');

const augmentAvatar = (avatar) => {
	const hearMe = document.createElement("div");
	hearMe.classList.add("hear-me");

	const icon = document.createElement("i");
	icon.classList.add("material-icons");
	hearMe.appendChild(icon);

	hearMe.addEventListener("click", event => {

		if (avatar.classList.contains("talking")) {
			VideoManager.stopHearMe();
			avatar.classList.remove("talking");
		}
		else {
			VideoManager.hearMe();
			avatar.classList.add("talking");
		}
	});

	avatar.appendChild(hearMe);
};

document.liveQuerySelectorAll('.avatars .avatar.self').added(augmentAvatar);</PRE></DIV><DIV class="paragraph style-paragraph collapsed" name="Augmented Avatar Style" data-id="rVRxSnSj" __wid="tLnJ2VJK"><STYLE data-type="content" type="text/css" codemirror="true" __wid="AsFaGk2c">.avatars .avatar .hear-me {
	position: absolute;
	top: 0;
	left: 0;
	z-index: 1;
	width: 45px;
	height: 45px;
	background-color: deepskyblue;
	border-radius: 50%;
	border: 2px solid white;
	box-shadow: 0px 0px 5px #000;
	opacity: 0;
	transition: transform 250ms ease-in-out 250ms, opacity 250ms ease-in-out 250ms;
}

.avatars .avatar .hear-me i:after {
	content: "videocam";
	position: absolute;
	left: 50%;
	top: 50%;
	transform: translate3d(-50%, -50%, 0);
}

.avatars .avatar .hear-me:hover {
	background-color: green;
}

.avatars .avatar.talking .hear-me i:after {
	content: "videocam_off";
}

.avatars .avatar:hover .hear-me {
	opacity: 1.0;
	transform: translate3d(-50px, 0, 0);
	pointer-events: all;
	cursor: pointer;
}</STYLE></DIV></DIV><DIV class="section section-hidden" name="Messages (experimental)" data-type="system" data-group="basic" data-id="E9RsGgmZ" __wid="YCgLtHJ8"><DIV class="paragraph body-paragraph locked collapsed" draggable="false" name="Documentation" data-id="yE2MbEaa" __wid="HyF9RNZm"><DIV data-type="content" type="text/html" codemirror="true" contenteditable="false" class="section-documentation" __wid="WxZ2Tiy8"><H2 __wid="6W3rVPtc">Description</H2>TODO</DIV></DIV><DIV class="paragraph data-paragraph locked collapsed" name="Properties" data-id="AZu6s64W" __wid="vGMqqDLs"><PRE data-type="content" type="application/json" class="section-properties" contenteditable="false" __wid="V5iGKHzY">{
	"version": "1.0",
	"dependencies": [],
	"description": "Lorem ipsum",
	"changelog":
	{
		"1.0": "Initital Release"
	}
}</PRE></DIV>

<DIV class="paragraph body-paragraph collapsed locked" draggable="false" style data-id="XF6byGcD" name="Messages Template" __wid="F7AiDxjN"><DIV data-type="content" type="text/html" codemirror="true" contenteditable="false" __wid="MMR3ESHv"><TEMPLATE id="messages-template" __wid="QtThm3Nw">
	<TRANSIENT class="messages" __wid="2CxP7TWA">
		<DIV class="close" __wid="8i4fxn2D">
			<I class="material-icons" __wid="zfcHcvbP">clear</I>
		</DIV>
	</TRANSIENT>
</TEMPLATE></DIV></DIV><DIV class="paragraph body-paragraph locked" draggable="false" style name="Message Template" data-id="zd7rzAy5" __wid="SxrbgxjR"><DIV data-type="content" type="text/html" codemirror="true" contenteditable="false" __wid="XbRvh3AE"><TEMPLATE id="message-template" __wid="DapfYruc">
	<DIV class="message" __wid="rjLJtMHX">
		<PRE class="content" __wid="FQhgpW6j">Content</PRE>
		<DIV class="delete" __wid="EydcrQXa">
			<I class="material-icons" __wid="WRX6a6BN">delete</I>
		</DIV>
	</DIV>
</TEMPLATE></DIV></DIV><DIV class="paragraph code-paragraph collapsed" draggable="false" style name="Message Viewer" run-on-load="true" last-execution-state="success" data-id="N4hU8h6A" __wid="2Yqtqj4U"><PRE data-type="content" type="text/javascript" __wid="YrRBNHcr">const GlobalMenuUtils = require('#global-menu-utils');

const showMessagesAction = document.createElement('button');
showMessagesAction.innerHTML = "Show Messages";
showMessagesAction.addEventListener("click", event => {
	
	// get messages template
	let template = document.querySelector('#messages-template');
	let fragment = document.importNode(template.content, true);
	let messages = fragment.firstElementChild;

	// get message template
	let messageTemplate = document.querySelector("#message-template");
	
	// add message to message view
	const addMessage = (msg) => {
		// create a clone from message template, and set message subject and message body
		let messageFragment = document.importNode(messageTemplate.content, true);
		let message = messageFragment.querySelector('.message');

		message.setAttribute("message-id", msg.messageId);
		message.querySelector('.content').innerHTML = JSON.stringify(msg, null, 2);
		message.querySelector('.delete').addEventListener("click", (event) => {
			webstrate.deleteMessage(msg.messageId);
			message.remove();
		});

		messages.appendChild(message);
	};
	
	// delete message from messages view
	const deleteMessage = (messageId) => {
		let message = messages.querySelector(`[message-id="${messageId}"]`);
		if (message) {
			message.remove();
		}
	};
	
	function onMessageReceived(message, senderId, messageId) {
		addMessage(message);
	}
	
	function onMessageDeleted(messageId) {
		deleteMessage(messageId);
	}
	
	// add existing messages, and add listeners to new messages or when messages were
	// deleted on another client
	webstrate.messages.forEach(addMessage);
	webstrate.on("messageReceived", onMessageReceived);
	webstrate.on("messageDeleted", onMessageDeleted);
	
	// add listener when
	document.addEventListener("click", function closeMessage(event) {
		
		if (!event.target.closest('.messages')) {
			document.removeEventListener("click", closeMessage, true);
			webstrate.off("messageReceived", onMessageReceived);
			webstrate.off("messageDeleted", onMessageDeleted);
			messages.remove();
		}
	}, true);
	
	document.body.appendChild(messages);
});

GlobalMenuUtils.addMenuItem(showMessagesAction);</PRE></DIV><DIV class="paragraph style-paragraph collapsed" style name="Message Style" data-id="6iAb2HCQ" __wid="guPeUF7t"><STYLE data-type="content" type="text/css" codemirror="true" __wid="XHFZ7Fqy">.messages {
/* 	pointer-events: none; */
	position: fixed;
	z-index: 1;
	top: 0;
	left: 0;
	right: 0;
	bottom: 0;
	width: calc(100vw - 100px);
	height: calc(100vh - 100px);
	margin: 50px;
	padding: 10px;
	overflow: auto;
	border-radius: 2px;
	
	color: black;
	background-color: whitesmoke;
}

.messages:empty:after {
	content: "No messages";
}

.messages .message {
	position: relative;
	padding: 10px;
}

.messages .message .delete {
	user-select: none;
	cursor: pointer;
	position: absolute;
	top: 10px;
	right: 10px;
	color: darkred;
	display: inline-block;
}</STYLE></DIV></DIV><DIV class="section section-hidden" name="Toast Messages (experimental)" data-type="system" data-group="basic" data-id="4MdLqZhf" __wid="iPHNCMzn"><DIV class="paragraph body-paragraph locked collapsed" draggable="false" name="Documentation" data-id="CzNxGRqf" __wid="bJ3d73Hg"><DIV data-type="content" type="text/html" codemirror="true" contenteditable="false" class="section-documentation" __wid="RRueqUTy"><H2 __wid="VfTkSQZF">Description</H2>TODO</DIV></DIV><DIV class="paragraph data-paragraph locked collapsed" name="Properties" data-id="FS3D7aYM" __wid="k8VmAivL"><PRE data-type="content" type="application/json" class="section-properties" contenteditable="false" __wid="GQhsyxrt">{
	"version": "1.0",
	"dependencies": [],
	"description": "Lorem ipsum",
	"changelog":
	{
		"1.0": "Initital Release"
	}
}</PRE></DIV>

<DIV class="paragraph body-paragraph locked" draggable="false" style name="Toast Message Template" data-id="8vgqpbV9" __wid="TnRLtQDm"><DIV data-type="content" type="text/html" codemirror="true" contenteditable="false" __wid="2dLTJE9D"><TEMPLATE id="toast-message-template" __wid="9VeJFtAg">
  <DIV class="toast-message" __wid="Ly847dmy"></DIV>
</TEMPLATE></DIV></DIV><DIV class="paragraph code-paragraph collapsed" last-execution-state="success" run-on-load="true" style name="Toast Messages" data-id="GaZttnH6" __wid="rpNwpkaH"><PRE data-type="content" type="text/javascript" __wid="EkYu7TWf">// create global toast message container
let toastMessages = document.querySelector('body .toast-messages');
if (!toastMessages) {
	toastMessages = document.createElement("transient");
	toastMessages.classList.add("toast-messages");
	document.body.appendChild(toastMessages);
}

const toast = (content, duration = 10000) => {

	// get message template, create a clone, and set message subject and message body
	let template = document.querySelector("#toast-message-template");
	let fragment = document.importNode(template.content, true);
	let toastMessage = fragment.firstElementChild;

	// append content if it is a Node, otherwise set the content as innerHTML
	if (content instanceof Node) {
		toastMessage.appendChild(content);
	}
	else {
		toastMessage.innerHTML = content;
	}
	
	// insert message as first child of messages to place it at the top position
	toastMessages.insertBefore(toastMessage, toastMessages.firstElementChild);

	// remove message on click
	toastMessage.addEventListener("click", (event) => {
		toastMessage.remove();
	});

	// delay adding the show class by two render cycles to make sure possible CSS transitions
	// will trigger
	window.requestAnimationFrame(() => {
		window.requestAnimationFrame(() => {
			toastMessage.classList.add("show");

			setTimeout(() => {
				toastMessage.addEventListener("transitionend", (event) => {
					if (event.propertyName === "opacity") {
						toastMessage.remove();
					}
				});

				toastMessage.classList.remove("show");
				toastMessage.classList.add("hide");
			}, duration);
		});
	});
};

// add toast to the JavaScript VM context
let vm = Codestrate.VirtualMachines.get("text/javascript");
vm.addToGlobalContext({
	toast
});</PRE></DIV><DIV class="paragraph style-paragraph collapsed" style draggable="false" name="Toast Message Style" data-id="B8Dik9QL" __wid="UBhJP28j"><STYLE data-type="content" type="text/css" codemirror="true" __wid="r28ejKKv">.toast-messages {
	position: fixed;
	left: 0;
	top: 0;
	width: 100vw;
	height: 100vh;
	pointer-events: none;
/*  	background-color: rgba(255, 0, 0, .1); */
}

.toast-messages .toast-message {
	position: relative;
/* 	top: -100%; */
	width: calc(100% - 15px);
	color: black;
	margin: 5px;
	padding: 10px;
	pointer-events: all;
	background-color: whitesmoke;
	transition: all 250ms ease-in-out;
	opacity: 0;
	border-radius: 2px;
	cursor: default;
}

.toast-messages .toast-message.show {
	top: 0;
	opacity: 1.0;
/* 	background-color: deepskyblue; */
}

.toast-messages .toast-message:hover {
	opacity: 1.0;
/* 	background-color: orange; */
}

.toast-messages .toast-message.hide {
	top: 0;
/* 	background-color: hotpink; */
}

.toast-messages .toast-message .subject {
	font-weight: bold;
}</STYLE></DIV></DIV><DIV class="section section-hidden" name="Assets" data-type="system" data-id="yfRLVs2U" __wid="wsAZ2qGm"><DIV class="paragraph body-paragraph locked collapsed" data-id="uyJ3rDdC" name="Documentation" __wid="9v9JG49j"><DIV data-type="content" type="text/html" codemirror="true" contenteditable="false" class="section-documentation" __wid="cXNG2yB6"><H2 __wid="br4VzZrR">Description</H2><DIV __wid="nKHw8YvK">TODO</DIV></DIV></DIV><DIV class="paragraph data-paragraph locked collapsed" data-id="xCRkA7iz" name="Properties" __wid="DpZ666W7"><PRE data-type="content" type="application/json" contenteditable="false" class="section-properties" __wid="8RqCPd6V">{
	"version": "1.0",
	"description": "Lorem ipsum",
	"changelog":
	{
		"1.0": "Initital Release"
	}
}</PRE></DIV><DIV class="paragraph code-paragraph collapsed" name="Asset Utils Code" draggable="false" style data-id="ZEUFBDeK" __wid="Rz2rC5t8"><PRE data-type="content" type="text/javascript" id="asset-utils" __wid="c6k5CKMX">// 1024 bytes * 1024 kB * 100 => 100 MB
const MAX_FILE_SIZE = 1024 * 1024 * 100;
const MAX_PREVIEW_FILE_SIZE = 1024 * 1024 * 20;

/**
 *
 */
const acceptFileOrThrowError = (file) => {
	if (file.size > MAX_FILE_SIZE) {
		throw new Error(`File size of ${file.name} is to large. Maximum file size is ${MAX_FILE_SIZE} bytes.`);
	}

	return true;
};

exports.uploadFiles = (files, onUploaded, onBeforeUpload, onError) => {

	if (files.length === 0) {
		return;
	}

	files.forEach((file) => {

		try {
			acceptFileOrThrowError(file);

			//       window.console.log('file', file);

			const uuid = Codestrate.util.randomString();

			const reader = new FileReader();
			reader.onload = function (e) {
				const asset = {
					uuid: uuid,
					fileName: file.name,
					mimeType: file.type,
					source: e.target.result
				};

				if (file.size &lt;= MAX_PREVIEW_FILE_SIZE) {
					if (typeof onBeforeUpload === 'function') {
						onBeforeUpload(asset);
					}
				}

				const formData = new FormData();
				formData.append("file", file, file.name);

				const request = new XMLHttpRequest();
				request.open("POST", window.location.pathname);
				request.send(formData);
				request.addEventListener("load", (e) => {
					const asset = JSON.parse(request.responseText);
					asset.uuid = uuid;
					asset.source = asset.fileName;

					onUploaded(asset);
				});
			};
			reader.readAsDataURL(file);
		}
		catch (error) {
			onError(error);
		}
	});
};

exports.uploadBlob = (assetName, blob, onBeforeUpload) => {

	return new Promise((resolve, reject) => {
		try {
			acceptFileOrThrowError(blob);

			const uuid = Codestrate.util.randomString();

			const asset = {
				uuid: uuid,
				fileName: assetName,
				mimeType: blob.type,
				source: blob
			};

			if (typeof onBeforeUpload === 'function') {
				onBeforeUpload(asset);
			}

			const formData = new FormData();
			formData.append("file", blob, assetName);

			const request = new XMLHttpRequest();
			request.open("POST", window.location.pathname);
			request.send(formData);
			request.addEventListener("load", (e) => {
				const asset = JSON.parse(request.responseText);
				asset.uuid = uuid;
				asset.source = asset.fileName;

				resolve(asset);
			});
		}
		catch (error) {
			reject(error);
		}
	});
};

exports.getElementFromAsset = (asset) => {

	let node;

	switch (asset.mimeType) {
		case "image/jpeg":
		case "image/png":
			node = document.createElement("img");
			node.setAttribute("src", asset.source);
			break;
		case "audio/mp3":
			node = document.createElement("audio");
			node.setAttribute("src", asset.source);
			node.setAttribute("controls", "true");
			break;
		case "video/mp4":
			node = document.createElement("video");
			node.setAttribute("src", asset.source);
			node.setAttribute("controls", "true");
			break;
		default:
			node = document.createElement("a");
			node.setAttribute("href", asset.source);
			node.setAttribute("target", "_blank");
			node.innerHTML = asset.source;
			break;
	}

	// 	// Disable (text) selection. It is, for example, necessary to make
	// 	// links clickeable.
	// 	node.setAttribute("contenteditable", "false");

	return node;
};</PRE></DIV><DIV class="paragraph code-paragraph collapsed" name="Drop Assets Code" run-on-load="true" style draggable="false" last-execution-state="success" data-id="rx3eU4qQ" __wid="xLGTAA9S"><PRE data-type="content" type="text/javascript" __wid="NWgMG6Jz">const AssetUtils = require('#asset-utils');

const handleFileDrop = (event, onUploaded, onBeforeUpload, onError) => {
  const files = Array.from(event.dataTransfer.files);
  AssetUtils.uploadFiles(files, onUploaded, onBeforeUpload, onError);
};

/**
 * Returns true if the drop transfer types contain "Files", and returns false otherwise.
 * 
 * @param {Object} event A drop event.
 *
 * @return True if the drop transfer types contain "Files" as type.
 */
const isFileDrop = (event) => {
  if (event.dataTransfer.types) {
		return event.dataTransfer.types.some((type) => type === "Files");
  }
	return false;
};

const addDropListener = (content) => {

  // Listen for a drop
  content.addEventListener("drop", (event) => {
		
// 		console.log('drop here', event);

    // only continue on file drop
    if (!isFileDrop(event)) return;

    // prevent the default behavior
    event.preventDefault();

    // get the position where file(s) where dropped
    const range = document.caretRangeFromPoint(event.clientX, event.clientY);

    /**
     * Called when asset uploaded completely.
     */
    const onUploaded = (asset) => {
      let node = AssetUtils.getElementFromAsset(asset);

      const uploadInProgress = content.querySelector(`[data-upload-id="${asset.uuid}"]`);

      if (uploadInProgress) {
        uploadInProgress.parentElement.replaceChild(node, uploadInProgress);
      } else {
        range.insertNode(node);
      }
    };

    /**
     * Called before asset is going to be uploaded.
     */
    const onBeforeUpload = (asset) => {

      let node = AssetUtils.getElementFromAsset(asset);

      const uploadInProgress = document.createElement("transient");
      uploadInProgress.setAttribute("data-upload-id", asset.uuid);
      uploadInProgress.setAttribute("class", "upload-in-progress");
      uploadInProgress.appendChild(node);

      range.insertNode(uploadInProgress);
    };

		/**
		 * Called when an error occurs during drop.
		 */
    const onError = (error) => {
      toast(error);
    };

    // Handle file drop with uploaded, before upload, and error callbacks.
    handleFileDrop(event, onUploaded, onBeforeUpload, onError);
  });
};

// Get the text paragraph.
var contents = document.liveQuerySelectorAll('.paragraph.body-paragraph [data-type="content"]');
contents.added((content) => {
// 	console.log('add content', content);
	addDropListener(content);
});</PRE></DIV><DIV class="paragraph code-paragraph collapsed" name="Add File Code" run-on-load="true" last-execution-state="success" draggable="false" style data-id="L6BgJE5u" __wid="44cst9Bv"><PRE data-type="content" type="text/javascript" __wid="64nX5kQR">const AssetUtils = require('#asset-utils');

const createDomNode = (textElement) => {

  const pictureTools = document.createElement("div");
  pictureTools.setAttribute("class", "action add-file");
	pictureTools.setAttribute("tooltip", true);

  const label = document.createElement("label");
  label.setAttribute("class", "material-icons input-button");

  this.input = document.createElement("input");
  this.input.setAttribute("type", "file");
//   this.input.setAttribute("accept", "image/*");

  this.input.addEventListener("change", event => {
    const files = Array.from(this.input.files);
    
//     console.log('upload files %o', files);
    
    AssetUtils.uploadFiles(files, (asset) => {
      addImage(asset, textElement);
    }, null, error => {
      console.error(error);
    });
    
    this.input.value = "";
  });

  label.appendChild(this.input);
  pictureTools.appendChild(label);

  return pictureTools;
};

const addImageTool = (textElement) => {
  
  const tools = textElement.parentElement.querySelector('.text-tools');
  
  if (!tools) return;
  
  // Only add image tools once.
  if (tools.querySelector('.add-file')) return;
  
  const imageTool = createDomNode(textElement);
  tools.appendChild(imageTool);
};

const addImage = (asset, textElement) => {
  
//   console.log('add image %o', asset);
  
  const element = AssetUtils.getElementFromAsset(asset);
  if (element) {
    if (!HTMLUtils.appendChildAtCaret(element, (range) => {
      return textElement.contains(range.commonAncestorContainer);
    })) {
      textElement.appendChild(element);
    }
  }
};

document.liveQuerySelectorAll('.paragraph.body-paragraph [data-type="content"][contenteditable]').added(addImageTool);

// const resizeImage = (img) => {
//   let width = img.width;
//   let height = img.height;

//   const max = Math.max(width, height);
//   const min = Math.min(width, height);

//   const maxSize = 800;

//   // Resize image when to large.
//   if (max > maxSize) {

//     let newWidth = width > height ? maxSize : (min / max) * maxSize;
//     let newHeight = height > width ? maxSize : (min / max) * maxSize;
//     width = newWidth;
//     height = newHeight;

//     const canvas = document.createElement('canvas');
//     const ctx = canvas.getContext('2d');
//     canvas.width = newWidth;
//     canvas.height = newHeight;

//     /// step 1 - resize to 50%
//     const oc = document.createElement('canvas');
//     const octx = oc.getContext('2d');

//     oc.width = img.width * 0.5;
//     oc.height = img.height * 0.5;
//     octx.drawImage(img, 0, 0, oc.width, oc.height);

//     /// step 2 - resize 50% of step 1
//     octx.drawImage(oc, 0, 0, oc.width * 0.5, oc.height * 0.5);

//     /// step 3, resize to final size
//     ctx.drawImage(oc, 0, 0, oc.width * 0.5, oc.height * 0.5, 0, 0, canvas.width, canvas.height);

//     img.src = canvas.toDataURL("image/png");
//   }
// }</PRE></DIV><DIV class="paragraph code-paragraph collapsed" last-execution-state="success" name="Local File System for Upload Assets (unfinished)" style draggable="false" data-id="ZbWviw3z" __wid="hu3s2GLx"><PRE data-type="content" type="text/javascript" __wid="tNSHsmDw">// https://developer.mozilla.org/en-US/docs/Web/API/File_and_Directory_Entries_API/Introduction

const requestedBytes = 1024 * 1024 * 100; // 100MB

//Taking care of the browser-specific prefix
window.requestFileSystem = window.requestFileSystem || window.webkitRequestFileSystem;

const errorHandler = (error) => {
  var msg = "";

  switch (error.code) {
  case FileError.QUOTA_EXCEEDED_ERR:
    msg = "QUOTA_EXCEEDED_ERR";
    break;
  case FileError.NOT_FOUND_ERR:
    msg = "NOT_FOUND_ERR";
    break;
  case FileError.SECURITY_ERR:
    msg = "SECURITY_ERR";
    break;
  case FileError.INVALID_MODIFICATION_ERR:
    msg = "INVALID_MODIFICATION_ERR";
    break;
  case FileError.INVALID_STATE_ERR:
    msg = "INVALID_STATE_ERR";
    break;
  default:
    msg = "Unknown Error";
    break;
  }

  console.error(`Error: ${msg}`, error);
};

const writeFile = async(fs, name, content, type = "text/plain") => {
  return new Promise((resolve, reject) => {
    fs.root.getFile(name, {
      create: true
    }, function (fileEntry) {

      // Create a FileWriter object for our FileEntry (log.txt).
      fileEntry.createWriter(function (fileWriter) {

        fileWriter.onwriteend = function (e) {
          console.log('Write completed.');
					resolve(e);
        };

        fileWriter.onerror = function (e) {
          console.log('Write failed: ' + e.toString());
					reject(e);
        };

        // Create a new Blob and write it to log.txt.
        var blob = new Blob([content], {
          type
        });

        fileWriter.write(blob);

      }, errorHandler);

    }, errorHandler);
  });
};

// read file
const readFile = async(fs, name) => {
  return new Promise((resolve, reject) => {
    fs.root.getFile(name, {}, (fileEntry) => {

      // Get a File object representing the file,
      // then use FileReader to read its contents.
      fileEntry.file((file) => {
        var reader = new FileReader();

        reader.onloadend = function (e) {
//           var txtArea = document.createElement('textarea');
//           txtArea.value = this.result;
//           document.body.appendChild(txtArea);
					resolve(this.result);
        };

// 				// this was not part of the example and might not work
//         reader.onerror = function (e) {
//           console.log('Read failed: ' + e.toString());
// 					reject(e);
//         };

        reader.readAsText(file);
      }, errorHandler);
    }, errorHandler);
  });
};

/**
 * name - the unique name assigned by the browser to the file system.
 * root - the read-only DirectoryEntry object representing the root of the file system.
 */
const onInitFs = (fs) => {
  console.log(fs);
	
	(async() => {
		let fileName = "foobar.txt";
		let content = "hello world"
		await writeFile(fs, fileName, content);
		let fileContent = await readFile(fs, fileName);
		
		console.log(`"${content}" === "${fileContent}"`, content === fileContent);
	})();
};

// The first parameter defines the type of storage: persistent or temporary
// Next, set the size of space needed (in bytes)
// initFs is the success callback
// And the last one is the error callback
// for denial of access and other errors. 
window.requestFileSystem(window.TEMPORARY, requestedBytes, onInitFs, errorHandler);</PRE></DIV></DIV><DIV class="section section-hidden" name="Invite" data-group="basic" data-type="system" data-id="fTSh2aVG" __wid="KAdjwvxH"><DIV class="paragraph body-paragraph locked collapsed" name="Documentation" data-id="WnFasvew" __wid="rmPwh7hu"><DIV data-type="content" type="text/html" codemirror="true" contenteditable="false" class="section-documentation" __wid="8DpCiHqq"><H2 __wid="xrFS2kD6">Description</H2><DIV __wid="YiVX28K5">TODO</DIV></DIV></DIV><DIV class="paragraph data-paragraph locked collapsed" name="Properties" data-id="ac7xbVfV" __wid="ykktZSni"><PRE data-type="content" type="application/json" class="section-properties" contenteditable="false" __wid="zw4r7Wbc">{
	"version": "1.0",
	"dependencies": [
		{
			"id": "4MdLqZhf",
			"name": "Toast Messages (experimental)"
		}
	],
	"description": "Lorem ipsum",
	"changelog":
	{
		"1.0": "Initial Release"
	}
}</PRE></DIV>

<DIV class="paragraph body-paragraph locked collapsed" style data-id="yAiQEXg3" name="Invitation Template" __wid="QBqVkhYL"><DIV data-type="content" type="text/html" codemirror="true" contenteditable="false" id="invitation" __wid="NqDCaaiF"><DIV class="invite" __wid="HZufSawe">
  <DIV class="user" __wid="rkniY72h">
    <DIV class="avatar" style="background-image: url(&quot;unknown.jpg&quot;);" __wid="UYJvPEBF"></DIV>
    <DIV class="username" __wid="2Zm7MwCC">Ano Nymous</DIV>
  </DIV>
  <DIV class="content" __wid="K2NXUUqh">
    <DIV class="subject" __wid="Dwyb8TAG">Subject</DIV>
    <DIV class="message" __wid="3PQtjKqB">Message</DIV>
  </DIV>
</DIV>

<TEMPLATE id="invite-template" __wid="xQAKNs8B">
	<DIV class="invite" __wid="gGgwDxJe">
		<DIV class="user" __wid="FPbFC3A8">
			<DIV class="avatar" style="background-image: url(&quot;unknown.jpg&quot;);" __wid="j4RnNdbx"></DIV>
			<DIV class="username" __wid="kQU4s7jd">Ano Nymous</DIV>
		</DIV>
		<DIV class="content" __wid="jARc6rW9">
			<DIV class="subject" __wid="BfpVLfiV">Subject</DIV>
			<DIV class="message" __wid="vbU2Qgax">Message</DIV>
		</DIV>
	</DIV>
</TEMPLATE></DIV></DIV><DIV class="paragraph style-paragraph collapsed" draggable="false" style name="Invitation" data-id="UWmGSTWG" __wid="Dj2fpztA"><STYLE data-type="content" type="text/css" codemirror="true" __wid="HEtYKv7Z">#invitation {
	color: black;
	background-color: white;
}

.invite {
	display: flex;
}

.invite .user {
	display: flex;
	flex-direction: column;
	align-items: center;
}

.invite .user .avatar {
	box-sizing: border-box;
	width: 50px;
	height: 50px;
	border-radius: 50%;
	background-size: contain;
	border: 2px solid white;
	border-color: hotpink;
	box-shadow: 0 0 5px black;
}

.invite .user .username {
	font-size: .6em;
}

.invite .content {
	margin-left: 15px;
}

.invite .content .subject {
	font-weight: bold;
}

.invite .content .message {
}</STYLE></DIV><DIV class="paragraph code-paragraph collapsed" style run-on-load="true" last-execution-state="success" name="Add invite to Global Menu" draggable="false" data-id="CkAQMwqs" __wid="A6AVBLQg"><PRE data-type="content" type="text/javascript" __wid="zN95ZEQj">const GlobalMenuUtils = require('#global-menu-utils');

// invite template
const inviteTemplate = document.querySelector('#invite-template');

webstrate.off("messageReceived");
webstrate.on("messageReceived", (message, senderId, messageId) => {

  if (message.__class__ === "codestrate" && message.type === "invite") {
    let {
      invite
    } = message;

    let fragment = document.importNode(inviteTemplate.content, true);

    let avatarElement = fragment.querySelector('.avatar');
    let usernameElement = fragment.querySelector('.username');
    let subjectElement = fragment.querySelector('.subject');
    let messageElement = fragment.querySelector('.message');

    avatarElement.style.backgroundImage = `url(${invite.avatarUrl || 'unknown.jpg'})`;
    avatarElement.style.borderColor = invite.userColor;
    usernameElement.innerHTML = invite.username;
    subjectElement.innerHTML = "Invitation";
    messageElement.innerHTML = `${invite.username} invites you to a codestrate. Click on &lt;a href="/${invite.webstrateId}/">this&lt;/a> link to open the codestrate!`;

    toast(fragment);
  }
});

const inviteAction = document.createElement("button");
inviteAction.innerHTML = "Invite to codestrate";
inviteAction.addEventListener("click", (event) => {

  (async() => {
    let receiver = await prompt("Send invite to a user or multiple users [comma separated list of user ids]", "", "Invite to codestrate");
    if (receiver) {
      let receivers = receiver.split(',');

      // get client color
      let ClientManager = require('#client-manager');
      let client = ClientManager.getClient();

      let username = webstrate.user.displayName || webstrate.user.username;
      let avatarUrl = webstrate.user.avatarUrl;
      let userColor = client.color;
      let webstrateId = webstrate.webstrateId;

      webstrate.message({
        __class__: "codestrate",
        type: "invite",
        invite: {
          username,
          avatarUrl,
          userColor,
          webstrateId
        }
      }, receivers);
    }
  })();
});

GlobalMenuUtils.addMenuItem(inviteAction);</PRE></DIV></DIV><DIV class="section section-hidden" data-id="33LePuGS" name="Help Dialog" data-type="system" __wid="LaJSjGVS"><DIV class="paragraph body-paragraph locked" data-id="wcNnbcmy" draggable="false" style name="Documentation" __wid="3aU7dgzi"><DIV data-type="content" type="text/html" codemirror="true" contenteditable="false" class="section-documentation" __wid="Z9dxfW3H"><H2 __wid="jS4nH7Et">Description</H2><DIV __wid="dxqfqMvH">Adds a help dialog, which can be opend pressing "F1" or using the "Help" entry in the global menu. The help dialog shows shortcuts and an introductory video about Codestrates.</DIV></DIV></DIV><DIV class="paragraph data-paragraph locked collapsed" data-id="Ji9ezFPZ" draggable="false" style name="Properties" __wid="w5AKt2zJ"><PRE data-type="content" type="application/json" class="section-properties" contenteditable="false" __wid="5M2vz78Z">{
	"version": "1.0",
	"description": "Shows a help dialog with shortcuts and introductory video.",
	"changelog":
	{
		"1.0": "Initital Release"
	}
}</PRE></DIV><DIV class="paragraph code-paragraph collapsed" data-id="xd63C8ye" draggable="false" style name="Shortcuts PC" __wid="eSQUDsB5"><PRE data-type="content" type="text/javascript" id="shortcuts-pc" __wid="hCpnJWpn">exports.shortcuts = {
	"F1": "This help menu",
	"Shift + Alt + F": "Formats content in a code paragraph",
	"Shift + Tab": "Formats selected content in code paragraphs",
	"Ctrl + F": "Search in a code paragraph",
	"Ctrl + S": "Saves HTML in body paragraph when editing through the HTML editor"
};</PRE></DIV><DIV class="paragraph code-paragraph collapsed" data-id="DptM4BZ7" draggable="false" style name="Shortcuts Mac" __wid="HDCdcbh6"><PRE data-type="content" type="text/javascript" id="shortcuts-mac" __wid="sxQAgk8V">exports.shortcuts = {
	"F1": "This help menu",
	"Shift + Alt + F": "Formats content in a code paragraph",
	"Shift + Tab": "Formats selected content in code paragraphs",
	"Cmd + F": "Search in a code paragraph",
	"Cmd + S": "Saves HTML in body paragraph when editing through the HTML editor"
};</PRE></DIV><DIV class="paragraph code-paragraph collapsed" data-id="wNKv7kCW" run-on-load="true" last-execution-state="success" name="Help Dialog Code" style __wid="zrHM5jjd"><PRE data-type="content" type="text/javascript" __wid="hZN3DtZb">const GlobalMenuUtils = require('#global-menu-utils');

const getOSShortcuts = () => {
  if (Codestrate.OS.isMac()) {
    return require('#shortcuts-mac', null, false).shortcuts;
  }
  return require('#shortcuts-pc', null, false).shortcuts;
};

const videoUrl = "Codestrates.mp4";

/////////////////////////////////////////////////////////////////////////////////////////////////////

importLib([
  "mousetrap.min.js",
  "mousetrap-global-bind.min.js"
]).then(() => {
	
	/**
	 * Toggles help menu.
	 */
	const toggleHelp = () => {
		const helpDialog = document.querySelector("#help");
    if (helpDialog) {
      const transient = helpDialog.parentElement;
      transient.remove();
    } else {
      showHelpDialog();
    }
	};

  const createButton = (name, classNames, action) => {
    const button = document.createElement("button");
    button.innerText = name;

    if (classNames) {
      button.setAttribute("class", classNames);
    }

    if (typeof action === 'function') {
      button.addEventListener("click", action);
    }

    return button;
  };

  let createHelpButton = createButton("Help", null, () => {
		GlobalMenuUtils.close();
		toggleHelp();
  });

	GlobalMenuUtils.addDivider();
  GlobalMenuUtils.addMenuItem(createHelpButton);

  Mousetrap.bindGlobal('f1', function (event) {
    toggleHelp();
    return false;
  });

  const showHelpDialog = (packageStati) => {

    let shortcuts = getOSShortcuts();

    return new Promise((resolve, reject) => {

      const transient = document.createElement("transient");

      const elements = require("#help-dialog-template", {
        id: "help",
        shortcuts: `${Object.keys(shortcuts).map(key => `&lt;li>
&lt;span class="key">${key}&lt;/span>
&lt;span class="action">${shortcuts[key]}&lt;/span>
&lt;/li>`).join("")}`,
        videoUrl: videoUrl
      });

      elements.forEach(e => transient.appendChild(e));

      const closeBtn = transient.querySelector(".close");

      const onClose = () => {
        transient.remove();
        resolve(true);
      };

      closeBtn.addEventListener("click", onClose);

      document.body.appendChild(transient);
    });
  };
});</PRE></DIV><DIV class="paragraph body-paragraph collapsed" data-id="7JzGxgXn" draggable="false" style name="Help Dialog Template" __wid="hQwZihc3"><DIV data-type="content" type="text/html" codemirror="true" contenteditable="true" id="help-dialog-template" __wid="k5GCAA2x"><DIV class="modal" __wid="LxSMpCtx"></DIV>
<DIV class="dialog" id="${id}" __wid="Y6jFcJUP">
	<DIV class="title" __wid="aN5WSDD4">Help</DIV>
	<DIV class="body" __wid="9Ln23FfS">
		<DIV class="intro" __wid="wFvACsYm">
			Codestrates is a research prototype for developing webstrates in a literate computing inspired fashion. It is still under heavy development, and may features are still experimental and undocumented. Below is a short list of the keyboard shortcuts available and a brief intro screencast to the basic features of Codestrates.<BR __wid="irL63erH"/><BR __wid="DRmtjqjZ"/>
			Visit <A href="https://webstrates.github.io" __wid="CkUf2FdW">webtrates.github.io</A> for the documentation of <A href="http://webstrates.net" __wid="WVgExjxM">Webstrates</A> and for more information about Codestrates visit <A href="http://codestrates.org" __wid="r8PXvJw7">codestrates.org</A>.
		</DIV>
		<DIV id="shortcuts" __wid="ThB7HWgg">
			<DIV class="help-title" __wid="yWtLLAmH">Shortcuts</DIV>
			<UL __wid="cqwRY7we">${shortcuts}</UL>
		</DIV>
		<DIV id="intro" __wid="ri6RqgbL">
			<DIV class="help-title" __wid="MZ5CpLcb">Introduction video</DIV>
			<DIV class="video" __wid="PZcE46rr">
				<IFRAME width="560" height="315" src="https://www.youtube.com/embed/7HedZZoFC-s?rel=0&showinfo=0" frameborder="0" allowfullscreen __wid="QQunvfZu"></IFRAME>	
			</DIV>
		</DIV>
	</DIV>
	<DIV class="actions" __wid="qzWfW7RW">
		<DIV class="button close" __wid="PgZs6ywd">Close</DIV>
	</DIV>
</DIV></DIV></DIV><DIV class="paragraph style-paragraph collapsed" data-id="M5jKghq9" style name="Help Dialog Style" __wid="VJvWwCud"><STYLE data-type="content" type="text/css" codemirror="true" __wid="Ym9jzmiG">#help {
	z-index: 999999;
	top: 50px;
}


#help a {
	color: white;
}

#help .body {
	width: 90vw;
	max-height: calc(100vh - 180px);
}

#help .help-title {
	font-size: 24px;
	margin-bottom: 12px;
}

#shortcuts {
    width: 33%;
    float: left;
}

#intro {
    margin-left: 35%;
}

#intro .video {
	width: 100%;
	text-align: center;
}

#shortcuts li {
	margin-bottom: 16px;
}

#shortcuts .key {
	margin: 0 5px 0 0;
	color: #eee;
	border-radius: 3px;
	padding: 3px 7px;
	min-width: 1em;
	box-shadow: inset 0 0 2px #5a5a5a, 0 0.1em 0.11em rgba(0,0,0,.9);
	cursor: default;
	background: #000;
	text-align: center;
	text-shadow: none;
	background-color: #101010;
	background-repeat: repeat-x;
	font-family: monospace;
	font-size: 14px;
}

#shortcuts .action {
	line-height: 150%;
}</STYLE></DIV></DIV><DIV class="section section-hidden" name="Section Browser" data-type="system" data-group="editing" data-id="4CsvECcC" __wid="sue3s4a6"><DIV class="paragraph body-paragraph locked" draggable="false" name="Documentation" style data-id="eRw5qerB" __wid="ZEiYRtgL"><DIV data-type="content" type="text/html" codemirror="true" contenteditable="false" class="section-documentation" __wid="BvjGXaYg"><H2 __wid="43ch6GCj">Description</H2><DIV __wid="NnigAjtr">This is a prototype implementation of a section browser in the side menu.</DIV><H2 __wid="tmHQJRVN">Usage</H2><DIV __wid="zxLgTSxW"><UL __wid="MNPiz9tv"><LI __wid="uV2tQ6gb">Click sections to expand/collapse</LI><LI __wid="LaQnVAte">Click paragraph to scroll them into view</LI><LI __wid="ZwNmXhpX">Click section eye to toggle visbility</LI></UL><H2 __wid="uHEqa7Wb">Bugs, ideas and ToDo</H2></DIV><DIV __wid="y64QrCFn"><UL __wid="YSnR9qiM"><LI __wid="MsjiNcFG"><STRIKE __wid="Qm8KcMSq">Refresh CodeMirror instances on visibility change</STRIKE></LI><LI __wid="RJxwtarm"><STRIKE __wid="xrVUGt6x">Toggle visibility and expand paragraph when clicking a paragraph</STRIKE></LI><LI __wid="yppcugCQ">Integrate properly in Roman's sidebar code<BR __wid="FvnQNB57"/></LI><LI __wid="FD47XZcx"><STRIKE __wid="SYbMF4M7">Overflow of sections with many paragraphs. Scrolling?</STRIKE></LI><LI __wid="scqB5pJQ">Disable scrolling of main window when scrolling in section tree. But how?</LI></UL></DIV></DIV></DIV><DIV class="paragraph data-paragraph locked collapsed" name="Properties" data-id="b24ajcq7" __wid="Qjps68Hu"><PRE data-type="content" type="application/json" class="section-properties" contenteditable="false" __wid="wfjh5mLH">{
	"version": "1.0",
	"description": "This is a prototype implementation of a section browser in the side menu.",
	"changelog":
	{
		"1.0": "Initital Release"
	}
}</PRE></DIV>

<DIV class="paragraph body-paragraph collapsed" draggable="false" name="Description" style data-id="srnWpw3v" __wid="b5jJHBXj"><DIV data-type="content" type="text/html" codemirror="true" contenteditable="true" __wid="qZhyxWa8"><H1 __wid="EMa2EzQR">Section browser</H1><DIV __wid="kMiwSAYW">This is a prototype implementation of a section browser in the side menu.</DIV><DIV __wid="UyKhiC3J"><BR __wid="dpCnrmEF"/></DIV><DIV __wid="ZuAguJGh">Usage:</DIV><DIV __wid="73X9qs53"><UL __wid="ntpeFHhN"><LI __wid="v7PVAckY">Click sections to expand/collapse</LI><LI __wid="3eNx8YPk">Click paragraph to scroll them into view</LI><LI __wid="krFmNrKF">Click section eye to toggle visbility</LI></UL><DIV __wid="i3d3dgLi">Bugs, ideas and ToDo</DIV></DIV><DIV __wid="6MVqLJcd"><UL __wid="DwFeyBDk"><LI __wid="mZYuzhYU"><STRIKE __wid="g26gqLAN">Refresh CodeMirror instances on visibility change</STRIKE></LI><LI __wid="RL85sknC"><STRIKE __wid="cnn28gFx">Toggle visibility and expand paragraph when clicking a paragraph</STRIKE></LI><LI __wid="twSW98FH">Integrate properly in Roman's sidebar code<BR __wid="NxMKUAqr"/></LI><LI __wid="tam4PrKh"><STRIKE __wid="MVFTKkHY">Overflow of sections with many paragraphs. Scrolling?</STRIKE></LI><LI __wid="n9AnUmjG">Disable scrolling of main window when scrolling in section tree. But how?</LI></UL></DIV></DIV></DIV><DIV class="paragraph code-paragraph collapsed" name="Global Menu Section Tree" style run-on-load="true" last-execution-state="success" draggable="false" data-id="VyGHLw6Z" __wid="fKnh6USp"><PRE data-type="content" type="text/javascript" __wid="UqdXrbHy">const GlobalMenuUtils = require('#global-menu-utils');

const sectionTree = document.createElement("ul");
sectionTree.id = "section-tree";

GlobalMenuUtils.addDivider();
GlobalMenuUtils.addMenuItem(sectionTree);</PRE></DIV><DIV class="paragraph code-paragraph collapsed" last-execution-state="success" name="Section Browser" run-on-load="true" style data-id="FDSSymJu" __wid="WG3DQEue"><PRE data-type="content" type="text/javascript" __wid="SQgjweZy">var SectionItem = function(section) {
	section.__sectionItem = this;
	this.section = section;
	// Create a list item for the section
	this.li = document.createElement("li");
	// Per default this is closed
	this.li.classList.add("closed");

	// Create an element indicating if a section is expanded or not
	this.expander = document.createElement("span");
	this.expander.classList.add("expander");
	this.expander.innerHTML = '&lt;i class="material-icons">keyboard_arrow_right&lt;/i>';
	this.li.appendChild(this.expander);

	// Create an element used for showing and toggling visibility
	this.visibility = document.createElement("span");
	this.visibility.classList.add("visibility");
	this.visibility.innerHTML = '&lt;i class="material-icons">&lt;/i>';
	this.li.appendChild(this.visibility);
	if (this.section.classList.contains("section-hidden")) {
		this.li.classList.add("hidden");
		this.visibility.firstChild.innerText = "visibility_off";
	} else {
		this.li.classList.add("visible");
		this.visibility.firstChild.innerText = "visibility";		
	}
	
	// Create an element used for showing if a section is a system section
	this.type = document.createElement("span");
	this.type.classList.add("type");
	this.type.innerHTML = '&lt;i class="material-icons">person&lt;/i>';
	this.li.appendChild(this.type);
	if (this.section.getAttribute("data-type")) {
		if (this.section.getAttribute("data-type") === "system") {
			this.type.firstChild.innerText = "extension";
		} else if (this.section.getAttribute("data-type") === "package") {
			this.type.firstChild.innerText = "build";
		}
	} else {
		this.type.firstChild.innerText = "person";
	}
	
	// Create the title of a section
	this.title = document.createElement("span");
	this.title.classList.add("title");
	var sectionName = this.section.getAttribute("name");
	this.title.innerText = sectionName && sectionName.length > 0 ? sectionName : "No Name";	
	this.li.appendChild(this.title);

	// Create the list of paragraphs
	this.ul = document.createElement("ul");
	this.li.appendChild(this.ul);
	
	// Create all the paragraph objects
	this.createParagraphItems();
	
	// When clicking the list item it toggles open/clised
	this.li.addEventListener("click", (e) => {
		this.li.classList.toggle("closed");
		if (this.li.classList.contains("closed")) {
				this.expander.innerHTML = '&lt;i class="material-icons">keyboard_arrow_right&lt;/i>';
		} else {
				this.expander.innerHTML = '&lt;i class="material-icons">keyboard_arrow_down&lt;/i>';
		}
	});
	
	// If the visibility icon is clicked, visibility of the section is toggled
	this.visibility.addEventListener("click", (e) => {
		e.stopPropagation();
		this.section.classList.toggle("section-hidden");
		this.section.classList.toggle("section-visible");
	});
	
	// A mutation observer is used to observe changes to attributes and children
	this.mo = new MutationObserver(() => {
		this.ul.innerHTML = "";
		var sectionName = this.section.getAttribute("name");
		this.title.innerText = sectionName && sectionName.length > 0 ? sectionName : "No Name";	
		if (this.section.classList.contains("section-hidden")) {
			this.li.classList.add("hidden");	
			this.visibility.firstChild.innerText = "visibility_off";
		} else {
			this.li.classList.remove("hidden");	
			this.visibility.firstChild.innerText = "visibility";
			
			// CodeMirror requires a refresh on the editor if any of the parent or
    	// container styles changed.
    	var contents = Array.from(this.section.querySelectorAll('.paragraph:not(.collapsed) [data-type="content"]'));
      
      contents.forEach(content => {
        if (content && content.__editor && content.__editor.editor) {
          content.__editor.editor.refresh();
        }
			});
		}
		if (this.section.getAttribute("data-type")) {
			if (this.section.getAttribute("data-type") === "system") {
				this.type.firstChild.innerText = "extension";
			} else if (this.section.getAttribute("data-type") === "package") {
				this.type.firstChild.innerText = "build";
			}
		} else {
			this.type.firstChild.innerText = "person";
		}
		this.createParagraphItems();
	});
	
	this.mo.observe(this.section, {attributes: true, childList: true});
};

SectionItem.prototype.createParagraphItems = function() {
	Array.from(this.section.querySelectorAll(".paragraph")).forEach((paragraph) => {
		var paragraphItem = new ParagraphItem(paragraph);
		this.ul.appendChild(paragraphItem.li);
	});
};

var ParagraphItem = function(paragraph) {
	paragraph.__paragraphItem = this;
	this.paragraph = paragraph;
	
	// Create a list item for the paragraph
	this.li = document.createElement("li");
	
	// Create an element for showing and toggling collapse
	this.collapse = document.createElement("span");
	this.collapse.innerHTML = '&lt;i class="material-icons">&lt;/i>';
	this.collapse.classList.add("collapse");
	this.li.appendChild(this.collapse);
	if (this.paragraph.classList.contains("collapsed")) {
		this.collapse.firstChild.innerText = "radio_button_unchecked";
	} else {
		this.collapse.firstChild.innerText = "radio_button_checked";		
	}
	
	// Create an element for the title of the paragraph
	this.title = document.createElement("span");
	this.title.classList.add("title");
	this.title.innerText = paragraph.getAttribute("name");
	this.li.appendChild(this.title);
	
	// Observe changes to the attributes of the paragraph
	this.mo = new MutationObserver(() => {
		this.title.innerText = paragraph.getAttribute("name");
		if (this.paragraph.classList.contains("collapsed")) {
			this.collapse.firstChild.innerText = "radio_button_unchecked";
		} else {	
			this.collapse.firstChild.innerText = "radio_button_checked";
		}
	});
	
	this.mo.observe(this.paragraph, {attributes: true});
	
	// If the paragraph is clicked, scroll it into view
	this.li.addEventListener("click", (e) => {
		e.stopPropagation();
		this.paragraph.classList.remove("collapsed");
		this.paragraph.closest(".section").classList.remove("section-hidden");
		this.paragraph.scrollIntoView();
	});
	
	// If the visibility icon is clicked, visibility of the section is toggled
	this.collapse.addEventListener("click", (e) => {
		e.stopPropagation();
		this.paragraph.classList.toggle("collapsed");
	});
};

var tree = document.querySelector("#global-menu #section-tree");
var sections = Array.from(document.querySelectorAll(".section"));

tree.innerHTML = "";

sections.forEach((section) => {
	var sectionItem = new SectionItem(section);
	tree.appendChild(sectionItem.li);
});</PRE></DIV></DIV><DIV class="section section-hidden" name="Main Theme" data-type="system" data-group="basic" data-id="PJGnfYsy" __wid="vaJGVjXs"><DIV class="paragraph body-paragraph locked" draggable="false" name="Documentation" data-id="5B8NDkAt" __wid="vFqZPbqF"><DIV data-type="content" type="text/html" codemirror="true" contenteditable="false" class="section-documentation" __wid="SKfiUQ2A"><H2 __wid="vADsSAm2">Description</H2><DIV __wid="gvXZv8i2">Over time, we'll collect all styles here that are neceertetssary for a particular theme. Then, whenever we want to create a new codestrate theme, it will just be a derivate of the main theme.</DIV></DIV></DIV><DIV class="paragraph data-paragraph locked collapsed" name="Properties" data-id="Cdg8V6VB" __wid="Ag2mZDjf"><PRE data-type="content" type="application/json" class="section-properties" contenteditable="false" __wid="KnesHrA9">{
	"version": "1.0",
	"description": "Lorem ipsum",
	"changelog":
	{
		"1.0": "Initital Release"
	}
}</PRE></DIV>

<DIV class="paragraph code-paragraph collapsed" name="Load Style (material-icons.css)" run-on-load="true" draggable="false" style last-execution-state="success" data-id="T34VfSAE" __wid="pFLEB77h"><PRE data-type="content" type="text/javascript" __wid="zcy6Acdw">importStyle("material-icons.css");</PRE></DIV><DIV class="paragraph style-paragraph collapsed" name="Main" draggable="false" style data-id="5uBKHKzL" __wid="dCLmxTRF"><STYLE data-type="content" type="text/css" codemirror="true" __wid="MkgxmMLm">html:not([transient-theme]),
html:not([transient-theme]) * {
  box-sizing: border-box;
}

html:not([transient-theme]),
html:not([transient-theme]) input,
html:not([transient-theme]) button {
  font-family: Avenir, Roboto, Arial, sans-serif;
}

html:not([transient-theme]) {
  width: 100%;
  margin: 0;
  background-color: rgb(48, 48, 48);
/* 	background-color: hotpink; */
  
  color: gainsboro;
  font-family: Avenir, Roboto, Arial, sans-serif;
}

html:not([transient-theme]) body {
  margin: 0 auto;
	position: relative;
  width: 60em;
	max-width: 100vw;
	padding: 0;
	overflow: hidden;
	overflow-y: auto;
}

/* iPhone media query */
@media only screen 
and (min-device-width : 375px) 
and (max-device-width : 667px) {
	html:not([transient-theme]) body {
		width: 100vw;
	}
}

/* Fix Chrome setting h1 font-size to 1.17em in paragraphs within sections */
html:not([transient-theme]) h1 {
  font-size: 2em;
}</STYLE></DIV><DIV class="paragraph style-paragraph collapsed" draggable="false" name="Loading / Disconnected" style data-id="c8dz5get" __wid="CpEXTQWq"><STYLE data-type="content" type="text/css" codemirror="true" __wid="kAr5iDn5">@-webkit-keyframes rotateplane {
  0% {
    -webkit-transform: perspective(120px);
  }
  50% {
    -webkit-transform: perspective(120px) rotateY(180deg);
  }
  100% {
    -webkit-transform: perspective(120px) rotateY(180deg) rotateX(180deg);
  }
}

@-moz-keyframes rotateplane {
  0% {
    -moz-transform: perspective(120px);
  }
  50% {
    -moz-transform: perspective(120px) rotateY(180deg);
  }
  100% {
    -moz-transform: perspective(120px) rotateY(180deg) rotateX(180deg);
  }
}

@-o-keyframes rotateplane {
  0% {
    -o-transform: perspective(120px);
  }
  50% {
    -o-transform: perspective(120px) rotateY(180deg);
  }
  100% {
    -o-transform: perspective(120px) rotateY(180deg) rotateX(180deg);
  }
}

@keyframes rotateplane {
  0% {
    -webkit-transform: perspective(120px) rotateX(0deg) rotateY(0deg);
    -moz-transform: perspective(120px) rotateX(0deg) rotateY(0deg);
    -o-transform: perspective(120px) rotateX(0deg) rotateY(0deg);
    transform: perspective(120px) rotateX(0deg) rotateY(0deg);
  }
  50% {
    -webkit-transform: perspective(120px) rotateX(-180.1deg) rotateY(0deg);
    -moz-transform: perspective(120px) rotateX(-180.1deg) rotateY(0deg);
    -o-transform: perspective(120px) rotateX(-180.1deg) rotateY(0deg);
    transform: perspective(120px) rotateX(-180.1deg) rotateY(0deg);
  }
  100% {
    -webkit-transform: perspective(120px) rotateX(-180deg) rotateY(-179.9deg);
    -moz-transform: perspective(120px) rotateX(-180deg) rotateY(-179.9deg);
    -o-transform: perspective(120px) rotateX(-180deg) rotateY(-179.9deg);
    transform: perspective(120px) rotateX(-180deg) rotateY(-179.9deg);
  }
}

html:not([transient-theme]) .overlay {
  position: fixed;
  display: block;
  top: 0;
  left: 0;
  bottom: 0;
  right: 0;
  /*background: rgba(255, 255, 255, .5);*/
/*  background: white;*/
  background: rgba(48, 48, 48, 1.0);
  width: 100vw;
  height: 100vh;
  z-index: 1000;
}

html:not([transient-theme]) .overlay>div {
  position: relative;
  display: inline-block;
  left: 50%;
  top: 50%;
  transform: translate3d(-50%, -50%, 0);
}

html:not([transient-theme]) .overlay>div:after {
  position: absolute;
  top: 100%;
  left: 50%;
  width: 200px;
  transform: translate3d(-50%, 0, 0);
  text-align: center;
}

html:not([transient-theme]) .overlay>div>div {
  position: relative;
  display: inline-block;
  top: 0;
  left: 0;
  width: 50px;
  height: 50px;
  border-radius: 2px;
  background: rgba(255, 255, 255, .5);
  /*margin: auto;*/
  -webkit-animation: rotateplane 1.2s infinite ease-in-out;
  -moz-animation: rotateplane 1.2s infinite ease-in-out;
  -o-animation: rotateplane 1.2s infinite ease-in-out;
  animation: rotateplane 1.2s infinite ease-in-out;
}

html:not([transient-theme]) .overlay.loading>div:after {
  content: "Loading";
}

html:not([transient-theme]) .overlay.disconnected>div:after {
  content: "Disconnected";
}</STYLE></DIV><DIV class="paragraph style-paragraph collapsed" draggable="false" name="Scrollbars" data-id="aReAMqZa" __wid="zF3ujyV7"><STYLE data-type="content" type="text/css" codemirror="true" __wid="WA7RUhCK">html:not([transient-theme]) *::-webkit-scrollbar {
	width: 5px;  /* remove scrollbar space */
	height: 5px;
	background: transparent;  /* optional: just make scrollbar invisible */
	border-radius: 10px;
	margin-left: 20px;
}

html:not([transient-theme]) *::-webkit-scrollbar-track {
	background-color: rgba(255, 255, 255, .1);
	border-radius: 10px;
/* 	border: 1px solid rgba(255, 255, 255, .3); */
}

/* optional: show position indicator in red */
html:not([transient-theme]) *::-webkit-scrollbar-thumb {
	border-radius: 10px;
	background-color: transparent;
	background-color: transparent;
}

html:not([transient-theme]) *::-webkit-scrollbar-thumb {
	background-color: white;
}</STYLE></DIV><DIV class="paragraph style-paragraph collapsed" name="Global Menu" draggable="false" data-id="wckGBv9N" __wid="gzxXJUAp"><STYLE data-type="content" type="text/css" codemirror="true" __wid="UHKySygd">html:not([transient-theme]) #global-menu {
	position: fixed;
	top: 0;
	left: 0;
	bottom: 0;
	width: 300px;
	height: 100vh;
	z-index: 100;
	transition: transform 500ms ease-in-out 0s;
	
	background-color: rgba(20, 20, 20, 1.0);
}

html:not([transient-theme]) #global-menu.closed {
	transform: translate3d(-100%, 0, 0);
}

/* Open menu on hover handle */
html:not([transient-theme]) #global-menu:hover {
	transform: none;
}

html:not([transient-theme]) #global-menu .handle {
	position: absolute;
	right: 0;
	top: 50%;
	transform: translate3d(100%, -50%, 0) rotate(-90deg);
	cursor: pointer;
}

html:not([transient-theme]) #global-menu .handle:after {
	font-family: 'Material Icons';
	font-weight: normal;
	font-style: normal;
	font-size: 24px;
	display: inline-block;
	line-height: 1;
	text-transform: none;
	letter-spacing: normal;
	word-wrap: normal;
	white-space: nowrap;
	direction: ltr;
	-webkit-font-smoothing: antialiased;
	text-rendering: optimizeLegibility;
	-moz-osx-font-smoothing: grayscale;
	font-feature-settings: 'liga';
	
	content: "drag_handle";
	font-size: 1.6em;
	background: rgba(20, 20, 20, 1.0);
	margin-right: 4px;
	border-bottom-right-radius: 2px;
	border-bottom-left-radius: 2px;
}

html:not([transient-theme]) #global-menu .content {
	display: flex;
	flex-direction: column;
	width: 100%;
	height: 100vh;
	
	overflow: hidden;
	overflow-y: auto;	
  flex-wrap: nowrap;
  -webkit-overflow-scrolling: touch;
}

html:not([transient-theme]) #global-menu .content hr {
	border-top: 1px solid #333;
	border-left: none;
	border-right: none;
	border-bottom: 1px solid #111;
	height: 0px;
	width: calc(100% - 30px);
}

html:not([transient-theme]) #global-menu .content button {
	display: block;
	font-size: 0.9em;
	min-height: 20px;
	background-color: transparent;
	border: none;
	color: white;
	margin-top: 5px;
	margin-bottom: 5px;
	text-align: left;
	cursor: pointer;
}

html:not([transient-theme]) #global-menu .content button:hover {
	color: orange;  
}

html:not([transient-theme]) #global-menu .content button:focus {
	outline: none;  
}

html:not([transient-theme]) #global-menu i.material-icons {
    display: initial;
}</STYLE></DIV><DIV class="paragraph style-paragraph collapsed" draggable="false" name="Carousel" data-id="5RyWnSLX" __wid="tFqbqp6d"><STYLE data-type="content" type="text/css" codemirror="true" __wid="5eFbVJ6R">html:not([transient-theme]) #paragraph-carousel {
	position: fixed;
	right: 0;
	top: 0;
	max-height: 100vh;
	z-index: 100;
	opacity: 0;
	
	overflow: hidden;
	overflow-y: auto;
	
	transform: translate3d(calc(100% - 20px), 0, 0);
	transition: transform 250ms ease-in-out, opacity 250ms ease-in-out;
}

/* Hide scrollbar */
html:not([transient-theme]) #paragraph-carousel::-webkit-scrollbar {
	width: 0px;  /* remove scrollbar space */
	background: transparent;  /* optional: just make scrollbar invisible */
}

html:not([transient-theme]) #paragraph-carousel:hover {
	transform: translate3d(-5px, 0, 0);
	opacity: 1.0;
}

html:not([transient-theme]) .paragraph-prototype {
	width: 180px;
	height: 65px;
	border-radius: 2px;
	color: black;
	background-color: white;
	padding: 10px;
	margin: 5px 0;
	transform: translate3d(20px, 0, 0);
	transition: transform 250ms ease-in-out;
	cursor: pointer;
	
	box-shadow: 0px 0px 5px black;
	
	user-select: none;
	-webkit-user-select: none;
	-moz-user-select: none;
	-ms-user-select: none;
}

html:not([transient-theme]) .paragraph-prototype:hover {
	transform: translate3d(10px, 0, 0);
}

html:not([transient-theme]) .paragraph-prototype i {
	font-size: 1.2em;
}

html:not([transient-theme]) .paragraph-prototype .template {
	display: none;
}

html:not([transient-theme]) .drop-indicator {
	display: block;
/* 	position: absolute; */
	width: calc(100% + 10px);
	margin-left: -5px;
	
	height: 5px;
	background-color: rgba(255, 255, 255, .9);
}

/* html[transient-dragging="true"],
html[transient-dragging="true"] body {
	background-color: orange;
} */

html:not([transient-theme])[transient-dragging="true"] .paragraph > *:not(#carousel-definitions) {
	pointer-events: none;
}</STYLE></DIV><DIV class="paragraph style-paragraph collapsed" name="Dialogs" draggable="false" data-id="L4rzUGdH" __wid="pNVUpWdS"><STYLE data-type="content" type="text/css" codemirror="true" __wid="rtymrFQS">html:not([transient-theme]) .dialog {
	display: flex;
	flex-direction: column;
	position: fixed;
	top: 100px;
	left: 50%;
	min-width: 400px;
	max-width: calc(100vw - 20px);
/* 	height: 200px; */
	background-color: white;
	z-index: 1001;
	transform: translate3d(-50%, 0, 0);
	box-shadow: 0 5px 15px rgba(0, 0, 0, .5);
	border-radius: 2px;
}

html:not([transient-theme]) .dialog .button {
	display: inline;
	padding: 5px 15px;
	background-color: rgba(255, 255, 255, .2);
	cursor: pointer;
	border-radius: 2px;
	user-select: none;
}

html:not([transient-theme]) .dialog .button:hover {
	background-color: rgba(255, 255, 255, .3);
}

html:not([transient-theme]) .dialog .title,
html:not([transient-theme]) .dialog .body {
	padding: 5px;
/* 	pointer-events: none; */
}

html:not([transient-theme]) .dialog .body > * {
	margin-bottom: 10px;
}

html:not([transient-theme]) .dialog .body input {
	width: 100%;
	font-size: 1.2em;
	padding: 5px;
	outline: 0;
	color: white;
	background-color: transparent;
	border: 0;
	border-bottom: 1px solid rgba(255, 255, 255, .3);
}

html:not([transient-theme]) .dialog .body input:focus {
	border-bottom-color: rgba(255, 255, 255, 1.0);
}

html:not([transient-theme]) .dialog .actions {
	padding: 10px;
}

html:not([transient-theme]) .dialog .title {
	background-color: rgba(0, 0, 0, .8);
	color: white;
	font-size: 1.2em;
}

html:not([transient-theme]) .dialog .body {
	height: 100%;
	background-color: rgba(0, 0, 0, .75);
	padding: 20px 15px;
}

html:not([transient-theme]) .dialog .actions {
	text-align: right;
	background-color: rgba(0, 0, 0, .8);
}</STYLE></DIV><DIV class="paragraph style-paragraph collapsed" name="Tooltip" draggable="false" data-id="ekcWCgH9" __wid="FJUPBFDB"><STYLE data-type="content" type="text/css" codemirror="true" __wid="QvqDjsDx">html:not([transient-theme]) .section-visible *[tooltip]:after {
	position: absolute;
	bottom: 0px;
	left: 50%;
	z-index: 98;
	padding: 5px 15px;
	color: white;
	background-color: rgba(0,0,0,.8);
	border-radius: 2px;
	display: inline;
	width: 200px;
	text-align: center;
	transform: translate3d(-50%, -36px, 0);
	opacity: 0;
	pointer-events: none;
  -webkit-font-smoothing: antialiased; /* webkit text rendering fix */
}

/* Match all tooltip headers and move them down 60px */
html:not([transient-theme]) .section-visible .section-header *[tooltip]:after {
	bottom: -63px;
}
/* Match all tooltips except the first and move them back up, effectively making
   the selector only match the first tooltip header. */
html:not([transient-theme]) .section-visible ~ .section-visible *[tooltip]:after {
	bottom: 0px;
}

html:not([transient-theme]) *[tooltip]:before {
	content: "";
	border: solid;
	bottom: 0;
	border-color: rgba(0,0,0,.8) transparent;
	border-width: 6px 6px 0px 6px;
	left: 50%;
	transform: translate3d(-50%, -30px, 0);
	position: absolute;
	z-index: 99;
	opacity: 0;
	pointer-events: none;
  -webkit-font-smoothing: antialiased; /* webkit text rendering fix */
}

/* Same principle as above, except this is for the tooltip triangle which needs
   to be reversed. */
html:not([transient-theme]) .section-visible .section-header *[tooltip]:before {
	transform: translate3d(-50%, 0px, 0);
	border-width: 0px 6px 6px 6px;
}
html:not([transient-theme]) .section-visible ~ .section-visible *[tooltip]:before {
	transform: translate3d(-50%, -30px, 0);
	border-width: 6px 6px 0px 6px;
}

html:not([transient-theme]) *[tooltip]:hover:after,
html:not([transient-theme]) *[tooltip]:hover:before {
	opacity: 1.0;
	transition: opacity 200ms ease-in-out 300ms;
}</STYLE></DIV><DIV class="paragraph style-paragraph collapsed" name="Section" draggable="false" data-id="Biib7BSP" __wid="tDL4F2QE"><STYLE data-type="content" type="text/css" codemirror="true" __wid="M6hhnWKD">html:not([transient-theme]) .section {
  margin-top: 10px;
  position: relative;
}

html:not([transient-theme]) .section.section-hidden,
html:not([transient-theme]) .section.section-hidden * {
/*   position: absolute;
  visibility: hidden;
  pointer-events: none;
  height: 0; */
	display: none;
}

html:not([transient-theme]) .section .section-header {
  display: block;
  height: 36px;
  padding-top: 7px;
  padding-left: 7px;
  background: rgba(0, 0, 0, .6);
  font-size: 1.2em;
  margin-bottom: 10px;
  border-radius: 2px;
}

html:not([transient-theme]) .section .section-header .action {
	position: relative;
  float: right;
  margin-right: 10px;
  cursor: pointer;
  font-size: .6em;
}

/* Icon Add Content */
html:not([transient-theme]) .section .section-header .add-body-paragraph i:after {
	content: "text_fields";
}

/* Tooltip Add Content */
html:not([transient-theme]) .section .section-header .add-body-paragraph:after {
	content: "Add Content";
}

/* Icon Add Code */
html:not([transient-theme]) .section .section-header .add-code-paragraph i:after {
	content: "code";
}

/* Tooltip Add Code */
html:not([transient-theme]) .section .section-header .add-code-paragraph:after {
	content: "Add Code";
}

/* Icon Add Style */
html:not([transient-theme]) .section .section-header .add-style-paragraph i:after {
	content: "brush";
}

/* Tooltip Add Style */
html:not([transient-theme]) .section .section-header .add-style-paragraph:after {
	content: "Add Style";
}

/* Icon Add Data */
html:not([transient-theme]) .section .section-header .add-data-paragraph i:after {
	content: "storage";
}

/* Tooltip Add Data */
html:not([transient-theme]) .section .section-header .add-data-paragraph:after {
	content: "Add Data";
}

html:not([transient-theme]) .section .section-header .name-input {
  position: absolute;
}

html:not([transient-theme]) .section .section-header .name-input:focus {
  outline: none;
}

html:not([transient-theme]) .section .section-header .name-input:empty:focus {
  outline: 1px solid white;
  opacity: 1.0;
  animation-name: blink-cursor;
  animation-duration: 500ms;
  animation-direction: alternate;
  animation-iteration-count: infinite;
  animation-timing-function: ease-in-out;
}

html:not([transient-theme]) .section .section-header .name-input:empty:before {
  content: "No Name";
  opacity: .5;
}

html:not([transient-theme]) .section .section-header .name-input:empty:focus:before {
  content: "";
}

html:not([transient-theme]) .section .section-header .delete-section {
  margin-left: 20px;
}

html:not([transient-theme]) .section .section-header .action {
  opacity: 0.25;
  pointer-events: none;
}

html:not([transient-theme]) .section .section-header:hover .action {
  opacity: 1.0;
  pointer-events: all;
}

html:not([transient-theme]) .section .section-header .action:hover {
  color: orange;
}

html:not([transient-theme]) .section .section-header .delete-section:hover {
  color: red;
}

/* Icon Delete */
html:not([transient-theme]) .section .section-header .delete-section i:after {
  content: "delete";
}

/* Tooltip Delete */
html:not([transient-theme]) .section .section-header .delete-section:after {
  content: "Delete";
}

/* Hide Collapsed Sections */
html:not([transient-theme]) .section.hide-collapsed-paragraphs .paragraph.collapsed {
	display: none;
}

html:not([transient-theme]) .section.hide-collapsed-paragraphs .hide-collapsed-paragraphs2 {
	opacity: 1.0;
}

/* Icon Show Collapsed Paragraphs */
html:not([transient-theme]) .section.hide-collapsed-paragraphs .hide-collapsed-paragraphs2 i:after {
  content: "visibility_off";
}

/* Tooltip Show Collapsed Paragraphs */
html:not([transient-theme]) .section.hide-collapsed-paragraphs .hide-collapsed-paragraphs2:after {
  content: "Show Collapsed Paragraphs";
}

/* Icon Hide Collapsed Paragraphs */
html:not([transient-theme]) .section:not(.hide-collapsed-paragraphs) .hide-collapsed-paragraphs2 i:after {
  content: "visibility";
}

/* Tooltip Hide Collapsed Paragraphs */
html:not([transient-theme]) .section:not(.hide-collapsed-paragraphs) .hide-collapsed-paragraphs2:after {
  content: "Hide Collapsed Paragraphs";
}

/* Icon Not System Section */
html:not([transient-theme]) .section .toggle-system-section i:after {
  content: "extension";
}

/* Tooltip Not System Section */
html:not([transient-theme]) .section .toggle-system-section:after {
  content: "Activate System Section";
}

/* System Section */
html:not([transient-theme]) .section[data-type="system"] .toggle-system-section {
  color: lime;
	opacity: 1.0 !important;
}

/* Tooltip Not System Section */
html:not([transient-theme]) .section[data-type="system"] .toggle-system-section:after {
  content: "Deactivate System Section";
}

/* Icon Not Package Section */
html:not([transient-theme]) .section .toggle-package-section i:after {
  content: "build";
}

/* Tooltip Not Package Section */
html:not([transient-theme]) .section .toggle-package-section:after {
  content: "Activate Package Section";
}

/* Package Section */
html:not([transient-theme]) .section[data-type="package"] .toggle-package-section {
  color: lime;
	opacity: 1.0 !important;
}

/* Tooltip Not Package Section */
html:not([transient-theme]) .section[data-type="package"] .toggle-package-section:after {
  content: "Deactivate Package Section";
}</STYLE></DIV><DIV class="paragraph style-paragraph collapsed" name="Section Browser" draggable="false" data-id="6tj93nGL" __wid="JYafDjTh"><STYLE data-type="content" type="text/css" codemirror="true" __wid="XfhXYmGV">html:not([transient-theme]) #section-tree {
	margin: 0px;
	min-height: 150px;
	padding-left: 0px;
	padding-right: 10px;
	user-select: none;
	overflow: auto;
	list-style: none;
}

html:not([transient-theme]) #section-tree li {
	color: gainsboro;
	vertical-align: middle;
	text-overflow: ellipsis;
	white-space: nowrap;
	overflow: hidden;
}

html:not([transient-theme]) #section-tree .closed ul {
	display: none;	
}

html:not([transient-theme]) #section-tree li {
	cursor: pointer;	
}

html:not([transient-theme]) #section-tree li.hidden {
	opacity: 0.5;	
}

html:not([transient-theme]) #section-tree li .title {
	margin-left: 0.5em;
	vertical-align: middle;
}

html:not([transient-theme]) #section-tree li i {
	vertical-align: middle;
}

html:not([transient-theme]) #section-tree li .type {
	margin-left: 5px;
}</STYLE></DIV><DIV class="paragraph style-paragraph collapsed" name="Paragraph Style" draggable="false" data-id="ZVLeTEZN" __wid="CkNDUGsN"><STYLE data-type="content" type="text/css" codemirror="true" __wid="hXMBQ6iD">html:not([transient-theme]) .paragraph {
  clear: both;
  position: relative;
/*   resize: vertical; */
  margin-top: 10px;
}

html:not([transient-theme]) .paragraph div:focus {
  outline: none;
}

html:not([transient-theme]) .paragraph pre {
  margin: 0px;
  padding: 0px;
}

html:not([transient-theme]) .paragraph pre[type]  {
  display: none;
}

html:not([transient-theme]) .paragraph.body-paragraph [data-type="content"] {
	position: inherit;
  font-size: 11pt;
  box-sizing: border-box;
  margin: 5px;
	z-index: 0;
}

/* Style achors in text paragraphs */
html:not([transient-theme]) .paragraph.body-paragraph [data-type="content"] a {
	color: white;
}

/* Reset box-sizing of content paragraphs to their initial value */
html:not([transient-theme]) .paragraph.body-paragraph [data-type="content"] * {
  box-sizing: initial;
}

html:not([transient-theme]) .paragraph .paragraph-header {
  display: block;
  position: relative;
  display: block;
  background: rgba(0, 0, 0, .3);
  width: 100%;
  height: 30px;
  border-radius: 2px;
}

html:not([transient-theme]) .paragraph .paragraph-header .action {
  position: relative;
  float: right;
  height: 100%;
  
  cursor: pointer;
  margin-right: 10px;
  opacity: .25;
  pointer-events: none;
}

html:not([transient-theme]) .paragraph .paragraph-header .action:hover {
	color: orange;
}

html:not([transient-theme]) .paragraph .paragraph-header:hover .action {
  pointer-events: initial;
  opacity: 1.0;
}

html:not([transient-theme]) .paragraph .paragraph-header .action .material-icons {
  position: relative;
  top: 50%;
  transform: translate3d(0, -50%, 0);
}</STYLE></DIV><DIV class="paragraph style-paragraph collapsed" name="Paragraph Title Style" draggable="false" data-id="n64A599U" __wid="rudFFQYA"><STYLE data-type="content" type="text/css" codemirror="true" __wid="NsuHXJgY">html:not([transient-theme]) .paragraph .paragraph-header:before {
	font-family: 'Material Icons';
	font-weight: normal;
	font-style: normal;
/* 	font-size: 24px; */
	display: inline-block;
	line-height: 1;
	text-transform: none;
	letter-spacing: normal;
	word-wrap: normal;
	white-space: nowrap;
	direction: ltr;
	-webkit-font-smoothing: antialiased;
	text-rendering: optimizeLegibility;
	-moz-osx-font-smoothing: grayscale;
	font-feature-settings: 'liga';
	
  position: relative;
  top: 7px;
  left: 7px;
}

html:not([transient-theme]) .paragraph.body-paragraph .paragraph-header:before {
  content: "text_fields";
}

html:not([transient-theme]) .paragraph.code-paragraph .paragraph-header:before {
  content: "code";
}

html:not([transient-theme]) .paragraph.style-paragraph .paragraph-header:before {
  content: "brush";
}

html:not([transient-theme]) .paragraph.data-paragraph .paragraph-header:before {
  content: "storage";
}

html:not([transient-theme]) .paragraph .paragraph-header .input {
  position: relative;
  top: 5px;
  font-size: .9em;
  z-index: 1;
  display: inline-block;
}


html:not([transient-theme]) .paragraph .paragraph-header .input:focus {
  outline: none;
}

html:not([transient-theme]) .paragraph .paragraph-header .input:empty:focus {
  outline: 1px solid white;
  opacity: 1.0;
  animation-name: blink-cursor;
  animation-duration: 500ms;
  animation-direction: alternate;
  animation-iteration-count: infinite;
  animation-timing-function: ease-in-out;
}

html:not([transient-theme]) .paragraph .paragraph-header .input:empty:before {
  opacity: .5;
}

html:not([transient-theme]) .paragraph .paragraph-header .input:empty:focus:before {
  content: "";
}

html:not([transient-theme]) .paragraph .paragraph-header .input {
  left: 15px;
  margin-right: 15px;
}

html:not([transient-theme]) .paragraph .paragraph-header .input:before {
  color: orange;
}

html:not([transient-theme]) .paragraph .paragraph-header .name-input:empty:before {
  content: "name";
}

html:not([transient-theme]) .paragraph .paragraph-header .id-input:not(:empty):before {
  content: "#";
}

html:not([transient-theme]) .paragraph .paragraph-header .id-input:empty:before {
  content: "#id";
}

html:not([transient-theme]) .paragraph .paragraph-header .class-input:before {
  content: "class: ";
}

html:not([transient-theme]) .paragraph .paragraph-header .input:empty:before {
  opacity: 0;
  pointer-events: none;
}

html:not([transient-theme]) .paragraph .paragraph-header:hover .input:empty:before {
  opacity: 1.0;
  pointer-events: all;
}</STYLE></DIV><DIV class="paragraph style-paragraph collapsed" name="Paragraph Collapse Style" draggable="false" data-id="gKnfCRJB" __wid="kziBQbsq"><STYLE data-type="content" type="text/css" codemirror="true" __wid="3SBJpHuZ">/* Icon expanded */
html:not([transient-theme]) .collapse-expand i:after {
  content: "expand_less";
}

/* Tooltip expanded */
html:not([transient-theme]) .collapse-expand:after {
	content: "Collapse";
}

/* Icon collapsed */
html:not([transient-theme]) .paragraph.collapsed .collapse-expand i:after {
  content: "expand_more";
}

/* Tooltip collapsed */
html:not([transient-theme]) .paragraph.collapsed .collapse-expand:after {
	content: "Expand";
}

/* Hide all content of a paragraph except the paragraph header */
html:not([transient-theme]) .paragraph.collapsed > *:not(.paragraph-header) {
	display: none;
}</STYLE></DIV><DIV class="paragraph style-paragraph collapsed" name="Lock Paragraph Style" draggable="false" data-id="LM22iaJk" __wid="YuD3uGEi"><STYLE data-type="content" type="text/css" codemirror="true" contenteditable="true" __wid="TAQayaXy">html:not([transient-theme]) .paragraph:not(:hover):not(.locked) .paragraph-header .lock-content {
  opacity: 0.25;
  pointer-events: none;
}

html:not([transient-theme]) .paragraph.locked .paragraph-header .lock-content {
  opacity: 1.0;
}

html:not([transient-theme]) .paragraph.locked .text-tools {
  display: none;
}

/* Icon Lock */
html:not([transient-theme]) .paragraph .paragraph-header .lock-content i:after {
  content: "lock_open";
}

/* Tooltip Lock */
html:not([transient-theme]) .paragraph .paragraph-header .lock-content:after {
  content: "Lock";
}

/* Icon Unlock */
html:not([transient-theme]) .paragraph.locked .paragraph-header .lock-content i:after {
  content: "lock_outline";
}

/* Tooltip Unlock */
html:not([transient-theme]) .paragraph.locked .paragraph-header .lock-content:after {
  content: "Unlock";
}</STYLE></DIV><DIV class="paragraph style-paragraph collapsed" name="Paragraph Delete Action Style" draggable="false" data-id="8vZywFM8" __wid="En8XWSJV"><STYLE data-type="content" type="text/css" codemirror="true" contenteditable="true" __wid="DMdZjjwN">html:not([transient-theme]) .paragraph .delete-paragraph {
  margin-right: 10px;
}

/* Icon Delete */
html:not([transient-theme]) .paragraph .delete-paragraph i:after {
  content: "delete";
}

/* Tooltip Delete */
html:not([transient-theme]) .paragraph .delete-paragraph:after {
  content: "Delete";
}

html:not([transient-theme]) .paragraph .delete-paragraph i:hover:after {
  color: red;
}</STYLE></DIV><DIV class="paragraph style-paragraph collapsed" name="Paragraph Sortable Style" draggable="false" data-id="C6eX72vd" __wid="vqFr5NMQ"><STYLE data-type="content" type="text/css" codemirror="true" __wid="3Kh7RfeP">html:not([transient-theme]) .paragraph .drag-handle {
  cursor: -webkit-grabbing;
  cursor: move;
  opacity: 0;
  pointer-events: none;
}

html:not([transient-theme]) .paragraph.dragging > * {
  pointer-events: none;
}

html:not([transient-theme]) .paragraph.dragging {
  opacity: .5;
}

/* Icon Drag Handle */
html:not([transient-theme]) .paragraph .drag-handle i:after {
  content: "drag_handle";
}</STYLE></DIV><DIV class="paragraph style-paragraph collapsed" name="Paragraph Code Execution" draggable="false" data-id="HHcUjYwH" __wid="vT4jM66J"><STYLE data-type="content" type="text/css" codemirror="true" __wid="yB4At8rR">html:not([transient-theme]) .paragraph .execute-paragraph,
html:not([transient-theme]) .paragraph .run-on-load-paragraph,
html:not([transient-theme]) .paragraph .toggle-console-paragraph {
  margin-left: 5px;
}

html:not([transient-theme]) .paragraph .run-on-load-paragraph {
  margin-right: 10px;
}

html:not([transient-theme]) .paragraph[run-on-load] .run-on-load-paragraph {
  opacity: 1.0;
  pointer-events: all;
}

/* Icon Execute Code */
html:not([transient-theme]) .paragraph .execute-paragraph i:after {
  content: "play_circle_outline";
}

/* Tooltip Execute Code */
html:not([transient-theme]) .paragraph .execute-paragraph:after {
  content: "Execute Code";
}

/* Icon Execute Code on Load */
html:not([transient-theme]) .paragraph .run-on-load-paragraph i:after {
  content: "directions_run";
}

/* Tooltip Enable Execute Code on Load */
html:not([transient-theme]) .paragraph .run-on-load-paragraph:after {
  content: "Enable Execute Code on Load";
}

/* Icon Console */
html:not([transient-theme]) .paragraph .toggle-console-paragraph i:after {
  content: "message";
}

/* Tooltip Console */
html:not([transient-theme]) .paragraph .toggle-console-paragraph:after {
  content: "Toggle Console";
}

html:not([transient-theme]) .paragraph[run-on-load] .run-on-load-paragraph i:after {
  color: lime;
}

/* Tooltip Disable Execute Code on Load */
html:not([transient-theme]) .paragraph[run-on-load] .run-on-load-paragraph:after {
	content: "Disable Execute Code on Load";
}

html:not([transient-theme]) .paragraph[last-execution-state="error"] .toggle-console-paragraph {
  opacity: 1.0;
}

html:not([transient-theme]) .paragraph[last-execution-state="error"] .toggle-console-paragraph i:after {
  color: red;
}

html:not([transient-theme]) .paragraph .paragraph-header .type-input {
  opacity: 0;
}

html:not([transient-theme]) .paragraph .paragraph-header:hover .type-input {
  opacity: 1;
}

html:not([transient-theme]) .paragraph .paragraph-header .type-input:before {
  content: "type: ";
}</STYLE></DIV><DIV class="paragraph style-paragraph collapsed" name="Paragraph Style Disable Style" data-id="AqZAbtDa" __wid="JbiH4p3b"><STYLE data-type="content" type="text/css" codemirror="true" __wid="ZAyVCB2B">html:not([transient-theme]) .paragraph:not(:hover):not(.style-disabled) .paragraph-header .disable-style-content {
  opacity: 0.25;
  pointer-events: none;
}

html:not([transient-theme]) .paragraph.style-disabled .paragraph-header .disable-style-content {
  opacity: 1.0;
}

/* Icon Disable */
html:not([transient-theme]) .paragraph .paragraph-header .disable-style-content i:after {
  content: "check_box";
}

/* Tooltip Disable */
html:not([transient-theme]) .paragraph .paragraph-header .disable-style-content:after {
  content: "Disable";
}

/* Icon Enable */
html:not([transient-theme]) .paragraph.style-disabled .paragraph-header .disable-style-content i:after {
  content: "check_box_outline_blank";
}

/* Tooltip Enable */
html:not([transient-theme]) .paragraph.style-disabled .paragraph-header .disable-style-content:after {
  content: "Enable";
}</STYLE></DIV><DIV class="paragraph style-paragraph collapsed" name="Fullscreen Style" draggable="false" data-id="AXwP6QBU" __wid="rrEuNBW2"><STYLE data-type="content" type="text/css" codemirror="true" contenteditable="true" __wid="tdnBv7Ew">html:not([transient-theme]) body.fullscreen:not([transient-fullscreen="false"]),
html:not([transient-theme]) body[transient-fullscreen="true"] {
  overflow: hidden;
}

html:not([transient-theme]) body.fullscreen:not([transient-fullscreen="false"]) .section,
html:not([transient-theme]) body[transient-fullscreen="true"] .section {
	width: 0;
	height: 0;
	padding: 0;
	margin: 0;
}

/* Hides section toolbar */
html:not([transient-theme]) body.fullscreen:not([transient-fullscreen="false"]) .section .section-header,
html:not([transient-theme]) body[transient-fullscreen="true"] .section .section-header {
	opacity: 0;
	pointer-events: none;
}

html:not([transient-theme]) .paragraph.fullscreen:not([transient-fullscreen="false"]),
html:not([transient-theme]) .paragraph[transient-fullscreen="true"] {
  position: fixed;
  left: 0;
  top: 0;
  bottom: 0;
  right: 0;
  width: 100vw;
  height: 100vh;
  z-index: 200;
  margin: 0;
  background: rgb(48, 48, 48);
	-webkit-overflow-scrolling: touch; /* enable elastic scroll on touch devices */
}

/* move transient-fullscreen above fullscreen */
html:not([transient-theme]) .paragraph[transient-fullscreen="true"] {
	z-index: 201;
}

/* Prevent input on paragraphs not in fullscreen view */
html:not([transient-theme]) body.fullscreen:not([transient-fullscreen="false"]) .paragraph:not(.fullscreen):not([transient-fullscreen="true"]),
html:not([transient-theme]) body[transient-fullscreen="true"] .paragraph:not([transient-fullscreen="true"]) {
	pointer-events: none;
}

html:not([transient-theme]) .paragraph.fullscreen:not([transient-fullscreen="false"]) .paragraph-header,
html:not([transient-theme]) .paragraph.body-paragraph.fullscreen:not([transient-fullscreen="false"]) .text-tools,
html:not([transient-theme]) .paragraph[transient-fullscreen="true"] .paragraph-header,
html:not([transient-theme]) .paragraph.body-paragraph[transient-fullscreen="true"] .text-tools {
  position: fixed;
	z-index: 1;
}

/* "Hide" paragraph utils when in locked fullscreen view */
html:not([transient-theme]) .paragraph.locked.fullscreen:not([transient-fullscreen="false"]) .paragraph-header,
html:not([transient-theme]) .paragraph.locked[transient-fullscreen="true"] .paragraph-header {
	height: 0;
}

/* Position toggle fullscreen button in locked fullscreen view */
html:not([transient-theme]) .paragraph.locked.fullscreen:not([transient-fullscreen="false"]) .paragraph-header > .toggle-fullscreen,
html:not([transient-theme]) .paragraph.locked[transient-fullscreen="true"] .paragraph-header > .toggle-fullscreen {
	position: absolute;
	top: 20px;
	right: 10px;
}

/* Position toggle fullscreen button in locked fullscreen view */
html:not([transient-theme]) .paragraph.locked.fullscreen:not([transient-fullscreen="false"]) .paragraph-header > .lock-content,
html:not([transient-theme]) .paragraph.locked[transient-fullscreen="true"] .paragraph-header > .lock-content {
	position: absolute;
	top: 20px;
	right: 40px;
}

/* !!! Bug: make actions interactive */
html:not([transient-theme]) .paragraph.locked.fullscreen:not([transient-fullscreen="false"]) .paragraph-header .action,
html:not([transient-theme]) .paragraph.locked[transient-fullscreen="true"] .paragraph-header .action {
	pointer-events: initial;
}

/* Hide paragraph icon */
html:not([transient-theme]) .paragraph.locked.fullscreen:not([transient-fullscreen="false"]) .paragraph-header:before,
html:not([transient-theme]) .paragraph.locked[transient-fullscreen="true"] .paragraph-header:before {
	display: none;
}

html:not([transient-theme]) .paragraph.fullscreen:not([transient-fullscreen="false"]) .paragraph-header .delete-paragraph,
html:not([transient-theme]) .paragraph.fullscreen:not([transient-fullscreen="false"]) .paragraph-header .drag-handle,
html:not([transient-theme]) .paragraph.fullscreen:not([transient-fullscreen="false"]) .paragraph-header .collapse-expand,
html:not([transient-theme]) .paragraph[transient-fullscreen="true"] .paragraph-header .delete-paragraph,
html:not([transient-theme]) .paragraph[transient-fullscreen="true"] .paragraph-header .drag-handle,
html:not([transient-theme]) .paragraph[transient-fullscreen="true"] .paragraph-header .collapse-expand {
	display: none;
}

/* Hide all paragraph actions excluding lock and toggle fullscreen */
html:not([transient-theme]) .paragraph.locked.fullscreen:not([transient-fullscreen="false"]) .paragraph-header > *:not(.lock-content):not(.toggle-fullscreen),
html:not([transient-theme]) .paragraph.locked[transient-fullscreen="true"] .paragraph-header > *:not(.lock-content):not(.toggle-fullscreen) {
	display: none;
}

html:not([transient-theme]) .paragraph.body-paragraph.fullscreen:not([transient-fullscreen="false"]) .text-tools,
html:not([transient-theme]) .paragraph.body-paragraph[transient-fullscreen="true"] .text-tools {
  top: 30px;
}

html:not([transient-theme]) .paragraph.fullscreen:not([transient-fullscreen="false"]) .CodeMirror,
html:not([transient-theme]) .paragraph[transient-fullscreen="true"] .CodeMirror {
	width: 100vw;
  height: 100vh;
	overflow: hidden !important;
  overflow-y: auto;
}


html:not([transient-theme]) .paragraph.fullscreen:not([transient-fullscreen="false"]):not(.locked) .CodeMirror,
html:not([transient-theme]) .paragraph[transient-fullscreen="true"]:not(.locked) .CodeMirror {
  height: calc(100vh - 30px);
  overflow: auto;
}

/* Move CodeMirror down to make space for fixed paragraph utils */
html:not([transient-theme]) .paragraph.fullscreen:not([transient-fullscreen="false"]):not(.locked) .CodeMirror,
html:not([transient-theme]) .paragraph[transient-fullscreen="true"]:not(.locked) .CodeMirror {
  margin-top: 30px;
}

/* This is a HACK as text paragraph cannot be scrolled in fullscreen otherwise */
html:not([transient-theme]) .paragraph.body-paragraph.fullscreen:not([transient-fullscreen="false"]) [data-type="content"],
html:not([transient-theme]) .paragraph.body-paragraph[transient-fullscreen="true"] [data-type="content"] {
	margin: 0;
	padding: 0;
	width: 100vw;
	height: 100vh;
  overflow: auto;
}

/* Move CodeMirror down to make space for fixed paragraph utils + text tools */
html:not([transient-theme]) .paragraph.body-paragraph.fullscreen:not([transient-fullscreen="false"]):not(.locked) [data-type="content"],
html:not([transient-theme]) .paragraph.body-paragraph[transient-fullscreen="true"]:not(.locked) [data-type="content"] {
	position: absolute;
  top: 75px;
  height: calc(100vh - 75px);
}

/* Icon Fullscreen */
html:not([transient-theme]) .paragraph .paragraph-header .toggle-fullscreen i:after {
  content: "fullscreen";
}

/* Tooltip Fullscreen */
html:not([transient-theme]) .paragraph .paragraph-header .toggle-fullscreen:after {
  content: "Fullscreen";
}

/* Icon Exit Fullscreen */
html:not([transient-theme]) .paragraph.fullscreen:not([transient-fullscreen="false"]) .paragraph-header .toggle-fullscreen i:after,
 html:not([transient-theme]) .paragraph[transient-fullscreen="true"] .paragraph-header .toggle-fullscreen i:after {
  content: "fullscreen_exit";
}

/* Tooltip Exit Fullscreen */
html:not([transient-theme]) .paragraph.fullscreen:not([transient-fullscreen="false"]) .paragraph-header .toggle-fullscreen:after,
html:not([transient-theme]) .paragraph[transient-fullscreen="true"] .paragraph-header .toggle-fullscreen:after {
  content: "Exit Fullscreen";
}</STYLE></DIV><DIV class="paragraph style-paragraph collapsed" name="Text Tools Style" draggable="false" data-id="ETX4s9QH" __wid="ZiyD6JE2"><STYLE data-type="content" type="text/css" codemirror="true" contenteditable="true" __wid="74Md5v83">html:not([transient-theme]) .text-tools {
/* 	position: relative; */
  display: block;
  width: 100%;
  background-color: rgba(0, 0, 0, .3);
  padding: 5px;
  padding-top: 10px;
  margin-top: 1px;
  border-radius: 2px;
  
/*  border-top: 1px solid rgba(255, 255, 255, .1);*/
  
  -webkit-user-select: none;  /* Chrome all / Safari all */
  -moz-user-select: none;     /* Firefox all */
  -ms-user-select: none;      /* IE 10+ */
  user-select: none;          /* Likely future */   
}

html:not([transient-theme]) .paragraph.collapsed .text-tools {
  display: none;
}

html:not([transient-theme]) .text-tools .action {
	position: relative;
  cursor: pointer;
  display: inline-block;
  margin-left: 5px;
}

html:not([transient-theme]) .text-tools .action:hover {
  color: orange;
}

/* Icon Bold */
html:not([transient-theme]) .text-tools .text-bold i:after {
  content: "format_bold";
}

/* Tooltip Bold */
html:not([transient-theme]) .text-tools .text-bold:after {
  content: "Bold";
}

/* Icon Italic */
html:not([transient-theme]) .text-tools .text-italic i:after {
  content: "format_italic";
}

/* Tooltip Italic */
html:not([transient-theme]) .text-tools .text-italic:after {
  content: "Italic";
}

/* Icon Underline */
html:not([transient-theme]) .text-tools .text-underline i:after {
  content: "format_underline";
}

/* Tooltip Underline */
html:not([transient-theme]) .text-tools .text-underline:after {
  content: "Underline";
}

/* Icon Strikethrough */
html:not([transient-theme]) .text-tools .text-strikethrough i:after {
  content: "format_strikethrough";
}

/* Tooltip Strikethrough */
html:not([transient-theme]) .text-tools .text-strikethrough:after {
  content: "Strikethrough";
}

/* Icon Bullets */
html:not([transient-theme]) .text-tools .text-list-bulleted i:after {
  content: "format_list_bulleted";
}

/* Tooltip Bullets */
html:not([transient-theme]) .text-tools .text-list-bulleted:after {
  content: "Bullets";
}

/* Icon Numbering */
html:not([transient-theme]) .text-tools .text-list-numbered i:after {
  content: "format_list_numbered";
}

/* Tooltip Numbering */
html:not([transient-theme]) .text-tools .text-list-numbered:after {
  content: "Numbering";
}

/* Icon Increase Indent */
html:not([transient-theme]) .text-tools .text-list-indent i:after {
  content: "format_indent_increase";
}

/* Tooltip Increase Indent */
html:not([transient-theme]) .text-tools .text-list-indent:after {
  content: "Increase Indent";
}

/* Icon Decrease Indent */
html:not([transient-theme]) .text-tools .text-list-outdent i:after {
  content: "format_indent_decrease";
}

/* Tooltip Decrease Indent */
html:not([transient-theme]) .text-tools .text-list-outdent:after {
  content: "Decrease Indent";
}

/* Icon Clear Formatting */
html:not([transient-theme]) .text-tools .clear-format i:after {
  content: "format_clear";
}

/* Tooltip Clear Formatting */
html:not([transient-theme]) .text-tools .clear-format:after {
  content: "Clear Formatting";
}

html:not([transient-theme]) .text-tools .text-h1,
html:not([transient-theme]) .text-tools .text-h2,
html:not([transient-theme]) .text-tools .text-h3,
html:not([transient-theme]) .text-tools .text-set-variable,
html:not([transient-theme]) .text-tools .text-hide-variable-names, 
html:not([transient-theme]) .text-tools .text-convert-to-html {
  margin-left: 10px;
  margin-top: 2px;
  vertical-align: top;
}

/* Tooltip Section */
html:not([transient-theme]) .text-tools .text-h1:after {
	content: "Format Heading 1"
}

/* Tooltip Subsection */
html:not([transient-theme]) .text-tools .text-h2:after {
	content: "Format Heading 2"
}

/* Tooltip Subsection */
html:not([transient-theme]) .text-tools .text-h3:after {
	content: "Format Heading 3"
}

/* Tooltip Add Variable */
html:not([transient-theme]) .text-tools .text-set-variable:after {
	content: "Add Variable"
}

/* Tooltip Hide Variable Names */
html:not([transient-theme]) .text-tools .text-hide-variable-names:after {
	content: "Hide Variable Names"
}

/* Tooltip Convert HTML */
html:not([transient-theme]) .text-tools .text-convert-to-html:after {
	content: "Convert HTML"
}</STYLE></DIV><DIV class="paragraph style-paragraph collapsed" name="Variable Style" draggable="false" data-id="LWYEJJ2X" __wid="FEG779nt"><STYLE data-type="content" type="text/css" codemirror="true" __wid="j57beArA">html:not([transient-theme]) .variable {
	position: relative;
	display: inline;
	color: deepskyblue;
}

html:not([transient-theme]) .variable:empty:before {
	content: attr(data-name) " (unset)";
}

html:not([transient-theme]) .variable:before {
	content: attr(data-name) " = ";
	color: orange;
	opacity: .5;
}

html:not([transient-theme]) .hide-variable-names .variable:not(:empty):before {
	display: none;
}

html:not([transient-theme]) .hide-variable-names .variable:not(:empty):hover:before {
	content: attr(data-name);
	position: absolute;
	top: 0;
	left: 0;
	transform: translate3d(0, -100%, 0);
	display: inline-block;
	border-radius: 2px;
	font-size: .8em;
	padding: 2px;

	color: white;
	background: rgb(135, 135, 129);
	opacity: 1.0;
	/*border: 5px solid transparent;*/
}</STYLE></DIV><DIV class="paragraph style-paragraph collapsed" name="Drop Assets Style" draggable="false" data-id="smjHTJUJ" __wid="sxTn8STR"><STYLE data-type="content" type="text/css" codemirror="true" __wid="b4iy347W">html:not([transient-theme]) .paragraph [data-type="content"] .upload-in-progress {
  opacity: .25;
}

html:not([transient-theme]) .paragraph [data-type="content"] video,
html:not([transient-theme]) .paragraph [data-type="content"] img {
  max-width: 100%;
}</STYLE></DIV><DIV class="paragraph style-paragraph collapsed" name="Add File Style" draggable="false" data-id="2SkdQVQA" __wid="nr5YjR4A"><STYLE data-type="content" type="text/css" codemirror="true" __wid="RcGZVY4P">/* Hide native upload file UI element */
html:not([transient-theme]) .add-file input[type="file"] {
  display: none;
}

/* Icon Upload File */
html:not([transient-theme]) .add-file label.material-icons:after {
  content: "file_upload";
}

/* Tooltip Upload File */
html:not([transient-theme]) .add-file:after {
  content: "Upload File";
}</STYLE></DIV><DIV class="paragraph style-paragraph collapsed" draggable="false" name="Remote Cursors" data-id="q78PZsdu" __wid="TegnKmgE"><STYLE data-type="content" type="text/css" codemirror="true" __wid="ERFVd7ch">html:not([transient-theme]) .client {
	width: 100px;
	height: 1em;
	margin: 1px;
	padding: 1px;
	display: inline-block;
}

html:not([transient-theme]) .cursor {
	position: absolute;
	user-select: none;
	pointer-events: none;
}

html:not([transient-theme]) .cursor .rect {
  /* lighten when white color font */
	mix-blend-mode: lighten;
}

html:not([transient-theme]) .cursor .end {
	opacity: 1.0;
	width: 2px;
}

html:not([transient-theme]) .cursor .end .displayName {
	position: absolute;
	padding: 2px;
	white-space: pre;
	top: -100%;
	font-size: 9pt;
	animation: hide 4s ease 1 normal;
	opacity: 0;
	font-weight: bold;
}

@-webkit-keyframes hide {
	0% { opacity: 1; }
	80% { opacity: 1; }
	100% { opacity: 0; }
}

html:not([transient-theme]) .cursor .rect {
	border-left: none;
}

html:not([transient-theme]) .cursor .rect ~ .rect {
	border: none;
}</STYLE></DIV><DIV class="paragraph style-paragraph collapsed" name="CodeMirror Monokai Theme" draggable="false" data-id="63U8sryX" __wid="AQysjt8x"><STYLE data-type="content" type="text/css" codemirror="true" __wid="R6qyQRmh">/* Based on Sublime Text's Monokai theme */

.cm-s-monokai.CodeMirror { background: rgb(48, 48, 48); color: #f8f8f2 !important; }
.cm-s-monokai.CodeMirror div {}
.cm-s-monokai div.CodeMirror-selected { background: #49483E; }
.cm-s-monokai .CodeMirror-line::selection, .cm-s-monokai .CodeMirror-line > span::selection, .cm-s-monokai .CodeMirror-line > span > span::selection { background: rgba(73, 72, 62, .99); }
.cm-s-monokai .CodeMirror-line::-moz-selection, .cm-s-monokai .CodeMirror-line > span::-moz-selection, .cm-s-monokai .CodeMirror-line > span > span::-moz-selection { background: rgba(73, 72, 62, .99); }
.cm-s-monokai .CodeMirror-gutters { background: rgb(48, 48, 48); border-right: 0px; }
.cm-s-monokai .CodeMirror-guttermarker { color: white; }
.cm-s-monokai .CodeMirror-guttermarker-subtle { color: #d0d0d0; }
.cm-s-monokai .CodeMirror-linenumber { color:rgb(135, 135, 129); }
.cm-s-monokai .CodeMirror-cursor { border-left: 1px solid #f8f8f0; }

.cm-s-monokai span.cm-comment { color: rgb(135, 135, 129); }
.cm-s-monokai span.cm-atom { color: #ae81ff; }
.cm-s-monokai span.cm-number { color: #ae81ff; }

.cm-s-monokai span.cm-property, .cm-s-monokai span.cm-attribute { color: #a6e22e; }
.cm-s-monokai span.cm-keyword { color: rgb(234, 53, 134); }
.cm-s-monokai span.cm-builtin { color: #66d9ef; }
.cm-s-monokai span.cm-string { color: #e6db74; }

.cm-s-monokai span.cm-variable { color: #f8f8f2; }
.cm-s-monokai span.cm-variable-2 { color: #9effff; }
.cm-s-monokai span.cm-variable-3 { color: #66d9ef; }
.cm-s-monokai span.cm-def { color: #fd971f; }
.cm-s-monokai span.cm-bracket { color: #f8f8f2; }
.cm-s-monokai span.cm-tag { color: rgb(234, 53, 134); }
.cm-s-monokai span.cm-header { color: #ae81ff; }
.cm-s-monokai span.cm-link { color: #ae81ff; }
.cm-s-monokai span.cm-error { background: rgb(234, 53, 134); color: #f8f8f0; }

.cm-s-monokai .CodeMirror-activeline-background { background: #373831; }
.cm-s-monokai .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: white !important;
}

.cm-s-monokai span.cm-matchhighlight { background: #353; }</STYLE></DIV><DIV class="paragraph style-paragraph collapsed" name="CodeMirror integration CSS" draggable="false" data-id="xjJqeVWB" __wid="h357mijz"><STYLE data-type="content" type="text/css" codemirror="true" __wid="VLnYZWYi">html:not([transient-theme]) .CodeMirror {
    isolation: isolate;
    height: auto;
    font-family: "Menlo", "consolas", monospace;
    font-size: 11pt;
    height: auto;
    -webkit-font-smoothing: antialiased;
		clear: both;
	
}

html:not([transient-theme]) .paragraph.body-paragraph > transient.hidden {
  display: none;
}

html:not([transient-theme]) .paragraph.body-paragraph transient.html-editor:before {
  content: "HTML of the above";
  display: block;
  margin-top: 20px;
  background-color: #222;
  padding: 3px;
  border-radius: 2px;
  pointer-events: none;
	clear: both;
}

/* Icon Save HTML */
html:not([transient-theme]) .paragraph .paragraph-header .save-html i:after {
  content: "save";
}

/* Tooltip Save HTML */
html:not([transient-theme]) .paragraph .paragraph-header .save-html:after {
  content: "Save HTML";
}

html:not([transient-theme]) .paragraph .paragraph-header .toggle-html i:after {
  content: "visibility";
}

html:not([transient-theme]) .paragraph .paragraph-header .toggle-html:after {
  content: "Toggle HTML Editor";
}</STYLE></DIV></DIV><DIV class="section section-hidden" name="Plain Theme" data-type="system" data-group="basic" data-id="bzCEKyQV" __wid="TchxNzXD"><DIV class="paragraph body-paragraph locked collapsed" name="Documentation" data-id="bZZW75bn" __wid="ZnBdqkwW"><DIV data-type="content" type="text/html" codemirror="true" contenteditable="false" class="section-documentation" __wid="WyxF3kiA"><H2 __wid="a3eHpgsa">Description</H2><DIV __wid="cGELneBK">TODO</DIV></DIV></DIV><DIV class="paragraph data-paragraph locked collapsed" name="Properties" data-id="KwWYX67K" __wid="kpESbYzN"><PRE data-type="content" type="application/json" class="section-properties" contenteditable="false" __wid="LbRSaLYA">{
	"version": "1.0",
	"dependencies": [],
	"description": "Lorem ipsum",
	"changelog":
	{
		"1.0": "Initital Release"
	}
}</PRE></DIV>

<DIV class="paragraph code-paragraph collapsed" draggable="false" last-execution-state="success" name="Install Plain Theme" run-on-load="true" data-id="HW4QN6YW" __wid="tDQFhX5Q"><PRE data-type="content" type="text/javascript" __wid="deQy3yZC">const GlobalMenuUtils = require('#global-menu-utils');

const createButton = (name, classNames, action) => {
	const button = document.createElement("button");
	button.innerText = name;

	if (classNames) {
		button.setAttribute("class", classNames);
	}

	if (typeof action === 'function') {
		button.addEventListener("click", action);
	}

	return button;
};

let togglePlainTheme = createButton("Toggle plain theme", null, () => {
	if (document.documentElement.hasAttribute("transient-theme")) {
		document.documentElement.removeAttribute("transient-theme");
	}
	else {
		document.documentElement.setAttribute("transient-theme", "plain");
	}
});

GlobalMenuUtils.addDivider();
GlobalMenuUtils.addMenuItem(togglePlainTheme);</PRE></DIV><DIV class="paragraph code-paragraph collapsed" draggable="false" style name="Load Style (material-icons.css)" run-on-load="true" last-execution-state="success" data-id="dqj56M68" __wid="sVKdxNDG"><PRE data-type="content" type="text/javascript" __wid="xDrc7QSY">importStyle("material-icons.css");</PRE></DIV><DIV class="paragraph style-paragraph collapsed" name="Main" draggable="false" style data-id="mnyFByPG" __wid="JLD3uFZH"><STYLE data-type="content" type="text/css" codemirror="true" __wid="rckTupDD">html[transient-theme="plain"],
html[transient-theme="plain"] * {
  box-sizing: border-box;
}

html[transient-theme="plain"] {
  width: 100%;
  margin: 0;
	color: black;
  background-color: white;
}

html[transient-theme="plain"],
html[transient-theme="plain"] input,
html[transient-theme="plain"] button {
  font-family: Avenir, Roboto, Arial, sans-serif;
}

html[transient-theme="plain"] body {
  margin: 0 auto;
	position: relative;
  width: 60em;
	max-width: 100vw;
	padding: 0;
	overflow: hidden;
	overflow-y: auto;
}

/* iPhone media query */
@media only screen
and (min-device-width : 375px) 
and (max-device-width : 667px) {
	html[transient-theme="plain"] body {
		width: 100vw;
	}
}</STYLE></DIV><DIV class="paragraph style-paragraph collapsed" draggable="false" name="Loading / Disconnected" style data-id="Qit7pbQF" __wid="VPKqCTqy"><STYLE data-type="content" type="text/css" codemirror="true" __wid="gzVVKXyR">@-webkit-keyframes rotateplane {
  0% {
    -webkit-transform: perspective(120px);
  }
  50% {
    -webkit-transform: perspective(120px) rotateY(180deg);
  }
  100% {
    -webkit-transform: perspective(120px) rotateY(180deg) rotateX(180deg);
  }
}

@-moz-keyframes rotateplane {
  0% {
    -moz-transform: perspective(120px);
  }
  50% {
    -moz-transform: perspective(120px) rotateY(180deg);
  }
  100% {
    -moz-transform: perspective(120px) rotateY(180deg) rotateX(180deg);
  }
}

@-o-keyframes rotateplane {
  0% {
    -o-transform: perspective(120px);
  }
  50% {
    -o-transform: perspective(120px) rotateY(180deg);
  }
  100% {
    -o-transform: perspective(120px) rotateY(180deg) rotateX(180deg);
  }
}

@keyframes rotateplane {
  0% {
    -webkit-transform: perspective(120px) rotateX(0deg) rotateY(0deg);
    -moz-transform: perspective(120px) rotateX(0deg) rotateY(0deg);
    -o-transform: perspective(120px) rotateX(0deg) rotateY(0deg);
    transform: perspective(120px) rotateX(0deg) rotateY(0deg);
  }
  50% {
    -webkit-transform: perspective(120px) rotateX(-180.1deg) rotateY(0deg);
    -moz-transform: perspective(120px) rotateX(-180.1deg) rotateY(0deg);
    -o-transform: perspective(120px) rotateX(-180.1deg) rotateY(0deg);
    transform: perspective(120px) rotateX(-180.1deg) rotateY(0deg);
  }
  100% {
    -webkit-transform: perspective(120px) rotateX(-180deg) rotateY(-179.9deg);
    -moz-transform: perspective(120px) rotateX(-180deg) rotateY(-179.9deg);
    -o-transform: perspective(120px) rotateX(-180deg) rotateY(-179.9deg);
    transform: perspective(120px) rotateX(-180deg) rotateY(-179.9deg);
  }
}

html[transient-theme="plain"] .overlay {
  position: fixed;
  display: block;
  top: 0;
  left: 0;
  bottom: 0;
  right: 0;
  /*background: rgba(255, 255, 255, .5);*/
/*  background: white;*/
  background: rgba(48, 48, 48, 1.0);
  width: 100vw;
  height: 100vh;
  z-index: 1000;
}

html[transient-theme="plain"] .overlay>div {
  position: relative;
  display: inline-block;
  left: 50%;
  top: 50%;
  transform: translate3d(-50%, -50%, 0);
}

html[transient-theme="plain"] .overlay>div:after {
  position: absolute;
  top: 100%;
  left: 50%;
  width: 200px;
  transform: translate3d(-50%, 0, 0);
  text-align: center;
}

html[transient-theme="plain"] .overlay>div>div {
  position: relative;
  display: inline-block;
  top: 0;
  left: 0;
  width: 50px;
  height: 50px;
  border-radius: 2px;
  background: rgba(255, 255, 255, .5);
  /*margin: auto;*/
  -webkit-animation: rotateplane 1.2s infinite ease-in-out;
  -moz-animation: rotateplane 1.2s infinite ease-in-out;
  -o-animation: rotateplane 1.2s infinite ease-in-out;
  animation: rotateplane 1.2s infinite ease-in-out;
}

html[transient-theme="plain"] .overlay.loading>div:after {
  content: "Loading";
}

html[transient-theme="plain"] .overlay.disconnected>div:after {
  content: "Disconnected";
}</STYLE></DIV><DIV class="paragraph style-paragraph collapsed" draggable="false" name="Scrollbars" style data-id="XYrCtjGa" __wid="FjCtL38x"><STYLE data-type="content" type="text/css" codemirror="true" __wid="bHjnq32J">html[transient-theme="plain"] *::-webkit-scrollbar {
	width: 5px;  /* remove scrollbar space */
	height: 5px;
	background: transparent;  /* optional: just make scrollbar invisible */
	border-radius: 10px;
	margin-left: 20px;
}

html[transient-theme="plain"] *::-webkit-scrollbar-track {
	background-color: rgba(0, 0, 0, .1);
	border-radius: 10px;
/* 	border: 1px solid rgba(255, 255, 255, .3); */
}

/* optional: show position indicator in red */
html[transient-theme="plain"] *::-webkit-scrollbar-thumb {
	border-radius: 10px;
	background-color: transparent;
	background-color: transparent;
}

html[transient-theme="plain"] *::-webkit-scrollbar-thumb {
	background-color: rgba(0, 0, 0, .3);
}</STYLE></DIV><DIV class="paragraph style-paragraph collapsed" name="Global Menu" draggable="false" data-id="kiPAjvjc" __wid="EULQkMwR"><STYLE data-type="content" type="text/css" codemirror="true" __wid="ixMXZKu2">html[transient-theme="plain"] #global-menu {
	position: fixed;
	top: 0;
	left: 0;
	bottom: 0;
	width: 300px;
	height: 100vh;
	z-index: 100;
	transition: transform 500ms ease-in-out 0s;

	background-color: rgba(247, 247, 247, 1);
	box-shadow: 0 0 10px black;
}

html[transient-theme="plain"] #global-menu.closed {
	transform: translate3d(-100%, 0, 0);
/* 	transform: none; */
}

/* Open menu on hover handle */
html[transient-theme="plain"] #global-menu:hover {
	transform: none;
}

html[transient-theme="plain"] #global-menu .handle {
	position: absolute;
	right: 0;
	top: 50%;
	transform: translate3d(100%, -50%, 0) rotate(-90deg);
	cursor: pointer;
}

html[transient-theme="plain"] #global-menu .handle:before {
	position: fixed;
	content: "";
	width: 25px;
	height: 25px;
/* 	box-shadow: 1px 1px 1px rgba(0, 0, 0, .5); */
}

html[transient-theme="plain"] #global-menu .handle:after {
	font-family: 'Material Icons';
	font-weight: normal;
	font-style: normal;
	font-size: 24px;
	display: inline-block;
	line-height: 1;
	text-transform: none;
	letter-spacing: normal;
	word-wrap: normal;
	white-space: nowrap;
	direction: ltr;
	-webkit-font-smoothing: antialiased;
	text-rendering: optimizeLegibility;
	-moz-osx-font-smoothing: grayscale;
	font-feature-settings: 'liga';
	
	box-shadow: -1px 1px 1px rgba(0, 0, 0, .5);
	
	content: "drag_handle";
	font-size: 1.6em;
	background-color: rgba(247, 247, 247, 1);
	margin-right: 4px;
	border-bottom-right-radius: 2px;
	border-bottom-left-radius: 2px;
}

html[transient-theme="plain"] #global-menu .content {
	display: flex;
	flex-direction: column;
	width: 100%;
	height: 100vh;
	
	overflow: hidden;
	overflow-y: auto;	
  flex-wrap: nowrap;
  -webkit-overflow-scrolling: touch;
}

html[transient-theme="plain"] #global-menu .content hr {
	border-top: none;
	border-left: none;
	border-right: none;
	border-bottom: 1px solid rgb(135, 135, 129);
	width: 100%;
}

html[transient-theme="plain"] #global-menu .content button {
	display: block;
	font-size: 0.9em;
	background-color: transparent;
	min-height: 20px;
	border: none;
	margin-top: 5px;
	margin-bottom: 5px;
	text-align: left;
	cursor: pointer;
}

html[transient-theme="plain"] #global-menu .content button:hover {
	color: orange;  
}

html[transient-theme="plain"] #global-menu .content button:focus {
	outline: none;  
}

html[transient-theme="plain"] #global-menu i.material-icons {
    display: initial;
}</STYLE></DIV><DIV class="paragraph style-paragraph collapsed" draggable="false" name="Carousel" data-id="8zvM4h75" __wid="KEqffmM4"><STYLE data-type="content" type="text/css" codemirror="true" contenteditable="true" __wid="esuSreY2">html[transient-theme="plain"] #paragraph-carousel {
	position: fixed;
	right: 0;
	top: 0;
	max-height: 100vh;
	z-index: 100;
	opacity: 0;
	
	overflow: hidden;
	overflow-y: auto;
	
	transform: translate3d(calc(100% - 20px), 0, 0);
	transition: transform 250ms ease-in-out, opacity 250ms ease-in-out;
}

/* Hide scrollbar */
html[transient-theme="plain"] #paragraph-carousel::-webkit-scrollbar {
	width: 0px;  /* remove scrollbar space */
	background: transparent;  /* optional: just make scrollbar invisible */
}

html[transient-theme="plain"] #paragraph-carousel:hover {
	transform: translate3d(-5px, 0, 0);
	opacity: 1.0;
}

html[transient-theme="plain"] .paragraph-prototype {
	width: 180px;
	height: 65px;
	border-radius: 2px;
	color: black;
	background-color: white;
	padding: 10px;
	margin: 5px 0;
	transform: translate3d(20px, 0, 0);
	transition: transform 250ms ease-in-out;
	cursor: pointer;
	
	box-shadow: 0px 0px 5px black;
	
	user-select: none;
	-webkit-user-select: none;
	-moz-user-select: none;
	-ms-user-select: none;
}

html[transient-theme="plain"] .paragraph-prototype:hover {
	transform: translate3d(10px, 0, 0);
}

html[transient-theme="plain"] .paragraph-prototype i {
	font-size: 1.2em;
}

html[transient-theme="plain"] .paragraph-prototype .template {
	display: none;
}

html[transient-theme="plain"] .drop-indicator {
	display: block;
/* 	position: absolute; */
	width: calc(100% + 10px);
	margin-left: -5px;
	
	height: 5px;
	background-color: rgba(0, 0, 0, .1);
}

/* html[transient-dragging="true"],
html[transient-dragging="true"] body {
	background-color: orange;
} */

html[transient-theme="plain"][transient-dragging="true"] .paragraph > *:not(#carousel-definitions) {
	pointer-events: none;
}</STYLE></DIV><DIV class="paragraph style-paragraph collapsed" name="Dialogs" draggable="false" style data-id="XYwHCW5w" __wid="ezL2e6WT"><STYLE data-type="content" type="text/css" codemirror="true" __wid="GHyzyWze">html[transient-theme="plain"] .dialog {
	display: flex;
	flex-direction: column;
	position: fixed;
	top: 100px;
	left: 50%;
	min-width: 400px;
	max-width: calc(100vw - 20px);
/* 	height: 200px; */
	background-color: white;
	z-index: 1001;
	transform: translate3d(-50%, 0, 0);
	box-shadow: 0 5px 15px rgba(0, 0, 0, .5);
	border-radius: 2px;
}

html[transient-theme="plain"] .dialog .button {
	display: inline;
	padding: 5px 20px;
	background-color: rgba(0, 0, 0, .03);
	cursor: pointer;
	border-radius: 2px;
	user-select: none;
}

html[transient-theme="plain"] .dialog .button:hover {
	background-color: rgba(0, 0, 0, .07);
}

html[transient-theme="plain"] .dialog .title,
html[transient-theme="plain"] .dialog .body {
	padding: 5px;
/* 	pointer-events: none; */
}

html[transient-theme="plain"] .dialog .body > * {
	margin-bottom: 10px;
}

html[transient-theme="plain"] .dialog .body input {
	width: 100%;
	font-size: 1em;
	outline: 0;
	border: 0;
	border-bottom: 1px solid rgba(0, 0, 0, .03);
	padding: 5px;
	font-family: Avenir, Arial, sans-serif;
}

html[transient-theme="plain"] .dialog .body input:focus {
	border-bottom-color: rgba(0, 0, 0, .3);
}

html[transient-theme="plain"] .dialog .actions {
	padding: 10px;
}

html[transient-theme="plain"] .dialog .title {
	font-size: 1.2em;
	background-color: rgba(0, 0, 0, 0.03);
}

html[transient-theme="plain"] .dialog .body {
	height: 100%;
	padding: 20px 15px;
/* 	background-color: rgba(0, 0, 0, .75); */
}

html[transient-theme="plain"] .dialog .actions {
	text-align: right;
	border-top: 1px solid rgba(0, 0, 0, .03)
}</STYLE></DIV><DIV class="paragraph style-paragraph collapsed" name="Tooltip" draggable="false" style data-id="nPqywxGd" __wid="tR5hzSqv"><STYLE data-type="content" type="text/css" codemirror="true" __wid="Fhd5A9Lb">html[transient-theme="plain"] *[tooltip]:after {
	position: absolute;
	bottom: 0px;
	left: 50%;
	z-index: 98;
	padding: 5px 15px;
	
	color: white;
	background: #333;
	background-color: rgba(0,0,0,.8);
	border-radius: 2px;
	display: inline;
	width: 200px;
	text-align: center;
	transform: translate3d(-50%, -36px, 0);
	opacity: 0;
	
	pointer-events: none;
	
  -webkit-font-smoothing: antialiased; /* webkit text rendering fix */
}

html[transient-theme="plain"] *[tooltip]:hover:after {
	opacity: 1.0;
	transition: opacity 500ms ease-in-out 1500ms;
}

html[transient-theme="plain"] *[tooltip]:before {
	content: "";
	border: solid;
	bottom: 0;
	border-color: #333 transparent;
	border-color: rgba(0,0,0,.8) transparent;
	border-width: 6px 6px 0 6px;
	left: 50%;
	transform: translate3d(-50%, -30px, 0);
	position: absolute;
	z-index: 99;
	opacity: 0;
	
	pointer-events: none;
	
  -webkit-font-smoothing: antialiased; /* webkit text rendering fix */
}

html[transient-theme="plain"] *[tooltip]:hover:before {
	opacity: 1.0;
	transition: opacity 500ms ease-in-out 1500ms;
}</STYLE></DIV><DIV class="paragraph style-paragraph collapsed" name="Section" draggable="false" data-id="vFJSqWZK" __wid="WTfyJ5eY"><STYLE data-type="content" type="text/css" codemirror="true" __wid="SPwFRpKD">html[transient-theme="plain"] .section {
  position: relative;
	margin-top: 10px;
}

html[transient-theme="plain"] .section.section-hidden,
html[transient-theme="plain"] .section.section-hidden * {
	display: none;
}

html[transient-theme="plain"] .section .section-header {
  display: block;
  height: 36px;
  padding-top: 7px;
  padding-left: 7px;
	color: black;
  background-color: rgba(0, 0, 0, .03);
  font-size: 1.2em;
  margin-bottom: 10px;
  border-radius: 2px;
}

html[transient-theme="plain"] .section .section-header .action {
	position: relative;
  float: right;
  margin-right: 10px;
  cursor: pointer;
  font-size: .6em;
}

/* Icon Add Content */
html[transient-theme="plain"] .section .section-header .add-body-paragraph i:after {
	content: "text_fields";
}

/* Tooltip Add Content */
html[transient-theme="plain"] .section .section-header .add-body-paragraph:after {
	content: "Add Content";
}

/* Icon Add Code */
html[transient-theme="plain"] .section .section-header .add-code-paragraph i:after {
	content: "code";
}

/* Tooltip Add Code */
html[transient-theme="plain"] .section .section-header .add-code-paragraph:after {
	content: "Add Code";
}

/* Icon Add Style */
html[transient-theme="plain"] .section .section-header .add-style-paragraph i:after {
	content: "brush";
}

/* Tooltip Add Style */
html[transient-theme="plain"] .section .section-header .add-style-paragraph:after {
	content: "Add Style";
}

/* Icon Add Data */
html[transient-theme="plain"] .section .section-header .add-data-paragraph i:after {
	content: "storage";
}

/* Tooltip Add Data */
html[transient-theme="plain"] .section .section-header .add-data-paragraph:after {
	content: "Add Data";
}

html[transient-theme="plain"] .section .section-header .name-input {
  position: absolute;
}

html[transient-theme="plain"] .section .section-header .name-input:focus {
  outline: none;
}

html[transient-theme="plain"] .section .section-header .name-input:empty:focus {
  outline: 1px solid white;
  opacity: 1.0;
  animation-name: blink-cursor;
  animation-duration: 500ms;
  animation-direction: alternate;
  animation-iteration-count: infinite;
  animation-timing-function: ease-in-out;
}

html[transient-theme="plain"] .section .section-header .name-input:empty:before {
  content: "No Name";
  opacity: .5;
}

html[transient-theme="plain"] .section .section-header .name-input:empty:focus:before {
  content: "";
}

html[transient-theme="plain"] .section .section-header .delete-section {
  margin-left: 20px;
}

html[transient-theme="plain"] .section .section-header .action {
  opacity: 0.25;
  pointer-events: none;
}

html[transient-theme="plain"] .section .section-header:hover .action {
  opacity: 1.0;
  pointer-events: all;
}

html[transient-theme="plain"] .section .section-header .action:hover {
  color: orange;
}

html[transient-theme="plain"] .section .section-header .delete-section:hover {
  color: red;
}

/* Icon Delete */
html[transient-theme="plain"] .section .section-header .delete-section i:after {
  content: "delete";
}

/* Tooltip Delete */
html[transient-theme="plain"] .section .section-header .delete-section:after {
  content: "Delete";
}

/* Hide Collapsed Sections */
html[transient-theme="plain"] .section.hide-collapsed-paragraphs .paragraph.collapsed {
	display: none;
}

html[transient-theme="plain"] .section.hide-collapsed-paragraphs .hide-collapsed-paragraphs2 {
	opacity: 1.0;
}

/* Icon Show Collapsed Paragraphs */
html[transient-theme="plain"] .section.hide-collapsed-paragraphs .hide-collapsed-paragraphs2 i:after {
  content: "visibility_off";
}

/* Tooltip Show Collapsed Paragraphs */
html[transient-theme="plain"] .section.hide-collapsed-paragraphs .hide-collapsed-paragraphs2:after {
  content: "Show Collapsed Paragraphs";
}

/* Icon Hide Collapsed Paragraphs */
html[transient-theme="plain"] .section:not(.hide-collapsed-paragraphs) .hide-collapsed-paragraphs2 i:after {
  content: "visibility";
}

/* Tooltip Hide Collapsed Paragraphs */
html[transient-theme="plain"] html[transient-theme="plain"] .section:not(.hide-collapsed-paragraphs) .hide-collapsed-paragraphs2:after {
  content: "Hide Collapsed Paragraphs";
}

/* Icon Not System Section */
html[transient-theme="plain"] .section .toggle-system-section i:after {
  content: "extension";
}

/* Tooltip Not System Section */
html[transient-theme="plain"] .section .toggle-system-section:after {
  content: "Activate System Section";
}

/* System Section */
html[transient-theme="plain"] .section[data-type="system"] .toggle-system-section {
  color: lime;
	opacity: 1.0 !important;
}

/* Tooltip Not System Section */
html[transient-theme="plain"] .section[data-type="system"] .toggle-system-section:after {
  content: "Deactivate System Section";
}

/* Icon Not Package Section */
html[transient-theme="plain"] .section .toggle-package-section i:after {
  content: "build";
}

/* Tooltip Not Package Section */
html[transient-theme="plain"] .section .toggle-package-section:after {
  content: "Activate Package Section";
}

/* Package Section */
html[transient-theme="plain"] .section[data-type="package"] .toggle-package-section {
  color: lime;
	opacity: 1.0 !important;
}

/* Tooltip Not Package Section */
html[transient-theme="plain"] .section[data-type="package"] .toggle-package-section:after {
  content: "Deactivate Package Section";
}</STYLE></DIV><DIV class="paragraph style-paragraph collapsed" name="Section Browser" draggable="false" data-id="wVwGj6V9" __wid="8snqCywm"><STYLE data-type="content" type="text/css" codemirror="true" __wid="snwyiHdU">[transient-theme="plain"] #section-tree {
	margin: 0px;
	min-height: 150px;
	padding-left: 0px;
	padding-right: 10px;
	user-select: none;
	overflow: auto;
	list-style: none;
}

[transient-theme="plain"] #section-tree li {
	vertical-align: middle;
	text-overflow: ellipsis;
	white-space: nowrap;
	overflow: hidden;
}

[transient-theme="plain"] #section-tree .closed ul {
	display: none;	
}

[transient-theme="plain"] #section-tree li {
	cursor: pointer;	
}

[transient-theme="plain"] #section-tree li.hidden {
	opacity: 0.5;	
}

[transient-theme="plain"] #section-tree li .title {
	margin-left: 0.5em;
	vertical-align: middle;
}

[transient-theme="plain"] #section-tree li i {
	vertical-align: middle;	
}

[transient-theme="plain"] #section-tree li .type {
	margin-left: 5px;
}</STYLE></DIV><DIV class="paragraph style-paragraph collapsed" name="Paragraph" draggable="false" data-id="WeXgeQSw" __wid="TcDpwPCM"><STYLE data-type="content" type="text/css" codemirror="true" __wid="SPWpuCvp">html[transient-theme="plain"] .paragraph {
  clear: both;
  position: relative;
/*   resize: vertical; */
  margin-top: 10px;
}

html[transient-theme="plain"] .paragraph div:focus {
  outline: none;
}

html[transient-theme="plain"] .paragraph pre {
  margin: 0px;
  padding: 0px;
}

html[transient-theme="plain"] .paragraph pre[type]  {
  display: none;
}

html[transient-theme="plain"] .paragraph.body-paragraph [data-type="content"] {
	position: inherit;
  font-size: 11pt;
  box-sizing: border-box;
  margin: 5px;
	z-index: 0;
}

/* Style achors in text paragraphs */
html[transient-theme="plain"] .paragraph.body-paragraph [data-type="content"] a {
	color: blue;
}

/* Reset box-sizing of content paragraphs to their initial value */
html[transient-theme="plain"] .paragraph.body-paragraph [data-type="content"] * {
  box-sizing: initial;
}

html[transient-theme="plain"] .paragraph .paragraph-header {
  display: block;
  position: relative;
  display: block;
	color: black;
  background: rgba(0, 0, 0, .01);
  width: 100%;
  height: 30px;
  border-radius: 2px;
}

html[transient-theme="plain"] .paragraph .paragraph-header .action {
  position: relative;
  float: right;
  height: 100%;
  
  cursor: pointer;
  margin-right: 10px;
  opacity: .25;
  pointer-events: none;
}

html[transient-theme="plain"] .paragraph .paragraph-header .action:hover {
	color: orange;
}

html[transient-theme="plain"] .paragraph .paragraph-header:hover .action {
  pointer-events: initial;
  opacity: 1.0;
}

html[transient-theme="plain"] .paragraph .paragraph-header .action .material-icons {
  position: relative;
  top: 50%;
  transform: translate3d(0, -50%, 0);
}</STYLE></DIV><DIV class="paragraph style-paragraph collapsed" name="Paragraph Title Style" draggable="false" data-id="TgBuuaLC" __wid="fGhqtiff"><STYLE data-type="content" type="text/css" codemirror="true" __wid="kLzhpu9H">html[transient-theme="plain"] .paragraph .paragraph-header:before {
	font-family: 'Material Icons';
	font-weight: normal;
	font-style: normal;
/* 	font-size: 24px; */
	display: inline-block;
	line-height: 1;
	text-transform: none;
	letter-spacing: normal;
	word-wrap: normal;
	white-space: nowrap;
	direction: ltr;
	-webkit-font-smoothing: antialiased;
	text-rendering: optimizeLegibility;
	-moz-osx-font-smoothing: grayscale;
	font-feature-settings: 'liga';
	
  position: relative;
  top: 7px;
  left: 7px;
}

html[transient-theme="plain"] .paragraph.body-paragraph .paragraph-header:before {
  content: "text_fields";
}

html[transient-theme="plain"] .paragraph.code-paragraph .paragraph-header:before {
  content: "code";
}

html[transient-theme="plain"] .paragraph.style-paragraph .paragraph-header:before {
  content: "brush";
}

html[transient-theme="plain"] .paragraph.data-paragraph .paragraph-header:before {
  content: "storage";
}

html[transient-theme="plain"] .paragraph .paragraph-header .input {
  position: relative;
  top: 5px;
  font-size: .9em;
  z-index: 1;
  display: inline-block;
}


html[transient-theme="plain"] .paragraph .paragraph-header .input:focus {
  outline: none;
}

html[transient-theme="plain"] .paragraph .paragraph-header .input:empty:focus {
  outline: 1px solid white;
  opacity: 1.0;
  animation-name: blink-cursor;
  animation-duration: 500ms;
  animation-direction: alternate;
  animation-iteration-count: infinite;
  animation-timing-function: ease-in-out;
}

html[transient-theme="plain"] .paragraph .paragraph-header .input:empty:before {
  opacity: .5;
}

html[transient-theme="plain"] .paragraph .paragraph-header .input:empty:focus:before {
  content: "";
}

html[transient-theme="plain"] .paragraph .paragraph-header .input {
  left: 15px;
  margin-right: 15px;
}

html[transient-theme="plain"] .paragraph .paragraph-header .input:before {
  color: black;
}

html[transient-theme="plain"] .paragraph .paragraph-header .name-input:empty:before {
  content: "name";
}

html[transient-theme="plain"] .paragraph .paragraph-header .id-input:not(:empty):before {
  content: "#";
}

html[transient-theme="plain"] .paragraph .paragraph-header .id-input:empty:before {
  content: "#id";
}

html[transient-theme="plain"] .paragraph .paragraph-header .class-input:before {
  content: "class: ";
}

html[transient-theme="plain"] .paragraph .paragraph-header .input:empty:before {
  opacity: 0;
  pointer-events: none;
}

html[transient-theme="plain"] .paragraph .paragraph-header:hover .input:empty:before {
  opacity: 1.0;
  pointer-events: all;
}</STYLE></DIV><DIV class="paragraph style-paragraph collapsed" name="Paragraph Collapse Style" draggable="false" style data-id="tLZB4Pyq" __wid="wzejvT9Q"><STYLE data-type="content" type="text/css" codemirror="true" __wid="JA2M3bD2">/* Icon expanded */
html[transient-theme="plain"] .collapse-expand i:after {
  content: "expand_less";
}

/* Tooltip expanded */
html[transient-theme="plain"] .collapse-expand:after {
	content: "Collapse";
}

/* Icon collapsed */
html[transient-theme="plain"] .paragraph.collapsed .collapse-expand i:after {
  content: "expand_more";
}

/* Tooltip collapsed */
html[transient-theme="plain"] .paragraph.collapsed .collapse-expand:after {
	content: "Expand";
}

/* Hide all content of a paragraph except the paragraph header */
html[transient-theme="plain"] .paragraph.collapsed > *:not(.paragraph-header) {
	display: none;
}</STYLE></DIV><DIV class="paragraph style-paragraph collapsed" name="Lock Paragraph Style" draggable="false" data-id="wYrCQ3Jm" __wid="yUwp4nzy"><STYLE data-type="content" type="text/css" codemirror="true" contenteditable="true" __wid="zuaJ5Yvh">html[transient-theme="plain"] .paragraph:not(:hover):not(.locked) .paragraph-header .lock-content {
  opacity: 0.25;
  pointer-events: none;
}

html[transient-theme="plain"] .paragraph.locked .paragraph-header .lock-content {
  opacity: 1.0;
}

html[transient-theme="plain"] .paragraph.locked .text-tools {
  display: none;
}

/* Icon Lock */
html[transient-theme="plain"] .paragraph .paragraph-header .lock-content i:after {
  content: "lock_open";
}

/* Tooltip Lock */
html[transient-theme="plain"] .paragraph .paragraph-header .lock-content:after {
  content: "Lock";
}

/* Icon Unlock */
html[transient-theme="plain"] .paragraph.locked .paragraph-header .lock-content i:after {
  content: "lock_outline";
}

/* Tooltip Unlock */
html[transient-theme="plain"] .paragraph.locked .paragraph-header .lock-content:after {
  content: "Unlock";
}

/* html[transient-theme="plain"] .paragraph.fullscreen .paragraph-header .lock-content {
  display: block;
} */</STYLE></DIV><DIV class="paragraph style-paragraph collapsed" name="Paragraph Delete Action Style" draggable="false" data-id="aKmUAkbu" __wid="Cx2P6WUv"><STYLE data-type="content" type="text/css" codemirror="true" contenteditable="true" __wid="ZY4nAeaZ">html[transient-theme="plain"] .paragraph .delete-paragraph {
  margin-right: 10px;
}

/* Icon Delete */
html[transient-theme="plain"] .paragraph .delete-paragraph i:after {
  content: "delete";
}

/* Tooltip Delete */
html[transient-theme="plain"] .paragraph .delete-paragraph:after {
  content: "Delete";
}

html[transient-theme="plain"] .paragraph .delete-paragraph i:hover:after {
  color: red;
}</STYLE></DIV><DIV class="paragraph style-paragraph collapsed" name="Paragraph Sortable Style" draggable="false" data-id="cezVHSiN" __wid="UcBHi2yG"><STYLE data-type="content" type="text/css" codemirror="true" __wid="knLP9yPf">html[transient-theme="plain"] .paragraph .drag-handle {
  cursor: -webkit-grabbing;
  cursor: move;
  opacity: 0;
  pointer-events: none;
}

html[transient-theme="plain"] .paragraph.dragging > * {
  pointer-events: none;
}

html[transient-theme="plain"] .paragraph.dragging {
  opacity: .5;
}

/* Icon Drag Handle */
html[transient-theme="plain"] .paragraph .drag-handle i:after {
  content: "drag_handle";
}</STYLE></DIV><DIV class="paragraph style-paragraph collapsed" name="Paragraph Code Execution" draggable="false" data-id="gJCLmvnS" __wid="UTENUnnh"><STYLE data-type="content" type="text/css" codemirror="true" __wid="9BmKkgLr">html[transient-theme="plain"] .paragraph .execute-paragraph,
html[transient-theme="plain"] .paragraph .run-on-load-paragraph,
html[transient-theme="plain"] .paragraph .toggle-console-paragraph {
  margin-left: 5px;
}

html[transient-theme="plain"] .paragraph .run-on-load-paragraph {
  margin-right: 10px;
}

html[transient-theme="plain"] .paragraph[run-on-load] .run-on-load-paragraph {
  opacity: 1.0;
  pointer-events: all;
}

/* Icon Execute Code */
html[transient-theme="plain"] .paragraph .execute-paragraph i:after {
  content: "play_circle_outline";
}

/* Tooltip Execute Code */
html[transient-theme="plain"] .paragraph .execute-paragraph:after {
  content: "Execute Code";
}

/* Icon Execute Code on Load */
html[transient-theme="plain"] .paragraph .run-on-load-paragraph i:after {
  content: "directions_run";
}

/* Tooltip Enable Execute Code on Load */
html[transient-theme="plain"] .paragraph .run-on-load-paragraph:after {
  content: "Enable Execute Code on Load";
}

/* Icon Console */
html[transient-theme="plain"] .paragraph .toggle-console-paragraph i:after {
  content: "message";
}

/* Tooltip Console */
html[transient-theme="plain"] .paragraph .toggle-console-paragraph:after {
  content: "Toggle Console";
}

html[transient-theme="plain"] .paragraph[run-on-load] .run-on-load-paragraph i:after {
  color: lime;
}

/* Tooltip Disable Execute Code on Load */
html[transient-theme="plain"] .paragraph[run-on-load] .run-on-load-paragraph:after {
	content: "Disable Execute Code on Load";
}

html[transient-theme="plain"] .paragraph[last-execution-state="error"] .toggle-console-paragraph {
  opacity: 1.0;
}

html[transient-theme="plain"] .paragraph[last-execution-state="error"] .toggle-console-paragraph i:after {
  color: red;
}

html[transient-theme="plain"] .paragraph .paragraph-header .type-input {
  opacity: 0;
}

html[transient-theme="plain"] .paragraph .paragraph-header:hover .type-input {
  opacity: 1;
}

html[transient-theme="plain"] .paragraph .paragraph-header .type-input:before {
  content: "type: ";
}</STYLE></DIV><DIV class="paragraph style-paragraph collapsed" name="Paragraph Style Disable Style" draggable="false" data-id="JWqTqrJE" __wid="xzavBAF5"><STYLE data-type="content" type="text/css" codemirror="true" __wid="hKbw3Bgz">html[transient-theme="plain"] .paragraph:not(:hover):not(.style-disabled) .paragraph-header .disable-style-content {
  opacity: 0.25;
  pointer-events: none;
}

html[transient-theme="plain"] .paragraph.style-disabled .paragraph-header .disable-style-content {
  opacity: 1.0;
}

/* Icon Disable */
html[transient-theme="plain"] .paragraph .paragraph-header .disable-style-content i:after {
  content: "check_box";
}

/* Tooltip Disable */
html[transient-theme="plain"] .paragraph .paragraph-header .disable-style-content:after {
  content: "Disable";
}

/* Icon Enable */
html[transient-theme="plain"] .paragraph.style-disabled .paragraph-header .disable-style-content i:after {
  content: "check_box_outline_blank";
}

/* Tooltip Enable */
html[transient-theme="plain"] .paragraph.style-disabled .paragraph-header .disable-style-content:after {
  content: "Enable";
}</STYLE></DIV><DIV class="paragraph style-paragraph collapsed" name="Fullscreen Style" draggable="false" style data-id="hvPtVVJR" __wid="PDTQaAcA"><STYLE data-type="content" type="text/css" codemirror="true" contenteditable="true" __wid="Vaxpxs8B">html[transient-theme="plain"] body.fullscreen:not([transient-fullscreen="false"]),
html[transient-theme="plain"] body[transient-fullscreen="true"] {
  overflow: hidden;
}

html[transient-theme="plain"] body.fullscreen:not([transient-fullscreen="false"]) .section,
html[transient-theme="plain"] body[transient-fullscreen="true"] .section {
	width: 0;
	height: 0;
	padding: 0;
	margin: 0;
}

/* Hides section toolbar */
html[transient-theme="plain"] body.fullscreen:not([transient-fullscreen="false"]) .section .section-header,
html[transient-theme="plain"] body[transient-fullscreen="true"] .section .section-header {
	opacity: 0;
	pointer-events: none;
}

html[transient-theme="plain"] .paragraph.fullscreen:not([transient-fullscreen="false"]),
html[transient-theme="plain"] .paragraph[transient-fullscreen="true"] {
  position: fixed;
  left: 0;
  top: 0;
  bottom: 0;
  right: 0;
  width: 100vw;
  height: 100vh;
  z-index: 200;
  margin: 0;
  background: rgb(48, 48, 48);
	-webkit-overflow-scrolling: touch; /* enable elastic scroll on touch devices */
}

/* move transient-fullscreen above fullscreen */
html[transient-theme="plain"] .paragraph[transient-fullscreen="true"] {
	z-index: 201;
}

/* Prevent input on paragraphs not in fullscreen view */
html[transient-theme="plain"] body.fullscreen:not([transient-fullscreen="false"]) .paragraph:not(.fullscreen):not([transient-fullscreen="true"]),
html[transient-theme="plain"] body[transient-fullscreen="true"] .paragraph:not([transient-fullscreen="true"]) {
	pointer-events: none;
}

html[transient-theme="plain"] .paragraph.fullscreen:not([transient-fullscreen="false"]) .paragraph-header,
html[transient-theme="plain"] .paragraph.body-paragraph.fullscreen:not([transient-fullscreen="false"]) .text-tools,
html[transient-theme="plain"] .paragraph[transient-fullscreen="true"] .paragraph-header,
html[transient-theme="plain"] .paragraph.body-paragraph[transient-fullscreen="true"] .text-tools {
  position: fixed;
	z-index: 1;
}

/* "Hide" paragraph utils when in locked fullscreen view */
html[transient-theme="plain"] .paragraph.locked.fullscreen:not([transient-fullscreen="false"]) .paragraph-header,
html[transient-theme="plain"] .paragraph.locked[transient-fullscreen="true"] .paragraph-header {
	height: 0;
}

/* Position toggle fullscreen button in locked fullscreen view */
html[transient-theme="plain"] .paragraph.locked.fullscreen:not([transient-fullscreen="false"]) .paragraph-header > .toggle-fullscreen,
html[transient-theme="plain"] .paragraph.locked[transient-fullscreen="true"] .paragraph-header > .toggle-fullscreen {
	position: absolute;
	top: 20px;
	right: 10px;
}

/* Position toggle fullscreen button in locked fullscreen view */
html[transient-theme="plain"] .paragraph.locked.fullscreen:not([transient-fullscreen="false"]) .paragraph-header > .lock-content,
html[transient-theme="plain"] .paragraph.locked[transient-fullscreen="true"] .paragraph-header > .lock-content {
	position: absolute;
	top: 20px;
	right: 40px;
}

/* !!! Bug: make actions interactive */
html[transient-theme="plain"] .paragraph.locked.fullscreen:not([transient-fullscreen="false"]) .paragraph-header .action,
html[transient-theme="plain"] .paragraph.locked[transient-fullscreen="true"] .paragraph-header .action {
	pointer-events: initial;
}

/* Hide paragraph icon */
html[transient-theme="plain"] .paragraph.locked.fullscreen:not([transient-fullscreen="false"]) .paragraph-header:before,
html[transient-theme="plain"] .paragraph.locked[transient-fullscreen="true"] .paragraph-header:before {
	display: none;
}

html[transient-theme="plain"] .paragraph.fullscreen:not([transient-fullscreen="false"]) .paragraph-header .delete-paragraph,
html[transient-theme="plain"] .paragraph.fullscreen:not([transient-fullscreen="false"]) .paragraph-header .drag-handle,
html[transient-theme="plain"] .paragraph.fullscreen:not([transient-fullscreen="false"]) .paragraph-header .collapse-expand,
html[transient-theme="plain"] .paragraph[transient-fullscreen="true"] .paragraph-header .delete-paragraph,
html[transient-theme="plain"] .paragraph[transient-fullscreen="true"] .paragraph-header .drag-handle,
html[transient-theme="plain"] .paragraph[transient-fullscreen="true"] .paragraph-header .collapse-expand {
	display: none;
}

/* Hide all paragraph actions excluding lock and toggle fullscreen */
html[transient-theme="plain"] .paragraph.locked.fullscreen:not([transient-fullscreen="false"]) .paragraph-header > *:not(.lock-content):not(.toggle-fullscreen),
html[transient-theme="plain"] .paragraph.locked[transient-fullscreen="true"] .paragraph-header > *:not(.lock-content):not(.toggle-fullscreen) {
	display: none;
}

html[transient-theme="plain"] .paragraph.body-paragraph.fullscreen:not([transient-fullscreen="false"]) .text-tools,
html[transient-theme="plain"] .paragraph.body-paragraph[transient-fullscreen="true"] .text-tools {
  top: 30px;
}

html[transient-theme="plain"] .paragraph.fullscreen:not([transient-fullscreen="false"]) .CodeMirror,
html[transient-theme="plain"] .paragraph[transient-fullscreen="true"] .CodeMirror {
	width: 100vw;
  height: 100vh;
	overflow: hidden !important;
  overflow-y: auto;
}


html[transient-theme="plain"] .paragraph.fullscreen:not([transient-fullscreen="false"]):not(.locked) .CodeMirror,
html[transient-theme="plain"] .paragraph[transient-fullscreen="true"]:not(.locked) .CodeMirror {
  height: calc(100vh - 30px);
  overflow: auto;
}

/* Move CodeMirror down to make space for fixed paragraph utils */
html[transient-theme="plain"] .paragraph.fullscreen:not([transient-fullscreen="false"]):not(.locked) .CodeMirror,
html[transient-theme="plain"] .paragraph[transient-fullscreen="true"]:not(.locked) .CodeMirror {
  margin-top: 30px;
}

/* This is a HACK as text paragraph cannot be scrolled in fullscreen otherwise */
html[transient-theme="plain"] .paragraph.body-paragraph.fullscreen:not([transient-fullscreen="false"]) [data-type="content"],
html[transient-theme="plain"] .paragraph.body-paragraph[transient-fullscreen="true"] [data-type="content"] {
	margin: 0;
	padding: 0;
	width: 100vw;
	height: 100vh;
  overflow: auto;
}

/* Move CodeMirror down to make space for fixed paragraph utils + text tools */
html[transient-theme="plain"] .paragraph.body-paragraph.fullscreen:not([transient-fullscreen="false"]):not(.locked) [data-type="content"],
html[transient-theme="plain"] .paragraph.body-paragraph[transient-fullscreen="true"]:not(.locked) [data-type="content"] {
	position: absolute;
  top: 75px;
  height: calc(100vh - 75px);
}

/* Icon Fullscreen */
html[transient-theme="plain"] .paragraph .paragraph-header .toggle-fullscreen i:after {
  content: "fullscreen";
}

/* Tooltip Fullscreen */
html[transient-theme="plain"] .paragraph .paragraph-header .toggle-fullscreen:after {
  content: "Fullscreen";
}

/* Icon Exit Fullscreen */
html[transient-theme="plain"] .paragraph.fullscreen:not([transient-fullscreen="false"]) .paragraph-header .toggle-fullscreen i:after,
 html[transient-theme="plain"] .paragraph[transient-fullscreen="true"] .paragraph-header .toggle-fullscreen i:after {
  content: "fullscreen_exit";
}

/* Tooltip Exit Fullscreen */
html[transient-theme="plain"] .paragraph.fullscreen:not([transient-fullscreen="false"]) .paragraph-header .toggle-fullscreen:after,
html[transient-theme="plain"] .paragraph[transient-fullscreen="true"] .paragraph-header .toggle-fullscreen:after {
  content: "Exit Fullscreen";
}</STYLE></DIV><DIV class="paragraph style-paragraph collapsed" name="Text Tools Style" draggable="false" data-id="FfHi4JRF" __wid="hcX7nfQn"><STYLE data-type="content" type="text/css" codemirror="true" contenteditable="true" __wid="UZHw96Ei">html[transient-theme="plain"] .text-tools {
/* 	position: relative; */
  display: block;
  width: 100%;
	color: black;
  background-color: rgba(0, 0, 0, .01);
  padding: 5px;
  padding-top: 10px;
  margin-top: 1px;
  border-radius: 2px;
  
/*  border-top: 1px solid rgba(255, 255, 255, .1);*/
  
  -webkit-user-select: none;  /* Chrome all / Safari all */
  -moz-user-select: none;     /* Firefox all */
  -ms-user-select: none;      /* IE 10+ */
  user-select: none;          /* Likely future */   
}

html[transient-theme="plain"] .paragraph.collapsed .text-tools {
  display: none;
}

html[transient-theme="plain"] .text-tools .action {
	position: relative;
  cursor: pointer;
  display: inline-block;
  margin-left: 5px;
}

html[transient-theme="plain"] .text-tools .action:hover {
  color: orange;
}

/* Icon Bold */
html[transient-theme="plain"] .text-tools .text-bold i:after {
  content: "format_bold";
}

/* Tooltip Bold */
html[transient-theme="plain"] .text-tools .text-bold:after {
  content: "Bold";
}

/* Icon Italic */
html[transient-theme="plain"] .text-tools .text-italic i:after {
  content: "format_italic";
}

/* Tooltip Italic */
html[transient-theme="plain"] .text-tools .text-italic:after {
  content: "Italic";
}

/* Icon Underline */
html[transient-theme="plain"] .text-tools .text-underline i:after {
  content: "format_underline";
}

/* Tooltip Underline */
html[transient-theme="plain"] .text-tools .text-underline:after {
  content: "Underline";
}

/* Icon Strikethrough */
html[transient-theme="plain"] .text-tools .text-strikethrough i:after {
  content: "format_strikethrough";
}

/* Tooltip Strikethrough */
html[transient-theme="plain"] .text-tools .text-strikethrough:after {
  content: "Strikethrough";
}

/* Icon Bullets */
html[transient-theme="plain"] .text-tools .text-list-bulleted i:after {
  content: "format_list_bulleted";
}

/* Tooltip Bullets */
html[transient-theme="plain"] .text-tools .text-list-bulleted:after {
  content: "Bullets";
}

/* Icon Numbering */
html[transient-theme="plain"] .text-tools .text-list-numbered i:after {
  content: "format_list_numbered";
}

/* Tooltip Numbering */
html[transient-theme="plain"] .text-tools .text-list-numbered:after {
  content: "Numbering";
}

/* Icon Increase Indent */
html[transient-theme="plain"] .text-tools .text-list-indent i:after {
  content: "format_indent_increase";
}

/* Tooltip Increase Indent */
html[transient-theme="plain"] .text-tools .text-list-indent:after {
  content: "Increase Indent";
}

/* Icon Decrease Indent */
html[transient-theme="plain"] .text-tools .text-list-outdent i:after {
  content: "format_indent_decrease";
}

/* Tooltip Decrease Indent */
html[transient-theme="plain"] .text-tools .text-list-outdent:after {
  content: "Decrease Indent";
}

/* Icon Clear Formatting */
html[transient-theme="plain"] .text-tools .clear-format i:after {
  content: "format_clear";
}

/* Tooltip Clear Formatting */
html[transient-theme="plain"] .text-tools .clear-format:after {
  content: "Clear Formatting";
}

html[transient-theme="plain"] .text-tools .text-h1,
html[transient-theme="plain"] .text-tools .text-h2,
html[transient-theme="plain"] .text-tools .text-h3,
html[transient-theme="plain"] .text-tools .text-set-variable,
html[transient-theme="plain"] .text-tools .text-hide-variable-names, 
html[transient-theme="plain"] .text-tools .text-convert-to-html {
  margin-left: 10px;
  margin-top: 2px;
  vertical-align: top;
}

/* Tooltip Section */
html[transient-theme="plain"] .text-tools .text-h1:after {
	content: "Format Heading 1"
}

/* Tooltip Subsection */
html[transient-theme="plain"] .text-tools .text-h2:after {
	content: "Format Heading 2"
}

/* Tooltip Subsection */
html[transient-theme="plain"] .text-tools .text-h3:after {
	content: "Format Heading 3"
}

/* Tooltip Add Variable */
html[transient-theme="plain"] .text-tools .text-set-variable:after {
	content: "Add Variable"
}

/* Tooltip Hide Variable Names */
html[transient-theme="plain"] .text-tools .text-hide-variable-names:after {
	content: "Hide Variable Names"
}

/* Tooltip Convert HTML */
html[transient-theme="plain"] .text-tools .text-convert-to-html:after {
	content: "Convert HTML"
}</STYLE></DIV><DIV class="paragraph style-paragraph collapsed" name="Variable Style" draggable="false" data-id="hx9pQUnE" __wid="Wsg6EZSe"><STYLE data-type="content" type="text/css" codemirror="true" __wid="RsrgFQ3f">html[transient-theme="plain"] .variable {
	position: relative;
	display: inline;
	color: deepskyblue;
}

html[transient-theme="plain"] .variable:empty:before {
	content: attr(data-name) " (unset)";
}

html[transient-theme="plain"] .variable:before {
	content: attr(data-name) " = ";
	color: orange;
	opacity: .5;
}

html[transient-theme="plain"] .hide-variable-names .variable:not(:empty):before {
	display: none;
}

html[transient-theme="plain"] .hide-variable-names .variable:not(:empty):hover:before {
	content: attr(data-name);
	position: absolute;
	top: 0;
	left: 0;
	transform: translate3d(0, -100%, 0);
	display: inline-block;
	border-radius: 2px;
	font-size: .8em;
	padding: 2px;

	color: white;
	background: rgb(135, 135, 129);
	opacity: 1.0;
	/*border: 5px solid transparent;*/
}</STYLE></DIV><DIV class="paragraph style-paragraph collapsed" name="Drop Assets Style" draggable="false" style data-id="2hkzAaHe" __wid="YuBnKW8X"><STYLE data-type="content" type="text/css" codemirror="true" __wid="r54iAYLD">html[transient-theme="plain"] .paragraph [data-type="content"] .upload-in-progress {
  opacity: .25;
}

html[transient-theme="plain"] .paragraph [data-type="content"] video,
html[transient-theme="plain"] .paragraph [data-type="content"] img {
  max-width: 100%;
}</STYLE></DIV><DIV class="paragraph style-paragraph collapsed" name="Add File Style" draggable="false" data-id="56NcGWvs" __wid="GQG9ti5a"><STYLE data-type="content" type="text/css" codemirror="true" __wid="ZuhJbmet">/* Hide native upload file UI element */
html[transient-theme="plain"] .add-file input[type="file"] {
  display: none;
}

/* Icon Upload File */
html[transient-theme="plain"] .add-file label.material-icons:after {
  content: "file_upload";
}

/* Tooltip Upload File */
html[transient-theme="plain"] .add-file:after {
  content: "Upload File";
}</STYLE></DIV><DIV class="paragraph style-paragraph collapsed" draggable="false" name="Remote Cursors" data-id="k7SYPBgJ" __wid="jZYgYf8M"><STYLE data-type="content" type="text/css" codemirror="true" __wid="AeZxRuML">html[transient-theme="plain"] .client {
	width: 100px;
	height: 1em;
	margin: 1px;
	padding: 1px;
	display: inline-block;
}

html[transient-theme="plain"] .cursor {
	position: absolute;
	user-select: none;
	pointer-events: none;
}

html[transient-theme="plain"] .cursor .rect {
  /* darken when black color font */
	mix-blend-mode: darken;
}

html[transient-theme="plain"] .cursor .end {
	opacity: 1.0;
	width: 2px;
}

html[transient-theme="plain"] .cursor .end .displayName {
	position: absolute;
	padding: 2px;
	white-space: pre;
	top: -100%;
	font-size: 9pt;
	animation: hide 4s ease 1 normal;
	opacity: 0;
	font-weight: bold;
}

@-webkit-keyframes hide {
	0% { opacity: 1; }
	80% { opacity: 1; }
	100% { opacity: 0; }
}

html[transient-theme="plain"] .cursor .rect {
	border-left: none;
}

html[transient-theme="plain"] .cursor .rect ~ .rect {
	border: none;
}</STYLE></DIV><DIV class="paragraph style-paragraph collapsed" name="CodeMirror Neo Theme" draggable="false" data-id="aGtdRDb8" __wid="Su9cLryB"><STYLE data-type="content" type="text/css" codemirror="true" __wid="RdHHabfa">/* neo theme for codemirror */

/* Color scheme */

[transient-theme="plain"] .CodeMirror {
	background-color:#ffffff !important;
	color:#2e383c !important;
}

[transient-theme="plain"] .cm-comment { color:#75787b !important; }
[transient-theme="plain"] .cm-keyword,
[transient-theme="plain"] .cm-property { color:#1d75b3 !important; }
[transient-theme="plain"] .cm-atom,
[transient-theme="plain"] .cm-number { color:#75438a !important; }
[transient-theme="plain"] .cm-node,
[transient-theme="plain"] .cm-tag { color:#9c3328 !important; }
[transient-theme="plain"] .cm-string { color:#b35e14 !important; }
[transient-theme="plain"] .cm-variable,
[transient-theme="plain"] .cm-qualifier { color:#047d65 !important; }
[transient-theme="plain"] .cm-attribute { color: green !important; }


/* Editor styling */

[transient-theme="plain"] pre {
	padding:0;
}

[transient-theme="plain"] .CodeMirror-gutters {
	border:none;
	border-right:10px solid transparent;
	background-color:transparent;
}

[transient-theme="plain"] .CodeMirror-linenumber {
	padding:0;
	color:#e0e2e5;
}

[transient-theme="plain"] .CodeMirror-guttermarker { color: #1d75b3; }
[transient-theme="plain"] .CodeMirror-selected { background: rgba(0, 0, 0, .1) !important; }
[transient-theme="plain"] .CodeMirror-matchingbracket { color: #1d75b3 !important; }
[transient-theme="plain"] .CodeMirror-guttermarker-subtle { color: #e0e2e5; }

[transient-theme="plain"] .CodeMirror-cursor {
	width: auto;
	border: 0;
	background: rgba(155,157,162,0.37);
	z-index: 1;
}</STYLE></DIV><DIV class="paragraph style-paragraph collapsed" draggable="false" name="CodeMirror integration CSS" data-id="jnd6rkFy" __wid="htxmAyKZ"><STYLE data-type="content" type="text/css" codemirror="true" __wid="mDFp9ghW">html[transient-theme="plain"] .CodeMirror {
  isolation: isolate;
  height: auto;
  font-family: "Menlo", "consolas", monospace;
  font-size: 11pt;
  height: auto;
  -webkit-font-smoothing: antialiased;
  clear: both;
}

html[transient-theme="plain"] .CodeMirror span.cm-matchhighlight {
    background-color: rgba(0, 0, 0, .1);
}

html[transient-theme="plain"] .CodeMirror .CodeMirror-activeline-background {
  background-color: rgba(0, 0, 0, .05);
}

html[transient-theme="plain"] .paragraph.body-paragraph>transient.hidden {
  display: none;
}

html[transient-theme="plain"] .paragraph.body-paragraph transient.html-editor:before {
  content: "HTML of the above";
  display: block;
  margin-top: 20px;
  background-color: rgba(0, 0, 0, .01);
  padding: 3px;
  border-radius: 2px;
  pointer-events: none;
  clear: both;
}

/* Icon Save HTML */

html[transient-theme="plain"] .paragraph .paragraph-header .save-html i:after {
  content: "save";
}

/* Tooltip Save HTML */

html[transient-theme="plain"] .paragraph .paragraph-header .save-html:after {
  content: "Save HTML";
}

html[transient-theme="plain"] .paragraph .paragraph-header .toggle-html i:after {
  content: "visibility";
}

html[transient-theme="plain"] .paragraph .paragraph-header .toggle-html:after {
  content: "Toggle HTML Editor";
}</STYLE></DIV></DIV><DIV class="section section-hidden" name="Example #1 - Grocery list" data-id="Q6m8x6LL" data-type="system" __wid="zXf8Bujj"><DIV class="paragraph body-paragraph" draggable="false" style name="About" data-id="NRHCbP5k" __wid="8DfFBsK6"><DIV data-type="content" type="text/html" codemirror="true" contenteditable="true" __wid="q3EPPvXc">This is a minimal implementation of a grocery list. Items can be added and checked off by clicking them. The paragraph <I __wid="hhmyZRgw">Groceries</I>Â is the main view, <I __wid="Q5nmbaud">Grocery code</I>Â contains the JavaScript code (note that the little green man is toggled meaning that it will run on load) and <I __wid="vSUVEVhY">Grocery style</I>Â contains the styling.<DIV __wid="Vb3ZkcuY"><BR __wid="5HWe2SZy"/></DIV><DIV __wid="fgAYBCmN">What you see below is everything needed to create a simple application that functions between users and across devices.</DIV></DIV></DIV><DIV class="paragraph body-paragraph locked" name="Groceries" style data-id="weHsfMDB" __wid="iCjMFC39"><DIV data-type="content" type="text/html" codemirror="true" contenteditable="false" id="groceries" __wid="JbGinY4G"><INPUT id="new-item" placeholder="What needs to be bought?" autofocus="autofocus" __wid="kLJR33Xb"/></DIV></DIV><DIV class="paragraph code-paragraph" style name="Grocery code" run-on-load="true" last-execution-state="success" data-id="sRSZkYAN" __wid="QdMJfDqA"><PRE data-type="content" type="text/javascript" __wid="Y4g8dNw8">var groceries = document.querySelector("#groceries");
var newItem = document.querySelector("#new-item");

newItem.addEventListener("keyup", (event) => {
	if (event.key == "Enter") {
		var text = newItem.value;
		newItem.value = "";
		var item = document.createElement("div");
		item.classList.add("item");
		item.innerText = text;
		groceries.appendChild(item);
	}
});

groceries.addEventListener("click", (event) => {
	if (!event.target.classList.contains("item")) return;
	event.target.classList.toggle("finished");
});</PRE></DIV><DIV class="paragraph style-paragraph" style name="Grocery style" data-id="zg3HhmnS" __wid="hdWjiS8Q"><STYLE data-type="content" type="text/css" codemirror="true" __wid="dK4e3TvU">#groceries {
	background-color: white;
	min-height: 200px;
	color: black;
	text-align: center;
}

.item {
	transition: opacity 1s;
	font-size: 18pt;
	cursor: pointer;
}

.finished {
	text-decoration: line-through;
	opacity: 0.2;
}

#new-item {
	font-size: 16pt;
	width: 12em;
	margin-bottom: 50px;
	margin-top: 50px;
	text-align: center;
}</STYLE></DIV></DIV><DIV class="section section-hidden" data-id="33LePuGS" name="Example #2 - Jokes" data-type="system" __wid="3U9Yddzv"><DIV class="paragraph body-paragraph locked" data-id="JXkq7umn" name="Tell a Joke" __wid="x2iuYUuj"><DIV data-type="content" type="text/html" codemirror="true" contenteditable="false" id="joke" __wid="gEAqwEcC"><BUTTON __wid="YLZ8rg3Y">
	Tell a joke!
</BUTTON></DIV></DIV><DIV class="paragraph style-paragraph" data-id="TSjb9uu4" name="Joke style" __wid="QKXn77q4"><STYLE data-type="content" type="text/css" codemirror="true" __wid="yKwkf3PM">#joke {
	background-color: white;
	text-align: center;
	min-height: 200px;
}

#joke button {
	position: absolute;
	font-size: 18pt;
	top: 50%;
	left: 50%;
	transform: translate(-50%, -50%);
}</STYLE></DIV><DIV class="paragraph code-paragraph" data-id="XGWgqyeB" name="Event handling" last-execution-state="success" style run-on-load="true" __wid="vfSbPJqf"><PRE data-type="content" type="text/javascript" __wid="kkFu2R4J">const read = require("#readaloud").read;
document.querySelector("#joke button").addEventListener("click", () =>{
	const jokes = require("#jokedata");
	const joke = jokes[Math.floor(Math.random()*jokes.length)];
	read(joke);
});</PRE></DIV><DIV class="paragraph code-paragraph" data-id="76qHP7vU" draggable="false" style name="Read text aloud" __wid="NCuQwSqV"><PRE data-type="content" type="text/javascript" id="readaloud" __wid="DPZcyhZc">exports.read = (text) => {
	var msg = new SpeechSynthesisUtterance(text);
	window.speechSynthesis.speak(msg);
};</PRE></DIV><DIV class="paragraph data-paragraph" data-id="JreFDTJA" name="List of jokes" style __wid="za5r4nTZ"><PRE data-type="content" type="application/json" id="jokedata" __wid="X6qDUhk5">[
	"The closest Iâve been to a diet this year is erasing food searches from my browser history.",
	"Last time I got caught stealing a calendar I got 12 months.",
	"Anton, do you think Iâm a bad mother? My name is Paul.",
	"My dog used to chase people on a bike a lot. It got so bad, finally I had to take his bike away.",
	"They threw me out of the cinema today for bringing my own food. But come on â the prices are way too high, plus I havenât had a barbecue in months.",
	"I got another letter from this lawyer today. It said âFinal Noticeâ. Good that he will not bother me anymore.",
	"How do you make a tissue dance? You put a little boogie in it.",
	"Why does Snoop Dogg carry an umbrella? FO DRIZZLE!",
	"What did the Zen Buddist say to the hotdog vendor? Make me one with everything.",
	"The past, present and future walk into a bar. It was tense.",
	"Whatâs brown and sticky? A stick!",
	"Why are pirates so mean? I donât know, they just arrrrrrrrr!",
	"How do you make holy water? You boil the hell out of it.",
	"Why did the storm trooper buy an iphone? He couldnât find the Droid he was looking for.",
	"Bacon and eggs walk into a bar and order a beer, the bartender says sorry, we donât serve breakfast."
]</PRE></DIV></DIV><DIV class="section section-visible" __wid="BvAeS9w4" data-id="33LePuGS"></DIV></DIV>

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	</BODY></html>
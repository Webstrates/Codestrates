<!doctype html>
<html __wid="8iiFCgMH" data-auth="[{&quot;username&quot;:&quot;raedle&quot;,&quot;provider&quot;:&quot;github&quot;,&quot;permissions&quot;:&quot;rw&quot;},{&quot;username&quot;:&quot;cklokmose&quot;,&quot;provider&quot;:&quot;github&quot;,&quot;permissions&quot;:&quot;rw&quot;},{&quot;username&quot;:&quot;kbadk&quot;,&quot;provider&quot;:&quot;github&quot;,&quot;permissions&quot;:&quot;rw&quot;},{&quot;username&quot;:&quot;MidasN&quot;,&quot;provider&quot;:&quot;github&quot;,&quot;permissions&quot;:&quot;rw&quot;},{&quot;username&quot;:&quot;anonymous&quot;,&quot;provider&quot;:&quot;&quot;,&quot;permissions&quot;:&quot;r&quot;}]" class="gr__webstrates_cs_au_dk"><HEAD __wid="nyQjClRO"><META name="mobile-web-app-capable" content="yes" __wid="VC-iR3Y0"/><META name="apple-mobile-web-app-capable" content="yes" __wid="h-Ul6mwY"/><META name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no" __wid="iiS6bfZA"/><SCRIPT id="script-main" __wid="dOK1EoH0">webstrate.on("loaded", function () { new Function(document.querySelector("#bootstrap").textContent)(); });</SCRIPT></HEAD><BODY __wid="KajDX5Up">
<DIV name="Bootstrapping" class="section section-hidden" data-type="system" __wid="uWU3qI-P"><DIV class="paragraph body-paragraph locked collapsed" name="Codestrate Bootstrapping" draggable="false" __wid="ea3S530f"><DIV data-type="content" contenteditable="false" __wid="kou2NaB9"><H1 __wid="ytVjddnZ">Documentation</H1>Now one line left in the script tag. The #bootstrap code is executed on webstrate "loaded" event, which is defined in the script in the head of this document. The #bootstrap code then executes all code that has a class .pre-bootstrap before any of the Codestrate code is executed.<H2 __wid="0BijmegU">Attention</H2><DIV __wid="oK-_w_VV"><UL __wid="NbAvMkfo"><LI __wid="h-ZU1cPN">Do not change the id of the bootstrap code. It needs to be #bootstrap, otherwise the Codestrate will not load properly.<BR __wid="0y8hZPKE"/></LI></UL></DIV></DIV></DIV><DIV class="paragraph code-paragraph collapsed" name="Bootstrap Code" draggable="false" last-execution-state="success" __wid="1yxNxzPp"><PRE data-type="content" type="text/javascript" id="bootstrap" __wid="oge-KtDX">window.getParameterByName = function(name, url) {
	if (!url) {
		url = window.location.href;
	}
	name = name.replace(/[\[\]]/g, "\\$&");
	var regex = new RegExp("[?&]" + name + "(=([^&#]*)|&|#|$)"),
			results = regex.exec(url);
	if (!results) return null;
	if (!results[2]) return '';
	return decodeURIComponent(results[2].replace(/\+/g, " "));
}

const exec = getParameterByName("exec");

// Do not execute bootstrap code
if (exec === "no") {
// 	const loadedEvent = new CustomEvent("codestrateloaded");
// 	window.dispatchEvent(loadedEvent);
	return;
}

const Codestrate = window.Codestrate = window.Codestrate || {};

/**
 * Execute bootstrap modules. All code paragraphs with bootstrap-module class will
 * be executed in the order in which they are defined. Changing the order can
 * break the Codestrate.
 */
var modules = document.querySelectorAll(".bootstrap-module");

if (!modules) return;

var len = modules.length;
for (var i = 0; i &lt; len; i++) {
	new Function(modules[i].textContent)();
}</PRE></DIV><DIV class="paragraph code-paragraph collapsed" draggable="false" name="Get Parameter By Name Function" __wid="XE3VRW_f"><PRE data-type="content" type="text/javascript" __wid="Ys_1SfiA">window.getParameterByName = function(name, url) {
	if (!url) {
		url = window.location.href;
	}
	name = name.replace(/[\[\]]/g, "\\$&");
	var regex = new RegExp("[?&]" + name + "(=([^&#]*)|&|#|$)"),
			results = regex.exec(url);
	if (!results) return null;
	if (!results[2]) return '';
	return decodeURIComponent(results[2].replace(/\+/g, " "));
}</PRE></DIV><DIV class="paragraph code-paragraph collapsed" draggable="false" name="Polyfills" __wid="qBgOkNWA"><PRE data-type="content" type="text/javascript" class="bootstrap-module" __wid="Nt1_5WRY">console.log('Polyfills');

if (window.Element && !Element.prototype.closest) {

	console.log('Adding polyfill for Element.prototype.closest');

	Element.prototype.closest = 
		function(s) {
		var matches = (this.document || this.ownerDocument).querySelectorAll(s),
				i,
				el = this;
		do {
			i = matches.length;
			while (--i >= 0 && matches.item(i) !== el) {};
		} while ((i &lt; 0) && (el = el.parentElement)); 
		return el;
	};
}

if (!Element.prototype.matches) {

	console.log('Adding polyfill for Element.prototype.matches');

	Element.prototype.matches = 
		Element.prototype.matchesSelector || 
		Element.prototype.mozMatchesSelector ||
		Element.prototype.msMatchesSelector || 
		Element.prototype.oMatchesSelector || 
		Element.prototype.webkitMatchesSelector ||
		function(s) {
		var matches = (this.document || this.ownerDocument).querySelectorAll(s),
				i = matches.length;
		while (--i >= 0 && matches.item(i) !== this) {}
		return i > -1;            
	};
}

// Production steps of ECMA-262, Edition 5, 15.4.4.18
// Reference: http://es5.github.io/#x15.4.4.18
if (!Array.prototype.forEach) {

	console.log('Adding polyfill for Array.prototype.forEach');

	Array.prototype.forEach = function(callback/*, thisArg*/) {

		var T, k;

		if (this == null) {
			throw new TypeError('this is null or not defined');
		}

		// 1. Let O be the result of calling toObject() passing the
		// |this| value as the argument.
		var O = Object(this);

		// 2. Let lenValue be the result of calling the Get() internal
		// method of O with the argument "length".
		// 3. Let len be toUint32(lenValue).
		var len = O.length >>> 0;

		// 4. If isCallable(callback) is false, throw a TypeError exception. 
		// See: http://es5.github.com/#x9.11
		if (typeof callback !== 'function') {
			throw new TypeError(callback + ' is not a function');
		}

		// 5. If thisArg was supplied, let T be thisArg; else let
		// T be undefined.
		if (arguments.length > 1) {
			T = arguments[1];
		}

		// 6. Let k be 0
		k = 0;

		// 7. Repeat, while k &lt; len
		while (k &lt; len) {

			var kValue;

			// a. Let Pk be ToString(k).
			//    This is implicit for LHS operands of the in operator
			// b. Let kPresent be the result of calling the HasProperty
			//    internal method of O with argument Pk.
			//    This step can be combined with c
			// c. If kPresent is true, then
			if (k in O) {

				// i. Let kValue be the result of calling the Get internal
				// method of O with argument Pk.
				kValue = O[k];

				// ii. Call the Call internal method of callback with T as
				// the this value and argument list containing kValue, k, and O.
				callback.call(T, kValue, k, O);
			}
			// d. Increase k by 1.
			k++;
		}
		// 8. return undefined
	};
}</PRE></DIV><DIV class="paragraph code-paragraph collapsed" draggable="false" name="Loading Indicator" __wid="Ez3S91KW"><PRE data-type="content" type="text/javascript" class="bootstrap-module" __wid="sg6hIbdx">// Hide document while loading all external webstrates.
const loadingContainer = document.createElement("transient");
loadingContainer.setAttribute("id", "active-essay-loading");

const centerPiece = document.createElement("div");

const loadingIndicator = document.createElement("div");

centerPiece.appendChild(loadingIndicator);
loadingContainer.appendChild(centerPiece);

document.body.appendChild(loadingContainer);

let readyCounter = 0;

++readyCounter;
window.addEventListener("codestrateloaded", function () {
	--readyCounter;

	if (readyCounter &lt; 1) {
		loadingContainer.remove();
	}
});

if (typeof Transclusion !== 'undefined') {
	++readyCounter;
	window.addEventListener("externalwebstratesloaded", function () {
		--readyCounter;

		if (readyCounter &lt; 1) {
			loadingContainer.remove();
		}
	});
}</PRE></DIV><DIV class="paragraph style-paragraph collapsed" draggable="false" name="Loading Style" __wid="x_Nh_5fv"><STYLE data-type="content" type="text/css" codemirror="true" __wid="CkjDjsbp">@-webkit-keyframes rotateplane {
  0% {
    -webkit-transform: perspective(120px);
  }
  50% {
    -webkit-transform: perspective(120px) rotateY(180deg);
  }
  100% {
    -webkit-transform: perspective(120px) rotateY(180deg) rotateX(180deg);
  }
}

@-moz-keyframes rotateplane {
  0% {
    -moz-transform: perspective(120px);
  }
  50% {
    -moz-transform: perspective(120px) rotateY(180deg);
  }
  100% {
    -moz-transform: perspective(120px) rotateY(180deg) rotateX(180deg);
  }
}

@-o-keyframes rotateplane {
  0% {
    -o-transform: perspective(120px);
  }
  50% {
    -o-transform: perspective(120px) rotateY(180deg);
  }
  100% {
    -o-transform: perspective(120px) rotateY(180deg) rotateX(180deg);
  }
}

@keyframes rotateplane {
  0% {
    -webkit-transform: perspective(120px) rotateX(0deg) rotateY(0deg);
    -moz-transform: perspective(120px) rotateX(0deg) rotateY(0deg);
    -o-transform: perspective(120px) rotateX(0deg) rotateY(0deg);
    transform: perspective(120px) rotateX(0deg) rotateY(0deg);
  }
  50% {
    -webkit-transform: perspective(120px) rotateX(-180.1deg) rotateY(0deg);
    -moz-transform: perspective(120px) rotateX(-180.1deg) rotateY(0deg);
    -o-transform: perspective(120px) rotateX(-180.1deg) rotateY(0deg);
    transform: perspective(120px) rotateX(-180.1deg) rotateY(0deg);
  }
  100% {
    -webkit-transform: perspective(120px) rotateX(-180deg) rotateY(-179.9deg);
    -moz-transform: perspective(120px) rotateX(-180deg) rotateY(-179.9deg);
    -o-transform: perspective(120px) rotateX(-180deg) rotateY(-179.9deg);
    transform: perspective(120px) rotateX(-180deg) rotateY(-179.9deg);
  }
}

#active-essay-loading {
  position: fixed;
  display: block;
  top: 0;
  left: 0;
  bottom: 0;
  right: 0;
  /*background: rgba(255, 255, 255, .5);*/
/*  background: white;*/
  background: rgba(48, 48, 48, 1.0);
  width: 100vw;
  height: 100vh;
  z-index: 999999;
}

#active-essay-loading>div {
  position: relative;
  display: inline-block;
  left: 50%;
  top: 50%;
  transform: translate3d(-50%, -50%, 0);
}

#active-essay-loading>div:after {
  content: "Loading";
  position: absolute;
  top: 100%;
  left: 50%;
  width: 200px;
  transform: translate3d(-50%, 0, 0);
  text-align: center;
}

#active-essay-loading>div>div {
  position: relative;
  display: inline-block;
  top: 0;
  left: 0;
  width: 50px;
  height: 50px;
  border-radius: 2px;
  background: rgba(255, 255, 255, .5);
  /*margin: auto;*/
  -webkit-animation: rotateplane 1.2s infinite ease-in-out;
  -moz-animation: rotateplane 1.2s infinite ease-in-out;
  -o-animation: rotateplane 1.2s infinite ease-in-out;
  animation: rotateplane 1.2s infinite ease-in-out;
}</STYLE></DIV><DIV class="paragraph code-paragraph collapsed" name="Disconnect / Reconnect Code" draggable="false" __wid="4IOgqtpQ"><PRE data-type="content" type="text/javascript" class="bootstrap-module" __wid="vWAuZPJE">var loadingContainer;

function showOffline() {
  // Hide document while loading all external webstrates.
  loadingContainer = document.createElement("transient");
  loadingContainer.setAttribute("id", "active-essay-disconnected");

  const centerPiece = document.createElement("div");

  const loadingIndicator = document.createElement("div");

  centerPiece.appendChild(loadingIndicator);
  loadingContainer.appendChild(centerPiece);

  document.body.appendChild(loadingContainer);
}

webstrate.on("reconnect", function() {
  if (loadingContainer) {
    loadingContainer.remove();
    loadingContainer = null;
  }
});

webstrate.on("disconnect", function() {
  showOffline();
});</PRE></DIV><DIV class="paragraph code-paragraph collapsed" draggable="true" name="JavaScript VM" last-execution-state="success" __wid="y-qxB3RG"><PRE data-type="content" type="text/javascript" class="bootstrap-module" __wid="ah7gJIxb">let globalContext = {};

const mergeContexts = (...contexts) => {
	const context = {};
	
	contexts.forEach(ctx => {
		Object.keys(ctx).forEach(key => {
			context[key] = ctx[key];
		});
	});
	
	return context;
}

Codestrate.JavaScriptVM = {
	addToGlobalContext: (context) => {
		globalContext = mergeContexts(globalContext, context);
	},
	getExecutionContext: (context = {}) => {

		const tmpContext = mergeContexts(globalContext, {
			console: Codestrate.activeConsole || window.console,
			Variable: window.Variable
		}, context);
		
		return {
			execute: (code) => {
				const argNames = Object.keys(tmpContext);
				const args = argNames.map(key => tmpContext[key]);
				
				const f = new Function(...argNames, code);
				return f(...args);
			}
		};
	}
}</PRE></DIV><DIV class="paragraph code-paragraph collapsed" draggable="false" name="Event Handling" __wid="_0ksa5j1"><PRE data-type="content" type="text/javascript" class="bootstrap-module" __wid="-ElG2p2W">Codestrate._listeners = [];

Codestrate.addEventListener = function(name, handler) {
	Codestrate._listeners.push({
		name: name,
		handler: handler
	});
};

Codestrate.removeEventListener = function(name, listener) {
	throw new Error(`Not yet implemented`);
};

Codestrate.dispatchEvent = function(name, event) {
	Codestrate._listeners.forEach(listener => {
		if (listener.name === name) {
			listener.handler.call(Codestrate, event);
		}
	});
}</PRE></DIV><DIV class="paragraph code-paragraph collapsed" name="Execute Code Paragraphs" __wid="uzhb6M8i"><PRE data-type="content" type="text/javascript" class="bootstrap-module" __wid="voZ_GJ8Y">const vm = Codestrate.JavaScriptVM;

Codestrate.runCode = (paragraph) => {

	const codeSelector = 'pre[type="text/javascript"]';
	let element = paragraph.querySelector(codeSelector);

	if (!element) {
		throw new Error(`Could not find ${codeSelector} in paragraph`);
	}

	var code = element.innerText;

	Codestrate.dispatchEvent("beforeruncode", {
		paragraph: paragraph,
		code: code
	});

	let codeSource = paragraph.getAttribute("id")
		|| (paragraph.getAttribute("name")
					&& paragraph.getAttribute("name").replace(/\W/g, "_"))
		|| `VM${webstrates.util.randomString()}`;

	try {
		code = `${code}\n//# sourceURL=${codeSource}`;

		const context = vm.getExecutionContext({
			exports: {}
		});
		
		context.execute(code);

		Codestrate.dispatchEvent("successruncode", {
			paragraph: paragraph,
			code: code
		});
	}
	catch (error) {
		if (error.source) {
			codeSource = error.source;
		}
// 		window.console.error(error, error.source);
		const regex = new RegExp("^([^\n]+)\n" + // error string
			"[^]+?" + // whatever comes before the parenthesis
			"\\((?:.*?):" + // code name or trash, non-capturing
			"([0-9]+):([0-9]+)\\)" // parenthesis
		);
		const matches = error.stack.match(regex);
		if (matches) {
			let [_, errorString, lineNumber, letterNumber] = matches;
			// Everything except SyntaxErrors will be in a `new Function` construct with
			// two appended lines, which we should account for.
			if (errorString.substring(0,12) !== "SyntaxError:") {
				lineNumber = lineNumber - 2;
			}
			console.error(`${errorString} at ${codeSource}` +
										`(${lineNumber}:${letterNumber})`);
		} else {
			console.error(error);
		}

		Codestrate.dispatchEvent("errorruncode", {
			error: error,
			paragraph: paragraph,
			code: code
		});
	}

	Codestrate.dispatchEvent("afterruncode", {
		paragraph: paragraph,
		code: code
	});
};

const executeOnLoadSections = Array.from(document.querySelectorAll('.paragraph[run-on-load="true"]'));
const len = executeOnLoadSections.length;

let currentIndex = 0;
let blockedExecution = false;

const execute = () => {
	
	// Break execution loop when all paragraph have been executed.
	if (currentIndex >= len) {
		const loadedEvent = new CustomEvent("codestrateloaded");
		window.dispatchEvent(loadedEvent);
		return;
	}

	const paragraph = executeOnLoadSections[currentIndex];

	Codestrate.runCode(paragraph);
	
	if (!blockedExecution) {
		execute(++currentIndex);
	}
};

Codestrate.blockExecution = (src) => {
	blockedExecution = true;
	let hasContinued = false;

	const continueWithNext = () => {
		clearTimeout(timeout);
		blockedExecution = false;
		hasContinued = true;
		execute(++currentIndex);
	};

	const timeout = setTimeout(() => {
		const message = `Loading "${src}" is taking too long. Do you want to continue?`;
		if (window.confirm(message)) {
			continueWithNext();
		}
	}, 30000);

	return {
		continue: () => {
			if (!hasContinued) {
				continueWithNext();
			}
		}
	}
};

// Execute first paragraph if one exists.
if (len) {
	execute(currentIndex);
}</PRE></DIV><DIV class="paragraph code-paragraph collapsed" draggable="false" name="Query Extensions" run-on-load="true" __wid="izjkwO8J"><PRE data-type="content" type="text/javascript" __wid="HrblNDEg">/**
 * The live query selector
 */
const liveQuerySelectorAll = function (selector, observerOptions = { subtree: true, childList: true }) {

	const elements = Array.from(this.querySelectorAll(selector));

	let addResolve;
	let removeResolve;

	if (observerOptions) {
		const observer = new MutationObserver(mutations => {

			mutations.forEach(mutation => {

				switch (mutation.type) {
					case "childList":

						if (removeResolve) {
							Array.from(mutation.removedNodes).forEach(node => {
								if (node.nodeType !== 1) return;

								try {
									if (node.matches(selector)) {
										removeResolve(node);
									}

									if (observerOptions.subtree) {
										const subNodes = Array.from(node.querySelectorAll(selector));
										subNodes.forEach(subNode => removeResolve(subNode));
									}
								}
								catch (error) {
									window.console.error(error, node);
								}
							});
						}

						if (addResolve) {
							Array.from(mutation.addedNodes).forEach(node => {
								if (node.nodeType !== 1) return;

								try {
									if (node.matches(selector)) {
										addResolve(node);
									}

									if (observerOptions.subtree) {
										const subNodes = Array.from(node.querySelectorAll(selector));
										subNodes.forEach(subNode => addResolve(subNode));
									}
								}
								catch (error) {
									window.console.error(error, node);
								}
							});
						}
						break;
														 }
			});
		});
		observer.observe(this, observerOptions);
	}

	const resolver = {
		added(resolve) {

			if (typeof resolve !== 'function')
				throw new Error('First parameter needs to be a function');

			elements.forEach(element => resolve(element));

			addResolve = resolve;
			return resolver;
		},
		removed(resolve) {
			if (typeof resolve !== 'function')
				throw new Error('First parameter needs to be a function');

			removeResolve = resolve;
			return resolver;
		}
	}

	return resolver;
};

Document.prototype.liveQuerySelectorAll = liveQuerySelectorAll;
Element.prototype.liveQuerySelectorAll = liveQuerySelectorAll;


const liveAttribute = function(attributeName) {
	const element = this;

	let attributeChanged;

	const observer = new MutationObserver(mutations => {

		if (typeof attributeChanged === 'function') {
			mutations.forEach(mutation => {

				if (mutation.attributeName === attributeName) {
					attributeChanged(mutation.target.getAttribute(attributeName), mutation.oldValue);
				}
			});
		}
	});
	observer.observe(element, { attributes: true, attributeOldValue: true });

	return {
		changed(resolve) {
			attributeChanged = resolve;
			resolve(element.getAttribute(attributeName), undefined);
		}
	}
};

Element.prototype.liveAttribute = liveAttribute;</PRE></DIV><DIV class="paragraph code-paragraph collapsed" name="Template Code" draggable="false" run-on-load="true" __wid="U5ckLHGM"><PRE data-type="content" type="text/javascript" __wid="cJyb1gWz">window.template = function(str, data) {
  return str
    .replace(
    /\${(\w*)}/g, // for "{this} instead of %this%"
    function( m, key ){
      return data.hasOwnProperty( key ) ? data[ key ] : "";
    }
  );
}</PRE></DIV><DIV class="paragraph code-paragraph collapsed" draggable="false" name="Import Function" run-on-load="true" __wid="ebbLjdKP"><PRE data-type="content" type="text/javascript" __wid="rmLHvxNZ">const relativeUrlRegex = new RegExp('^\\s*(?:[a-z0-9]+:)?//', 'i');
const isCacheEnabled = getParameterByName("cache") !== null;
const cacheKeyPrefix = "notestrate-import:";

console.debug(`Cache enabled: ${isCacheEnabled}`);

let importsContainer = document.head.querySelector('transient#imports');

// Add imports container if it does not exist.
if (!importsContainer) {
	importsContainer = document.createElement("transient");
	importsContainer.setAttribute("id", "imports");
	document.head.insertBefore(importsContainer, document.head.firstChild);
}

/**
 * Returns true if the resource is relative path to this webstrate.
 *
 * @param {string} src Url to resource.
 * @param {boolean} Returns true if the resource is relative. 
 */
const isRelativeResource = (src) => {
	return !relativeUrlRegex.test(src);
};

const getLatestAssets = () => {
	
	let latestAssets = {};
	let assets = webstrate.assets.call({});
	Array.prototype.forEach.call(assets, asset => {
		if (!latestAssets[asset.fileName] || latestAssets[asset.fileName].v &lt; asset.v) {
			latestAssets[asset.fileName] = asset;
		}
	});
	
	return latestAssets;
};

// Webstrate assets to check if cached resource needs to be updated.
const assets = []; //getLatestAssets();

/**
* Executes JavaScript code by adding it to a script element, which is then appended
* to the importsContainer transient element. The script element is returned.
*
* @param {string} code The JavaScript code.
* @return {HTMLScriptElement} The script element containing the code.
*/
const executeJavaScript = function (code) {

	// Add sourcemap functionality to script
	code = `${code}\n//# sourceURL=${webstrates.util.randomString()}`;

	const script = document.createElement("script");
	script.setAttribute("type", "text/javascript");

	// Use text node to make large scripts work (> 65k characters)
	const textNode = document.createTextNode(code);
	script.appendChild(textNode);

	importsContainer.appendChild(script);

	return script;
};

/**
* Executes the CSS by adding it to a style element, which is then appended to the
* importsContainer transient element. The style element is returned.
*
* @param {string} css The CSS style.
* @param {HTMLStyleElement The style element containing the css.
*/
const executeCss = function (css) {

	// Create the style element
	const style = document.createElement("style");

	// Add styles
	style.innerHTML = css;

	// WebKit hack :(
	style.appendChild(document.createTextNode(""));

	// Add the style element to the page
	importsContainer.appendChild(style);

	return style;
};

const storeInCache = (src, type) => {
	
	// Check if cache is enabled and only cache resources are from this webstrate.
	if (!isCacheEnabled || !isRelativeResource(src)) {
		return false;
	}
	
	// Get asset and only cache if asset for resource exists.
	const asset = assets[src];
	
	if (typeof (Storage) !== "undefined" && asset) {
		
		// Get resource and store its content in cache.
		fetch(src, { credentials: 'include' }).then(externalResource => {
			externalResource.text().then(content => {
				
				const resource = {
					asset,
					type,
					content
				};
				
				localStorage.setItem(`${cacheKeyPrefix}${src}`, JSON.stringify(resource));
			})
		});
	}
}

/**
 * It loads the source from cache if the cache is enabled and if it exists in cache
 */
const loadFromCache = (src) => {
	
	if (!isCacheEnabled) {
		return false;
	}
	
	if (typeof (Storage) !== "undefined") {

		const value = localStorage.getItem(`${cacheKeyPrefix}${src}`);

		if (value) {
			try {
				const { asset, type, content } = JSON.parse(value);
				
				// If asset does not exist then it has been updated eventually
				if (assets[asset.fileName].v > asset.v) {
					localStorage.removeItem(`${cacheKeyPrefix}${src}`);
					return false;
				}

				let imported = importsContainer.querySelector(`[data-src="${src}"]`);

				// Source already imported
				if (imported) {
					return true;
				}
				
// 				console.debug(`Loading ${asset.fileName}?v=${asset.v} from cache`);

				let element;
				if (type === "text/javascript") {
					element = executeJavaScript(content);
				}
				else if (type === "text/css") {
					element = executeCss(content);
				}
				else {
					throw new Error(`Type "${type}" is not supported.`);
				}
				element.setAttribute("data-cached", "true");
				element.setAttribute("data-src", src);
				return true;
			}
			catch (error) {
				debugger;
				console.error(`Could not load source ${src} from cache. Removing it from cache.`, error);
				localStorage.removeItem(`${cacheKeyPrefix}${src}`);
			}
		}
	}

	return false;
}

window.importLib = function (src, type = "text/javascript") {

	// Block execution of consecutive code paragraphs until all external libraries imported
	// by the current code paragraph have been executed.
	const blockHandle = Codestrate.blockExecution(src);

	const loadLibrary = (s, callback) => {

		if (loadFromCache(s)) {
			setTimeout(() => {
				callback();
			}, 0);
			return;
		}
		
		let script = importsContainer.querySelector(`script[src="${s}"]`);

		// Import source only once.
		if (!script) {
			script = document.createElement("script");
			script.setAttribute("type", type);
			script.setAttribute("src", s);
			script.onload = () => {
				script.__loaded = true;

				if (isCacheEnabled) {
					storeInCache(s, type);
				}

				callback();

				if (script.__callbacks) {
					script.__callbacks.forEach(cb => cb());
				}
			};
			importsContainer.appendChild(script);
		}
		// Script is imported by another code paragraph, but has not been loaded completely
		// by the first one. So, the callback is added to a list and called after the
		// has loaded.
		else if (!script.__loaded) {
			if (!script.__callbacks) {
				script.__callbacks = [];
			}
			script.__callbacks.push(callback);
		}
		// The script has been loaded and executed before. Just continue.
		else {
			callback();
		}
	}

	// Returns a promise like function, which will be executed when all imports
	// were loaded.
	return {

		then: (resolve) => {

			if (typeof src === "string") {
				loadLibrary(src, () => {
					resolve();
					blockHandle.continue();
				});
			}
			else if (Array.isArray(src)) {
			
				const len = src.length;
				let i = 0;

				const loadNextLib = () => {
					if (i &lt; len) {
						loadLibrary(src[i], () => {
							++i;
							loadNextLib();
						});
					}
					else {
						resolve();
						blockHandle.continue();
					}
				};

				loadNextLib();
			}
			else {
				throw new Error(`The 1 parameter must be a string or an array of strings instead of ${src}`);
			}
		}
	};
}

/**
 * Load style from source.
 *
 * @param {string|Array} src The url to the source or an array of urls to sources.
 */
const loadStyle = (src) => {

	// Load resource from cache and return on success.
	if (loadFromCache(src))	return;
		
	let link = importsContainer.querySelector(`link[src="${src}"]`);

	// Import resource only once.
	if (!link) {
		link = document.createElement("link");
		link.setAttribute("rel", "stylesheet");
		link.setAttribute("href", src);
		importsContainer.appendChild(link);

		if (isCacheEnabled) {
			storeInCache(src, "text/css");
		}
	}
}

// Export importStyle function to global window object.
window.importStyle = function (src) {

	if (typeof src === "string") {
		loadStyle(src);
	}
	else if (Array.isArray(src)) {
		src.forEach(loadStyle);
	}
	else {
		throw new Error(`The 1 parameter must be a string or an array of strings instead of ${src}`);
	}
}</PRE></DIV><DIV class="paragraph code-paragraph collapsed" draggable="false" name="Require Function" run-on-load="true" last-execution-state="success" __wid="RlweYFFY"><PRE data-type="content" type="text/javascript" __wid="wargAUH2">const vm = Codestrate.JavaScriptVM;

window.require = function (selector, data) {
	const codeElements = Array.from(document.querySelectorAll(selector));

	if (!codeElements.length) {
		throw new Error(`require('${selector}') does not exist`);
	}
	
	if (codeElements.length > 1) {
		throw new Error(`require('${selector}') returns multiple elements, which is not supported`);
	}

// 	let code = codeElements.map(codeElement => {
// 		return codeElement.innerText;
// 	}).join('\n\n');
	
	const codeElement = codeElements[0];
	let code = codeElement.innerText;

	// Replace placeholders like ${myVar} in code
	if (data) {
		code = template(code, data);
	}

	const type = codeElement.getAttribute("type");

	if (type === "text/javascript") {
		let exports = {};
		const context = vm.getExecutionContext({ exports: exports });
		context.execute(code);
		return exports;
	}
	else if (type === "application/json") {
		const context = vm.getExecutionContext();
		return context.execute(`return ${code};`);
	}
	else if (type === "text/css") {
		return code;
	}
	else if (type === "text/html") {
		let html = codeElement.innerHTML;
		
		if (data) {
			html = template(html, data);
		}
		
		const container = document.createElement("div");
		container.innerHTML = html;
		
		return Array.from(container.children).map(c => c);
	}

	return undefined;
};</PRE></DIV><DIV class="paragraph code-paragraph collapsed" run-on-load="true" last-execution-state="success" draggable="false" name="Dialog VM Overwrite" __wid="BGGgazVI"><PRE data-type="content" type="text/javascript" __wid="bwQFuuDg">const Dialogs = require('#dialogs');

Codestrate.JavaScriptVM.addToGlobalContext({
	alert: Dialogs.alert,
	confirm: Dialogs.confirm,
	prompt: Dialogs.prompt
});</PRE></DIV><DIV class="paragraph code-paragraph collapsed" draggable="false" name="Console" run-on-load="true" last-execution-state="success" __wid="ylXHPM6h"><PRE data-type="content" type="text/javascript" __wid="2Q1UW0Xt">importLib("moment.min.js").then(() => {

  class Console {

    constructor(paragraph, container) {
			this.paragraph = paragraph;
      this.container = container;

      // Logs go to buffer and will be subsequently rendered in
      // requestAnimationFrame.
      this._outputBuffer = [];

      this._addHeader();
      this._addOutput();
      this._addInput();

      this._addCloseButton();

      this.container.classList.add("close");
    }

    open() {
      this.container.classList.remove("close");
      setTimeout(() => {
        this.container.classList.add("open");
      }, 1);
    }

    close() {
      const onClosed = (event) => {
        if (event.propertyName === "height") {
          this.container.removeEventListener("transitionend", onClosed);
          this.container.classList.add("close");
        }
      };

      this.container.removeAttribute("style");
      this.container.addEventListener("transitionend", onClosed, false);
      this.container.classList.remove("open");
    }

    toggle() {
      if (this.container.classList.contains("open")) {
        this.close();
      }
      else {
        this.open();
      }
    }

    destroy() {
      this.close();

      this.container.addEventListener("transitionend", (event) => {
        if (event.propertyName === "height") {
          this.container.remove();
        }
      }, false);
    }

    log() {
      this._internalLog("log", ...arguments);
    }

    info() {
      this._internalLog("info", ...arguments);
    }

    error() {
      this._internalLog("error", ...arguments);
    }

    warn() {
      this._internalLog("warn", ...arguments);
    }

    debug() {
      this._internalLog("debug", ...arguments);
    }

    trace() {
      this._internalLog("trace", ...arguments);
    }

    _addHeader() {
      this.header = document.createElement("div");
      this.header.setAttribute("class", "header");
      this.container.appendChild(this.header);
    }

    _addOutput() {
      this.output = document.createElement("div");
      this.output.setAttribute("class", "output");
      this.container.appendChild(this.output);
    }

    _addInput() {
      this.input = document.createElement("div");
      this.input.setAttribute("class", "input");
      
      let history = [];
      let historyIndex = -1;

      const inputElement = document.createElement("input");
      inputElement.setAttribute("type", "text");
      inputElement.addEventListener("keydown", event => {
        
//         alert('key code' + event.key);
        
        if (event.keyCode === 13) {

          // Get console input
          const value = inputElement.value;
          
          // Ignore empty console input
          if (value.trim() === "") {
            return;
          }
          
          // Push console input to history
          history.push(value);
          historyIndex = history.length;

          try {
//             const f = new Function('console', `return ${value}`);
//             const result = f(this);
            
            this.log(value);
            
            const result = eval(value);

            this.log(result);
          }
          catch (error) {
            this.error(error);
          }
          finally {
            // Reset console input
            inputElement.value = "";
          }
        }
        else if (event.keyCode === 38) {
          
          if (historyIndex > 0) {
            inputElement.value = history[--historyIndex];
          }
        }
        else if (event.keyCode === 40) {
          
          if (historyIndex &lt; history.length - 1) {
            inputElement.value = history[++historyIndex];
          }
          else {
            historyIndex = history.length;
            inputElement.value = "";
          }
        }
      });
      this.input.appendChild(inputElement);

      this.container.appendChild(this.input);
    }

    _addCloseButton() {
      const closeConsole = document.createElement("span");
      closeConsole.setAttribute("class", "close-console");
      closeConsole.addEventListener("click", event => {
        if (typeof this.onClose === 'function') {
          if (this.onClose.call(this)) {
            this.close();
          }
        }
        else {
          this.close();
        }
      });

      const icon = document.createElement("i");
      icon.setAttribute("class", "material-icons");
      closeConsole.appendChild(icon);

      this.header.appendChild(closeConsole);
    }

    _updateScroll() {
      this.output.scrollTop = this.output.scrollHeight;
    }

    _internalLog(type, ...args) {
			
			// Log to actual DevTools console including the paragraph that contains the code.
			const console = window.console;
			if (console) {
				const consoleLog = console[type];
				if (typeof consoleLog === 'function') {
					const location = this.paragraph.getAttribute("name") || "No Name";
					console.group("Console %c%s", 'color: orange;', location);
					consoleLog.call(window, ...args);
					console.groupCollapsed("%cLog Source", 'font-weight: normal;');
					console.log(this.paragraph);
					console.groupEnd();
					console.groupEnd();
				}
			}

      this._outputBuffer.push({
        timestamp: moment().format("YYYY-MM-DD HH:mm:ss.SSS"),
        type: type,
        args: args
      });

      /**
       * Convert arg to output that conforms to console output.
       */
      const convertArg = arg => {

        let converted = arg;

        if (arg instanceof Error) {
          converted = arg.stack;
        }
        else if (arg instanceof HTMLElement) {
					// Convert HTML element to a string.
					// !!! The replace is required otherwise the console will render the HTML
					// instead of logging the markup.
					converted = arg.outerHTML.replace(/[\u00A0-\u9999&lt;>\&]/gim, (idx) => {
						return `&#${idx.charCodeAt(0)};`;
					});
        }
        else if (typeof arg === 'object') {
					try {
          	converted = JSON.stringify(arg, null, "  ");
					}
					catch (error) {
// 						window.console.error(error);
						converted = arg.toString();
					}
        }
        
        let type = typeof arg;
        if (arg == null) {
          type = "null";
        }

        return `&lt;span class="${type}">${converted}&lt;/span>`;
      }

      const logToOutput = () => {

        const fragment = document.createDocumentFragment();

        this._outputBuffer.forEach(item => {
          const entry = document.createElement("div");
					entry.classList.add(`log-output`);
					entry.classList.add(type);

          const args = item.args.map(convertArg);
          let message = args.join(" ");

          entry.innerHTML = `
&lt;div class="time">${item.timestamp}&lt;/div>
&lt;div class="message">${message}&lt;/div>
`;
          fragment.appendChild(entry);
        });

        this.output.appendChild(fragment);

        this._updateScroll();

        // Clear output buffer
        this._outputBuffer.length = 0;

        // Allow new animation frame requests
        this.requestedAnimationFrame = false;
      };

      if (!this.requestedAnimationFrame) {
        this.requestedAnimationFrame = true;
        window.requestAnimationFrame(logToOutput);
      }
    }
  };


  // Hook into Active Essay bootstrap and set console for currently executed code
  // block.
  Codestrate.addEventListener("beforeruncode", event => {

    const { paragraph } = event;

    // Set active console.
    Codestrate.activeConsole = paragraph.console;
  });
  
  const addConsole = (paragraph) => {

    // Add console only once.
    if (paragraph.console) return;

    const consoleContainer = document.createElement("transient");
    consoleContainer.setAttribute("class", "console");

    // Attach actual console to element.
    const console = new Console(paragraph, consoleContainer);
    paragraph.console = console;
    paragraph.appendChild(consoleContainer);
  };

  document.liveQuerySelectorAll('.paragraph.code-paragraph').added(addConsole);
});</PRE></DIV><DIV class="paragraph style-paragraph collapsed" name="Console Style" draggable="false" __wid="v3zZ3itC"><STYLE data-type="content" type="text/css" codemirror="true" __wid="UD_CFtLn">.console {
/*   position: relative; */
  background: rgb(48, 48, 48);
  margin-top: 5px;
  width: 100%;
  height: 0;
  opacity: 0;
  pointer-events: none;
  z-index: 9;
  display: block;

  border: 1px solid rgb(135, 135, 129);
  border-radius: 2px;

  font-family: "Menlo", monospace;
  font-size: 11px;
  
  background-color: rgba(0, 0, 0, .1);  
  
  display: none;

  /*   -webkit-transition: height 500ms ease-in-out 0s, opacity 500ms ease-in-out 0s;
  -moz-transition: height 500ms ease-in-out 0s, opacity 500ms ease-in-out 0s;
  transition: height 500ms ease-in-out 0s, opacity 500ms ease-in-out 0s; */
}

.console.open {
  display: flex;
/*   flex: 1; */
/*   flex-direction: column; */
  flex-flow: column;

  /*   height: 100%; */
  min-height: 200px;
  opacity: 1.0;
  pointer-events: all;

  overflow: hidden;
  overflow-y: hidden;
  resize: vertical;
}

.console.close {
  border: 0;
  padding: 0;
  margin: 0;
}

.console .header {
  padding: 5px;
}

.console .header:before {
  content: "Console";
}

.console .close-console {
  position: absolute;
  top: 0;
  right: 0;
  height: 100%;
  z-index: 1;
  cursor: pointer;
  /*font-size: .6em;*/
}

/* .console .close-console i:after {
  content: "close";
  position: absolute;
  top: 50%;
  right: 0;
  font-size: .8em;
  transform: translate3d(0, -50%, 0);
} */

.console .output {
  flex: 1;
  
/*   background-color: orange; */
  overflow: hidden;
  overflow-y: auto;
  padding: 5px;

  border-top: 1px solid rgba(255, 255, 255, .05);
  border-bottom: 1px solid rgba(255, 255, 255, .05);
}

.console > .output > div > * {
  position: relative;
  display: inline-block;
  /*word-break: break-all;*/
  word-wrap: break-word;
  /*float: right;*/
  white-space: pre-wrap;

  vertical-align: top;
}

.console > .output > div:not(:last-child) {
  padding: 3px 0 3px 0;
  border-bottom: 1px solid rgba(255, 255, 255, .1);
}

.console > .output > div:last-child {
  padding: 3px 0 0 0;
}

.console > .output > div > .time {
  color: rgb(135, 135, 129);
  /*margin-right: 5px;*/
}


.console > .output > .error {
	background-color: rgba(255, 0, 0, .1);
  color: rgb(255, 127, 127);
}

.console > .output > .warn {
	background-color: rgba(255, 255, 0, .1);
  color: rgba(255, 220, 158, 1.0);
}

.console > .output > .debug {
  color: rgba(76, 136, 255, 1.0);
}

.console > .output > div > .message .number,
.console > .output > div > .message .boolean {
  color: #9179ff;
}

.console > .output > div > .message .object {
/*   color: lime; */
}

.console > .output > div > .message .null,
.console > .output > div > .message .undefined {
  color: rgb(135, 135, 129);
}

.console > .output > div > .message.info:before {
  content: "INFO: ";
	display: inline-block;
}

.console .input {
  padding: 5px;
}

.console .input:before {
  content: ">";
  margin-right: 5px;
  font-weight: bold;
  width: 10px;
/*   background-color: lime; */
  display: inline-block;
}

.console .input input[type="text"] {
  border: 0;
  outline: 0;
  color: white;
  width: calc(100% - 15px);
  background-color: transparent;
}</STYLE></DIV></DIV><DIV name="User Manager" class="section section-hidden" data-type="system" __wid="Aoxg-xn-"><DIV class="paragraph body-paragraph collapsed" draggable="false" name="Documentation" __wid="XYRELpU1"><DIV data-type="content" type="text/html" codemirror="true" contenteditable="true" __wid="FklE79Xj"><H1 __wid="3HyJ6mlA">User Manager</H1>The user manager adds a users array to the Codestrate global window object. Each object in the users array will have the user id and a generated user color. For example, the color can be used in the in the Codestrate to have a consistent user color for remote pointers and remote cursors.<DIV __wid="vzGcyMq7"><BR __wid="UXI8B1Eb"/></DIV><H2 __wid="vxzx5e62">Usage</H2><DIV __wid="6AAGoT0c">tbd.</DIV></DIV></DIV><DIV class="paragraph code-paragraph collapsed" run-on-load="true" name="User Manager Global" __wid="Yud8A9rY"><PRE data-type="content" type="text/javascript" __wid="V4XVl3n-">// Add a users array to the global Codestrate object
if (Codestrate && !Codestrate.users) {
	Codestrate.users = [];
}

/**
 * Adds a new user to the users array and generates a random user color. Nothing will
 * happen if a user already exists.
 *
 * @param {string} id The user id.
 */
const addUser = (id) => {
	
	const users = Codestrate.users;

	// Add user only if it does not exist
	if (users.findIndex(u => u.id === id) &lt; 0) {
		users.push({
			id: id,
			color: '#'+(Math.random()*0xFFFFFF&lt;&lt;0).toString(16)
		});
	}
};

/**
 * Removes a user from the users array.
 *
 * @param {string} id The user id.
 */
const removeUser = (id) => {
	const users = Codestrate.users;
	const idx = users.findIndex(u => u.id === id);
	users.splice(idx, 1);
};

// Add all existing users
webstrate.clients.forEach(c => addUser(c));

// Add a client to the list of users when it joins
webstrate.on("clientJoin", (clientId) => {
	addUser(clientId);
});

// Remove a client from the list of users when it leaves
webstrate.on("clientPart", (clientId) => {	
	removeUser(clientId);
});</PRE></DIV><DIV class="paragraph code-paragraph collapsed" name="User Manager Utils" __wid="5e3Oegvt"><PRE data-type="content" type="text/javascript" id="user-manager" __wid="GpIqK7CM">/**
	 * Convert a hex colour to a rgb/rgba value
	 * @param {string} hex
	 * @param {?number} opacity
	 * @returns {string}
	 */
const convertHexToRGBA = (hex, opacity) => {
	hex = hex.replace('#','');
	const r = parseInt(hex.substring(0,2), 16);
	const g = parseInt(hex.substring(2,4), 16);
	const b = parseInt(hex.substring(4,6), 16);

	return `rgba(${r},${g},${b},${opacity})`;
}

const getUserColor = exports.getUserColor = (clientId = webstrate.clientId) => {
	const user = Codestrate.users.find(u => u.id === clientId);
	
	if (!user) {
		return "#00ff00";
		throw new Error(`User ${clientId} does not exist in ${JSON.stringify(Codestrate.users)}`);
	}
	
	return user.color;
};

exports.getUserColorInRGBA = (clientId = webstrate.clientId, opacity = 1.0) => {
	return convertHexToRGBA(getUserColor(clientId), opacity);
};</PRE></DIV></DIV><DIV name="Idle Timer" class="section section-hidden" data-type="system" __wid="J9jdTZPE"><DIV class="paragraph body-paragraph" name="Documentation" __wid="r-ATAwdB"><DIV data-type="content" type="text/html" codemirror="true" contenteditable="true" __wid="LyAPao6Y">Idle Timer Documentation tbd.</DIV></DIV><DIV class="paragraph code-paragraph collapsed" name="Idle Timer Code" run-on-load="true" last-execution-state="success" draggable="false" __wid="wfCNISdd"><PRE data-type="content" type="text/javascript" __wid="0QNkupjv">// Time until client becomes idle/inactive (in milliseconds)
const IDLE_TIMEOUT = 300 * 1000;

let isIdle = false;
let idleTimeout;
let lastAction = Date.now();

const actionHappend = () => {
	
	lastAction = Date.now();
	
	// Send awake message only if client was in idle mode
	if (isIdle) {
		isIdle = false;
		signalAwake();
	}

	if (idleTimeout) {
		clearTimeout(idleTimeout);
	}

	idleTimeout = setTimeout(() => {
		isIdle = true;
		signalIdle();
	}, IDLE_TIMEOUT);
};

/**
 * Signal awake message to all clients.
 */
const signalAwake = () => {
	webstrate.signal({ type: "IdleTimer", cmd: "awake" });
};

/**
 * Signal idle message to recipients or all clients.
 *
 * @param {Array|string} [recicipients] An array of client ids or a single client id indicating the recipients of the idle signal.
 */
const signalIdle = (recipients = webstrate.clients) => {
	webstrate.signal({
		type: "IdleTimer",
		cmd: "idle",
		idleTime: Date.now() - lastAction
	}, recipients);
};

// Send idle state to joining clients when idle = true
webstrate.on("clientJoin", (clientId) => {
	
	// Ignore own client join event
	if (clientId === webstrate.clientId) return;
	
	if (isIdle) {
		// We have to set a timeout here to cope with race condition. The signalIdle is
		// sent to the requesting client before the callback that listens for this message
		// is registered.
		setTimeout(() => signalIdle(clientId), 10000);
	}
});

// webstrate.on("reconnect", actionHappend);

document.addEventListener("mousemove", actionHappend);
document.addEventListener("keydown", actionHappend);
document.addEventListener("touchstart", actionHappend);
document.addEventListener("touchmove", actionHappend);
document.addEventListener("touchend", actionHappend);
actionHappend();</PRE></DIV></DIV><DIV class="section section-hidden" name="Dialogs (experimental)" data-type="system" __wid="C6LMgVa6"><DIV class="paragraph body-paragraph collapsed" name="Dialog Template" draggable="false" __wid="1oEcRTBn"><DIV data-type="content" type="text/html" codemirror="true" contenteditable="true" id="dialog-template" __wid="RY6XgxtU"><DIV class="modal" __wid="_D0aGjBT"></DIV>
<DIV class="dialog" style="min-width: 300px;" __wid="vghdaskp">
	<DIV class="title" __wid="r4RvLVId">${title}</DIV>
	<DIV class="body" __wid="KglnCUjt">${message}</DIV>
	<DIV class="actions" __wid="OKWbgzjS">
		${actions}
	</DIV>
</DIV></DIV></DIV><DIV class="paragraph style-paragraph collapsed" name="Dialog Style" draggable="false" __wid="3CDdkjMz"><STYLE data-type="content" type="text/css" codemirror="true" __wid="fopI7f_H">/* .modal {
	position: fixed;
	top: 0;
	left: 0;
	width: 100vw;
	height: 100vh;
	z-index: 1;
	background-color: rgba(0, 0, 0, .2);
	pointer-events: none;
} */

.dialog {
	display: flex;
	flex-direction: column;
	position: fixed;
	top: 100px;
	left: 50%;
	min-width: 300px;
	max-width: calc(100vw - 20px);
/* 	height: 200px; */
	background-color: white;
	z-index: 201;
	transform: translate3d(-50%, 0, 0);
	box-shadow: 5px 5px 15px rgba(0, 0, 0, .7);
	border-radius: 2px;
}

.dialog .button {
	display: inline;
	padding: 5px 15px;
	background-color: rgba(255, 255, 255, .2);
	cursor: pointer;
}

.dialog .title,
.dialog .body {
	padding: 5px;
/* 	pointer-events: none; */
}

.dialog .body > * {
	margin-bottom: 10px;
}

.dialog .body input {
	width: 100%;
	font-size: 1.2em;
	outline: 0;
}

.dialog .actions {
	padding: 10px;
}

.dialog .title {
	background-color: rgba(0, 0, 0, .8);
	color: white;
	font-weight: bold;
}

.dialog .body {
	height: 100%;
	background-color: rgba(0, 0, 0, .75);
}

.dialog .actions {
	text-align: right;
	background-color: rgba(0, 0, 0, .8);
}</STYLE></DIV><DIV class="paragraph code-paragraph collapsed" draggable="false" last-execution-state="success" name="Dialog Exports" __wid="O9BrCRjx"><PRE data-type="content" type="text/javascript" id="dialogs" __wid="E7Os0q77">exports.prompt = (message, defaultValue = "", title = "") => {

	return new Promise((resolve, reject) => {

		const transient = document.createElement("transient");

		const elements = require('#dialog-template', {
			title: title === "" ? "&nbsp;" : title,
			message: `&lt;div>${message}&lt;/div>
&lt;input class="input" type="text" value="${defaultValue}">`,
			actions: `&lt;div class="button ok">Ok&lt;/div>
&lt;div class="button cancel">Cancel&lt;/div>`
		});

		elements.forEach(e => transient.appendChild(e));

		const okBtn = transient.querySelector('.ok');
		const cancelBtn = transient.querySelector('.cancel');
		const input = transient.querySelector('.input');

		const ok = () => {
			transient.remove();
			resolve(input.value);
		}

		const cancel = () => {
			transient.remove();
			resolve(false);
		}

		okBtn.addEventListener("click", ok);
		cancelBtn.addEventListener("click", cancel);

		input.addEventListener("keydown", e => {
			e.stopPropagation();

			if (e.keyCode === 13) {
				e.preventDefault();
				ok();
			}
			else if (e.keyCode === 27) {
				e.preventDefault();
				cancel();
			}
		});

		document.body.appendChild(transient);

		input.focus();
	});
}

exports.alert = (message, title = "") => {

	return new Promise((resolve, reject) => {

		const transient = document.createElement("transient");

		const elements = require('#dialog-template', {
			title: title === "" ? "&nbsp;" : title,
			message: message,
			actions: `&lt;div class="button ok">Ok&lt;/div>`
		});

		elements.forEach(e => transient.appendChild(e));

		const okBtn = transient.querySelector('.ok');

		const ok = () => {
			transient.remove();
			resolve(true);
		}

		okBtn.addEventListener("click", ok);

		document.body.appendChild(transient);
	});
};

exports.confirm = (message, title = "") => {

	return new Promise((resolve, reject) => {

		const transient = document.createElement("transient");

		const elements = require('#dialog-template', {
			title: title === "" ? "&nbsp;" : title,
			message: message,
			actions: `&lt;div class="button ok">Ok&lt;/div>
&lt;div class="button cancel">Cancel&lt;/div>`
		});

		elements.forEach(e => transient.appendChild(e));

		const okBtn = transient.querySelector('.ok');
		const cancelBtn = transient.querySelector('.cancel');

		const ok = () => {
			transient.remove();
			resolve(true);
		}

		const cancel = () => {
			transient.remove();
			resolve(false);
		}

		okBtn.addEventListener("click", ok);
		cancelBtn.addEventListener("click", cancel);

		document.body.appendChild(transient);
	});
};</PRE></DIV><DIV class="paragraph code-paragraph collapsed" last-execution-state="success" run-on-load="true" name="Show Tags Dialog" __wid="8Pd-6SQn"><PRE data-type="content" type="text/javascript" __wid="caXWx5eI">Codestrate.showTags = () => {
	
	const transient = document.createElement("transient");
	
	const tags = webstrate.tags();
	const keys = Object.keys(tags);
	keys.reverse();
	
	let tagElementsString = '&lt;ul>';
	let len = keys.length > 10 ? 10 : keys.length;
	for (var i = 0; i &lt; len; i++) {
		tagElementsString += `&lt;li class="tag" data-key="${keys[i]}" data-tag="${tags[keys[i]]}">${tags[keys[i]]}&lt;/li>`;
	}
	tagElementsString += '&lt;/ul>';

	const elements = require('#dialog-template', {
		title: "Codestrate Tags",
		message: tagElementsString,
		actions: `&lt;div class="button cancel">Cancel&lt;/div>`
	});

	elements.forEach(e => transient.appendChild(e));

	const cancelBtn = transient.querySelector('.cancel');
	
	const tagElements = Array.from(transient.querySelectorAll('.tag'));
	tagElements.forEach(element => {
		element.addEventListener("click", e => {
			const tag = element.getAttribute("data-tag");
			webstrate.restore(tag);
			window.location.reload();
		});
	});
	
	const cancel = () => {
		transient.remove();
	}

	cancelBtn.addEventListener("click", e => {
		transient.remove();
	});

	document.body.appendChild(transient);
};</PRE></DIV><DIV class="paragraph style-paragraph collapsed" name="Show Tags Dialog Style" __wid="Q5hkqqgF"><STYLE data-type="content" type="text/css" codemirror="true" __wid="FG9oUzpL">.dialog ul {
	list-style-type: none;
	margin: 0;
	padding: 0;
}

.dialog ul li.tag {
	padding: 5px;
	cursor: pointer;
}

.dialog ul li.tag:hover {
	background-color: rgba(255, 255, 255, .1);
}</STYLE></DIV></DIV><DIV class="section section-hidden" name="The Codestrate Code" data-type="system" __wid="gkRlHaTg">
        
    <DIV class="paragraph style-paragraph collapsed" draggable="false" name="Animations (@keyframes)" __wid="V6f0Gj3i"><STYLE data-type="content" type="text/css" codemirror="true" __wid="8oGIJXCV">/* The animation code */
@keyframes blink-cursor {
    from { opacity: 1.0; }
    to { opacity: 0.0; }
}</STYLE></DIV><DIV class="paragraph code-paragraph collapsed" draggable="false" name="DOM Utils" run-on-load="true" __wid="GGKJMMEa"><PRE data-type="content" type="text/javascript" id="dom-utils" __wid="IoCkwy29">const HTMLUtils = window.HTMLUtils = (function () {

	this.getCaretPosition = function (editableDiv) {
		var caretPos = 0,
				sel, range;
		if (window.getSelection) {
			sel = window.getSelection();
			if (sel.rangeCount) {
				range = sel.getRangeAt(0);
				if (range.commonAncestorContainer.parentNode == editableDiv) {
					caretPos = range.endOffset;
				}
			}
		} else if (document.selection && document.selection.createRange) {
			range = document.selection.createRange();
			if (range.parentElement() == editableDiv) {
				var tempEl = document.createElement("span");
				editableDiv.insertBefore(tempEl, editableDiv.firstChild);
				var tempRange = range.duplicate();
				tempRange.moveToElementText(tempEl);
				tempRange.setEndPoint("EndToEnd", range);
				caretPos = tempRange.text.length;
			}
		}
		return caretPos;
	};
	
	this.setCaretPosition = function(editableDiv, position) {

		// Only set new caret position if position > 0
		if (position &lt;= 0) return;
		
		
		var textNode = editableDiv.firstChild;
		var range = document.createRange();
		range.setStart(textNode, position);
		range.setEnd(textNode, position);
		var sel = window.getSelection();
		sel.removeAllRanges();
		sel.addRange(range);
	};

	this.pasteHtmlAtCaret = function (html) {
		var sel, range;
		if (window.getSelection) {
			// IE9 and non-IE
			sel = window.getSelection();
			if (sel.getRangeAt && sel.rangeCount) {
				range = sel.getRangeAt(0);
				range.deleteContents();

				// Range.createContextualFragment() would be useful here but is
				// non-standard and not supported in all browsers (IE9, for one)
				var el = document.createElement("div");
				el.innerHTML = html;
				var frag = document.createDocumentFragment(), node, lastNode;
				while ((node = el.firstChild)) {
					lastNode = frag.appendChild(node);
				}
				range.insertNode(frag);

				// Preserve the selection
				if (lastNode) {
					range = range.cloneRange();
					range.setStartAfter(lastNode);
					range.collapse(true);
					sel.removeAllRanges();
					sel.addRange(range);
				}
			}
		} else if (document.selection && document.selection.type != "Control") {
			// IE &lt; 9
			document.selection.createRange().pasteHTML(html);
		}
	};

	this.appendChildAtCaret = function (child, beforeInsert) {

		if (window.getSelection) {
			
			// IE9 and non-IE
			const selection = window.getSelection();

			let range;
			if (selection.focusNode && selection.getRangeAt && selection.rangeCount) {
				range = selection.getRangeAt(0);
			}
			else {
				range = HTMLUtils.lastRange;
			}

			if (range) {

				// Check if child should be inserted at range.
				if (typeof beforeInsert === 'function') {
					if (!beforeInsert(range)) {
						return false;
					}
				}

				range.deleteContents();
				range.insertNode(child);

				// Preserve the selection
				if (child) {
					range = range.cloneRange();
					range.setStartAfter(child);
					range.collapse(true);
					selection.removeAllRanges();
					selection.addRange(range);
				}

				return true;
			}
		}
		else {
			throw new Error(`Append child at caret is not supported.`);
		}

		return false;
	};

	return this;
}).call({});

/**
 * This is a hack for iOS devices where the selection on contenteditable
 * changes when clicking a button.
 */
document.addEventListener("selectionchange", event => {

	if (window.getSelection) {
		const selection = window.getSelection();

		let node = selection.focusNode;
		if (node) {
			
			const range = selection.getRangeAt(0);
			HTMLUtils.lastRange = range.cloneRange();

			if (node.nodeType === 3) {
				node = node.parentElement;
			}
			
			const bodyParagraphContent = node.closest('.paragraph.body-paragraph [data-type="content"][contenteditable]');
			
			if (bodyParagraphContent) {
				bodyParagraphContent._selectionRange = range.cloneRange();		
			}
		}
	}
});

/**
 *
 */
Element.prototype.appendChildAtCaret = function(child) {
	if (!this.isContentEditable) return;

	let range = this._selectionRange;

	if (range) {
// 		range.deleteContents();
		range.insertNode(child);

		if (window.getSelection) {
			const selection = window.getSelection();
			
			// Preserve the selection
			if (child) {
				range = range.cloneRange();
				range.setStartAfter(child);
				range.collapse(true);
				selection.removeAllRanges();
				selection.addRange(range);
			}
		}

		return true;
	}

	return false;
};</PRE></DIV><DIV class="paragraph code-paragraph collapsed" name="Destroy Event Listeners On Rerun" style="will-change: transform;" __wid="Y2CGDKL3"><PRE data-type="content" type="text/javascript" __wid="NMXLZO8t">let beforeRunCodeRan = false;
let _addEventListener;

Codestrate.addEventListener("beforeruncode", event => {

  const { paragraph, code } = event;
  
  if (paragraph.__listeners) {
    paragraph.__listeners.forEach(listener => {
      console.info('Removing previously added event listener', listener);
      listener.source.removeEventListener(...listener.parameters);
    });
  }

  paragraph.__listeners = [];

  _addEventListener = Node.prototype.addEventListener;
  
  Node.prototype.addEventListener = function() {
    var parameters = Array.from(arguments);
    // window.console.log('arguments %o', parameters);

    try {
			_addEventListener.call(this, ...parameters);
			paragraph.__listeners.push({
				source: this,
				parameters: parameters
			});
		}
		catch (error) {
			throw error;
		}
  };
  
  beforeRunCodeRan = true;
});

Codestrate.addEventListener("afterruncode", event => {

  // This script runs only afterruncode.
  if (beforeRunCodeRan) {
  	Node.prototype.addEventListener = _addEventListener;
  }
});</PRE></DIV><DIV class="paragraph code-paragraph collapsed" draggable="false" name="Destroy DOM Elements On Rerun" __wid="VQceycnw"><PRE data-type="content" type="text/javascript" __wid="CrD23_8y">let beforeRunCodeRan = false;
let _appendChild;

Codestrate.addEventListener("beforeruncode", event => {

  const { paragraph, code } = event;
  
  if (paragraph.__appendChilds) {
    paragraph.__appendChilds.forEach(child => {
      child.remove();
    });
  }

  paragraph.__appendChilds = [];

  _appendChild = Node.prototype.appendChild;
  
  Node.prototype.appendChild = function(child) {
    paragraph.__appendChilds.push(child);
    _appendChild.call(this, child);
  };
  
  beforeRunCodeRan = true;
});

Codestrate.addEventListener("afterruncode", event => {

  // This script runs only afterruncode.
  if (beforeRunCodeRan) {
  	Node.prototype.appendChild = _appendChild;
  }
});</PRE></DIV><DIV class="paragraph code-paragraph collapsed" name="Action Utils" draggable="false" __wid="WVpOYaKn"><PRE data-type="content" type="text/javascript" id="action-utils" __wid="1XAMBwn7">exports.create = (action, options = {}) => {
  
  options = Object.assign({
    classNames: null,
    text: null
  }, options);
  
  const button = document.createElement("div");
  button.setAttribute("class", "action" + (options.classNames ? " " + options.classNames : ""));
  button.addEventListener("click", action);
  
  if (options.text) {
    const text = document.createElement("span");
    text.setAttribute("class", "action-label");
    text.innerText = options.text;
    button.appendChild(text);
  }
	
	if (options.tooltip) {
		button.setAttribute("tooltip", options.tooltip);
	}

  const icon = document.createElement("i");
  icon.setAttribute("class", "material-icons");
  button.appendChild(icon);
  
  return button;
}</PRE></DIV><DIV class="paragraph code-paragraph collapsed" name="Global Menu Code" draggable="false" run-on-load="true" __wid="kleXTgYw"><PRE data-type="content" type="text/javascript" __wid="xt0avRrd">// The global menu.
const globalMenu = document.createElement("transient");
globalMenu.setAttribute("id", "global-menu");
globalMenu.setAttribute("class", "closed");

// Handle to open and close the global menu.
const handle = document.createElement("span");
handle.setAttribute("class", "handle");
handle.addEventListener("click", () => {
  globalMenu.classList.toggle("closed");
});
globalMenu.appendChild(handle);

// Close menu on click outside of global menu.
/*window.addEventListener("click", event => {
  if (!event.target.closest('#global-menu')) {
    globalMenu.classList.add("closed");
  }
});*/

document.body.appendChild(globalMenu);

const addButton = (name, classNames, action) => {
  const button = document.createElement("button");
  button.innerText = name;
  
  if (classNames) {
    button.setAttribute("class", classNames);
  }
  
  if (typeof action === 'function') {
    button.addEventListener("click", action);
  }
  
  globalMenu.appendChild(button);
  
  return button;
};

const addDivider = () => {
  const divider = document.createElement("hr");
  globalMenu.appendChild(divider);
};

const addSectionMeta = function(section) {
  
  const updateLabel = (name) => {
    
    // Set default name.
    if (!name) {
      name = "No Name"
    }
    
    const visible = !section.classList.contains("section-hidden");
    
    if (visible) {
      button.innerText = "Hide " + name;
    }
    else {
      button.innerText = "Show " + name;
    }
  };
  
  const button = addButton("-", "show-section-hidden", () => {
    section.classList.toggle("section-hidden");
    
    updateLabel(section.getAttribute("name"));
    
    // CodeMirror requires a refresh on the editor if any of the parent or
    // container styles changed.
    if (!section.classList.contains("section-hidden")) {
      const contents = Array.from(section.querySelectorAll('.paragraph:not(.collapsed) [data-type="content"]'));
      
      contents.forEach(content => {
        if (content && content.__editor && content.__editor.editor) {
          content.__editor.editor.refresh();
        }
      });
    }
  });
  
  section.liveAttribute("name").changed(updateLabel);
  
  button.section = section;
};

const removeArticleMeta = function(section) {
  
  const metas = Array.from(globalMenu.querySelectorAll('.show-section-hidden'));
  metas.forEach(meta => {
    
    if (meta.section === section) {
      meta.remove();
    }
  });
};

addButton("Add new section", null, () => {
  const section = document.createElement("div");
  section.classList.add("section");

	// Causes an section to be first element on reload...
// 	document.body.appendChild(section);
	
	// FIX that causes sections to be first element when document.body.appendChild
	let lastPersistentElement = document.body.lastElementChild;
	while (lastPersistentElement && lastPersistentElement.tagName.toUpperCase() === "TRANSIENT") {
		lastPersistentElement = lastPersistentElement.previousElementSibling;
	}
	
	document.body.insertBefore(section, lastPersistentElement.nextElementSibling);
});

addDivider();

const tagVersion = (name) => {
	webstrate.tag(name);
}

addButton("Create copy of codestrate", null, () => {
	globalMenu.classList.add("closed");
	window.location = `/${webstrate.webstrateId}/?copy`;
});

addButton("Tag codestrate", null, () => {
	
	globalMenu.classList.add("closed");

  const result = prompt('Set tag name', "", "Tag codestrate");
	if (result instanceof Promise) {
		result.then(r => {
			if (r) {
				tagVersion(r);
			}
		});
	}
	else {
		if (result) {
			tagVersion(result);
		}
	}
});

addButton("Restore codestrate", null, () => {
	globalMenu.classList.add("closed");
  Codestrate.showTags();
});

addDivider();

const sectionTree = document.createElement("ul");
sectionTree.id = "section-tree";
globalMenu.appendChild(sectionTree);

/*document.liveQuerySelectorAll('.section')
  .added(addSectionMeta)
  .removed(removeArticleMeta);*/</PRE></DIV><DIV class="paragraph style-paragraph collapsed" name="Global Menu Style" draggable="false" __wid="AQRgOtEZ"><STYLE data-type="content" type="text/css" codemirror="true" __wid="1IesOTPM">#global-menu {
	position: fixed;
	top: 0;
	right: 0;
	bottom: 0;
	height: 100vh;
	z-index: 100;
	width: 300px;
	padding: 10px;
	background: rgba(20, 20, 20, 1.0);

	transition: transform 500ms ease-in-out 0s;
}

#global-menu.closed {
	transform: translate3d(100%, 0, 0);
}

#global-menu .handle {
	position: absolute;
	left: 0;
	top: 50%;
	transform: translate3d(-100%, -50%, 0) rotate(90deg);
	cursor: pointer;
}

#global-menu .handle:after {
	font-family: 'Material Icons';
	font-weight: normal;
	font-style: normal;
	font-size: 24px;
	display: inline-block;
	line-height: 1;
	text-transform: none;
	letter-spacing: normal;
	word-wrap: normal;
	white-space: nowrap;
	direction: ltr;
	-webkit-font-smoothing: antialiased;
	text-rendering: optimizeLegibility;
	-moz-osx-font-smoothing: grayscale;
	font-feature-settings: 'liga';
	
	content: "drag_handle";
	font-size: 1.6em;
	background: rgba(20, 20, 20, 1.0);
	margin-right: 4px;
	border-bottom-right-radius: 2px;
	border-bottom-left-radius: 2px;
}

#global-menu hr {
	border-top: none;
	border-left: none;
	border-right: none;
	border-bottom: 1px solid rgb(135, 135, 129);
}

#global-menu button {
	display: block;
	font-size: 0.9em;
	background-color: transparent;
	border: none;
	color: white;
	margin-top: 5px;
	margin-bottom: 5px;
	text-align: left;
	cursor: pointer;
}

#global-menu button:hover {
	color: orange;  
}

#global-menu button:focus {
	outline: none;  
}</STYLE></DIV><DIV class="paragraph code-paragraph collapsed" name="Section Code" draggable="false" run-on-load="true" __wid="RWd1_4zO"><PRE data-type="content" type="text/javascript" __wid="K_kyxOoE">const ActionUtils = require('#action-utils');

/**
 * Add a transient header to the section. This transient element will
 * contain all section specific actions, like collapse, and sortable.
 */
const addArticleHeader = (section) => {
  
	// Add section header only once.
	if (section.querySelector('.section-header')) return;
	
  const header = document.createElement("transient");
  header.setAttribute("class", "section-header");
  
  addEditableElement(section, header, "name");
  addEditableElement(section, header, "id");
  
  addDeleteAction(section, header);
	addToggleSystemSectionAction(section, header);
  addHideCollapsedParagraphsAction(section, header);
	
  addDataParagraphAction(section, header);
  addCodeParagraphAction(section, header);
  addStyleParagraphAction(section, header);
  addContentParagraphAction(section, header);
  
  section.insertBefore(header, section.firstChild);
}

/**
 *
 */
const addEditableElement = (section, header, attributeName) => {
  
  // Add title name element to header.
  const nameElement = document.createElement("span");
  nameElement.setAttribute("class", `${attributeName}-input`);
  nameElement.setAttribute("contenteditable", "true");
  
  section.liveAttribute(attributeName).changed(value => {
		// This fixes a bug introduced in Chrome 57 and Safari resulting in reverse
		// text input.
		let position = HTMLUtils.getCaretPosition(nameElement);
    nameElement.innerHTML = value || "";
		HTMLUtils.setCaretPosition(nameElement, position);
  });
  
  nameElement.addEventListener("input", function () {
    const name = nameElement.innerText;
    const hasName = !!name.trim().length;

    if (!hasName) {
      section.removeAttribute(attributeName);
    }
    else {
      section.setAttribute(attributeName, name);
    }
  });
  header.appendChild(nameElement);
};

/**
 *
 */
const addDeleteAction = (section, header) => {
  const action = ActionUtils.create(() => {

    const name = section.getAttribute("name");

    let message = "Do you really want to delete this section?";
    if (name && name !== "") {
      message = "Do you really want to delete section " + name + " ?";
    }

    const result = confirm(message, "Delete Section");

		if (result instanceof Promise) {
			result.then(r => {
				if (r) {
					section.remove();
				}
			})
    }
		else if (result) {
			section.remove();
		}
  }, { classNames: "delete-section", tooltip: true });
  
  header.appendChild(action);
};

const createParagraph = (type) => {
  const paragraph = document.createElement("div");
  paragraph.classList.add("paragraph");
  paragraph.classList.add(`${type}-paragraph`);
  return paragraph;
}

const addContentParagraphAction = (section, header) => {
  const action = ActionUtils.create(() => {

    const paragraph = createParagraph("body");

    const content = document.createElement("div");
    content.setAttribute("data-type", "content");
    content.setAttribute("type", "text/html");
    content.setAttribute("codemirror", "true");
    content.contentEditable = true;
    paragraph.appendChild(content);

    section.appendChild(paragraph);
    
  }, { classNames: "add-body-paragraph", tooltip: true });
  
  header.appendChild(action);
};

/**
 *
 */
const addCodeParagraphAction = (section, header) => {
  const action = ActionUtils.create(() => {

    const paragraph = createParagraph("code");

    const code = document.createElement("pre");
    code.innerText = "// JavaScript code here";
    code.setAttribute("data-type", "content");
    code.setAttribute("type", "text/javascript");
    paragraph.appendChild(code);

    section.appendChild(paragraph);
    
  }, { classNames: "add-code-paragraph", tooltip: true });
  
  header.appendChild(action);
};

/**
 *
 */
const addStyleParagraphAction = (section, header) => {
  const action = ActionUtils.create(() => {
    
    const paragraph = createParagraph("style");

    const code = document.createElement("style");
    code.innerText = "/* CSS here */";
    code.setAttribute("data-type", "content");
    code.setAttribute("type", "text/css");
    code.setAttribute("codemirror", "true");
    paragraph.appendChild(code);

    section.appendChild(paragraph);
    
  }, { classNames: "add-style-paragraph", tooltip: true });
  
  header.appendChild(action);
};

/**
 *
 */
const addDataParagraphAction = (section, header) => {
  const action = ActionUtils.create(() => {

    const paragraph = createParagraph("data");

    const data = document.createElement("pre");
    data.innerText = "/* JSON here */";
    data.setAttribute("data-type", "content");
    data.setAttribute("type", "application/json");
    paragraph.appendChild(data);

    section.appendChild(paragraph);
    
  }, { classNames: "add-data-paragraph", tooltip: true });
  
  header.appendChild(action);
};

/**
 *
 */
const addHideCollapsedParagraphsAction = (section, header) => {

  const action = ActionUtils.create(() => {
    section.classList.toggle("hide-collapsed-paragraphs"); 
  }, {
		classNames: "hide-collapsed-paragraphs2",
		tooltip: true
	});
  
  header.appendChild(action);
};


const addToggleSystemSectionAction = (section, header) => {
  
	const action = ActionUtils.create(() => {
    
    if (section.hasAttribute("data-type")) {
      section.removeAttribute("data-type");
    }
    else {
      section.setAttribute("data-type", "system");
    }
  }, {
		classNames: "toggle-system-section",
		tooltip: true
	});
  
  header.appendChild(action);
};

// Live query the body for existing sections on load and new sections
// added later.
const sectionQuery = document.body.liveQuerySelectorAll('.section', { childList: true, subtree: false})
  .added(addArticleHeader);</PRE></DIV><DIV class="paragraph style-paragraph collapsed" name="Section Style" draggable="false" style="null" __wid="jNtO94zh"><STYLE data-type="content" type="text/css" codemirror="true" __wid="JgWa7CI0">.section {
  position: relative;
}

.section.section-hidden,
.section.section-hidden * {
/*   position: absolute;
  visibility: hidden;
  pointer-events: none;
  height: 0; */
	display: none;
}

.section .section-header {
  display: block;
  height: 36px;
  padding-top: 7px;
  padding-left: 7px;
  background: rgba(0, 0, 0, .6);
  font-family: Arial, sans-serif;
  font-size: 1.2em;
  margin-bottom: 10px;
  border-radius: 2px;
}

/*.section .name-input:empty:before {
  content: "No Name";
  display: inline-block;
  color: rgba(255, 255, 255, .5);
}*/

.section .section-header .action {
	position: relative;
  float: right;
  margin-right: 10px;
  cursor: pointer;
  font-size: .6em;
}

/* Icon Add Content */
.section .section-header .add-body-paragraph i:after {
	content: "text_fields";
}

/* Tooltip Add Content */
.section .section-header .add-body-paragraph:after {
	content: "Add Content";
}

/* Icon Add Code */
.section .section-header .add-code-paragraph i:after {
	content: "code";
}

/* Tooltip Add Code */
.section .section-header .add-code-paragraph:after {
	content: "Add Code";
}

/* Icon Add Style */
.section .section-header .add-style-paragraph i:after {
	content: "brush";
}

/* Tooltip Add Style */
.section .section-header .add-style-paragraph:after {
	content: "Add Style";
}

/* Icon Add Data */
.section .section-header .add-data-paragraph i:after {
	content: "storage";
}

/* Tooltip Add Data */
.section .section-header .add-data-paragraph:after {
	content: "Add Data";
}

/*.section[name]:after {
  content: attr(name);
  position: absolute;
  top: 0;
  left: 0;
  margin-left: 7px;
  margin-top: 7px;
  font-family: Arial, sans-serif;
  font-size: 1.2em;
}*/

.section .section-header .name-input {
  position: absolute;
}

.section .section-header .name-input:focus {
  outline: none;
}

.section .section-header .name-input:empty:focus {
  outline: 1px solid white;
  opacity: 1.0;
  animation-name: blink-cursor;
  animation-duration: 500ms;
  animation-direction: alternate;
  animation-iteration-count: infinite;
  animation-timing-function: ease-in-out;
}

.section .section-header .name-input:empty:before {
  content: "No Name";
  opacity: .5;
}

.section .section-header .name-input:empty:focus:before {
  content: "";
}

.section .section-header .delete-section {
  margin-left: 20px;
}

.section .section-header .action {
  opacity: 0.25;
  pointer-events: none;
}

.section .section-header:hover .action {
  opacity: 1.0;
  pointer-events: all;
}

.section .section-header .action:hover {
  color: orange;
}

.section .section-header .delete-section:hover {
  color: red;
}

/* Icon Delete */
.section .section-header .delete-section i:after {
  content: "delete";
}

/* Tooltip Delete */
.section .section-header .delete-section:after {
  content: "Delete";
}

/* Hide Collapsed Sections */
.section.hide-collapsed-paragraphs .paragraph.collapsed {
	display: none;
}

.section.hide-collapsed-paragraphs .hide-collapsed-paragraphs2 {
	opacity: 1.0;
}

/* Icon Show Collapsed Paragraphs */
.section.hide-collapsed-paragraphs .hide-collapsed-paragraphs2 i:after {
  content: "visibility_off";
}

/* Tooltip Show Collapsed Paragraphs */
.section.hide-collapsed-paragraphs .hide-collapsed-paragraphs2:after {
  content: "Show Collapsed Paragraphs";
}

/* Icon Hide Collapsed Paragraphs */
.section:not(.hide-collapsed-paragraphs) .hide-collapsed-paragraphs2 i:after {
  content: "visibility";
}

/* Tooltip Hide Collapsed Paragraphs */
.section:not(.hide-collapsed-paragraphs) .hide-collapsed-paragraphs2:after {
  content: "Hide Collapsed Paragraphs";
}

/* Icon Not System Section */
.section .toggle-system-section i:after {
  content: "extension";
}

/* Tooltip Not System Section */
.section .toggle-system-section:after {
  content: "Activate System Section";
}

/* System Section */
.section[data-type="system"] .toggle-system-section {
  color: lime;
	opacity: 1.0 !important;
}

/* Tooltip Not System Section */
.section[data-type="system"] .toggle-system-section:after {
  content: "Deactivate System Section";
}</STYLE></DIV><DIV class="paragraph code-paragraph collapsed" name="Variable Code" draggable="false" run-on-load="true" __wid="mdQkuviQ"><PRE data-type="content" type="text/javascript" __wid="GZy39hK7">window.Variable = function (name) {

  const variables = Array.from(document.querySelectorAll(`div.variable[data-name="${name}"]`));

  this.set = function (value) {
    variables.forEach(variable => {
      variable.innerHTML = value;
    });
  }

  this.setTransient = function (value) {
    variables.forEach(variable => {
      variable.innerHTML = `&lt;transient>${value}&lt;/transient>`;
    });
  }
	
	this.appendChild = function(child) {
		if (variables.length === 0) {
			console.warn(`Variable ${name} does not exist`);
		}
		
		if (variables.length > 1) {
			console.warn(`Variable.appendChild only applied to first variable`);
		}
		
		if (variables.length > 0) {
			variables[0].appendChild(child);
		}
	}

  return this;

}.bind({});</PRE></DIV><DIV class="paragraph style-paragraph collapsed" name="Variable Style" draggable="false" __wid="rjb97oPM"><STYLE data-type="content" type="text/css" codemirror="true" __wid="1GydNPC6">.variable {
	position: relative;
	display: inline;
	color: deepskyblue;
}

.variable:empty:before {
	content: attr(data-name) " (unset)";
}

.variable:before {
	content: attr(data-name) " = ";
	color: orange;
	opacity: .5;
}

.hide-variable-names .variable:not(:empty):before {
	display: none;
}

.hide-variable-names .variable:not(:empty):hover:before {
	content: attr(data-name);
	position: absolute;
	top: 0;
	left: 0;
	transform: translate3d(0, -100%, 0);
	display: inline-block;
	border-radius: 2px;
	font-size: .8em;
	padding: 2px;

	color: white;
	background: rgb(135, 135, 129);
	opacity: 1.0;
	/*border: 5px solid transparent;*/
}</STYLE></DIV><DIV class="paragraph code-paragraph collapsed" draggable="false" name="Paragraph Utils Code" __wid="07XqtyAn"><PRE data-type="content" type="text/javascript" id="paragraph-utils" __wid="vnhpm6Kb">const paragraphHeaderClass = "paragraph-header";

/**
 * Get paragraph header or create a new transient header if it does not
 * exist.
 */
const getHeader = (paragraph) => {
  
  let header = paragraph.querySelector(`.${paragraphHeaderClass}`);
  if (!header) {
    header = document.createElement("transient");
    header.setAttribute("class", paragraphHeaderClass);
    paragraph.insertBefore(header, paragraph.firstChild);
  }
  return header;
};

/**
 * Get content element.
 */
const getContentElement = (paragraph) => {
  return paragraph.querySelector('[data-type="content"]');
};

exports.getHeaderElement = getHeader;
exports.getContentElement = getContentElement;

exports.addHeaderAction = (paragraph, className, action, options) => {
  
  let header = getHeader(paragraph);
  
  // Only add header action once.
  if (header.querySelector(`.${className}`)) return;
  
  const actionElement = document.createElement("div");
  actionElement.setAttribute("class", `action ${className}`);
  
  // Add action if defined.
  if (action) {
    actionElement.addEventListener("click", action);
  }
	
	// Add tooltip when provided as optional setting
	if (options && options.tooltip) {
		actionElement.setAttribute("tooltip", options.tooltip);
	}

  const icon = document.createElement("i");
  icon.setAttribute("class", "material-icons");
  actionElement.appendChild(icon);
  
  header.appendChild(actionElement);
  
  return actionElement;
};

exports.addEditableElement = (target, attributeName, proxyElement) => {
  
  // Only add editable element once.
  if (target.querySelector(`span.${attributeName}-input`)) return;
  
  // Add title name element to header.
  const nameElement = document.createElement("span");
  nameElement.setAttribute("class", `input ${attributeName}-input`);
  nameElement.setAttribute("contenteditable", "true");
  
  // Update when changing to the attribute happen (also remote updates).
  proxyElement.liveAttribute(attributeName).changed(value => {
		// This fixes a bug introduced in Chrome 57 and Safari resulting in reverse
		// text input.
		let position = HTMLUtils.getCaretPosition(nameElement);
    nameElement.innerHTML = value || "";
		HTMLUtils.setCaretPosition(nameElement, position);
  });
  
  nameElement.addEventListener("input", function () {
    const name = nameElement.innerText;
    const hasName = !!name.trim().length;

    if (!hasName) {
      proxyElement.removeAttribute(attributeName);
    }
    else {
      proxyElement.setAttribute(attributeName, name);
    }
  });
  target.appendChild(nameElement);
};</PRE></DIV><DIV class="paragraph code-paragraph collapsed" name="Focussed Section" draggable="false" run-on-load="true" __wid="NY6r9pkk"><PRE data-type="content" type="text/javascript" __wid="58WlcthE">window.addEventListener("click", function (event) {
  if (!event.target || !event.target.closest) return;

  if (!event.target.closest('.paragraph') && window.Codestrate.focussedSection) {
    window.Codestrate.focussedSection = null;
  }
});

window.addEventListener("focus", function (event) {
  if (!event.target || !event.target.closest) return;

  const paragraph = event.target.closest('.paragraph');

  if (paragraph === window.Codestrate.focussedSection) return;

  if (window.Codestrate.focussedSection) {
    window.Codestrate.focussedSection = null;
  }

  if (paragraph) {
    window.Codestrate.focussedSection = paragraph;
  }
}, true);</PRE></DIV><DIV class="paragraph style-paragraph collapsed" name="Main" draggable="false" __wid="gylEn2Wz"><STYLE data-type="content" type="text/css" codemirror="true" __wid="x84ZPERy">* {
  box-sizing: border-box;
}

html {
  width: 100%;
  margin: 0;
  background-color: rgb(48, 48, 48);
/* 	background-color: hotpink; */
  
  color: gainsboro;
  font-family: Avenir, Arial, sans-serif;
}

body {
  margin: 0 auto;
	position: relative;
  width: 50em;
	max-width: 100vw;
	padding: 0;
	overflow: hidden;
	overflow-y: auto;
}

/* iPhone media query */
@media only screen 
and (min-device-width : 375px) 
and (max-device-width : 667px) {
	body {
		width: 100vw;
	}
}

/* Fix Chrome setting h1 font-size to 1.17em in paragraphs within sections */
h1 {
  font-size: 2em;
}

.section {
  margin-top: 10px;
}

.paragraph {
  clear: both;
  position: relative;
/*   resize: vertical; */
  margin-top: 10px;
}

.paragraph pre {
  margin: 0px;
  padding: 0px;
}

.paragraph pre[type]  {
  display: none;
}

.paragraph.body-paragraph [data-type="content"] {
  font-size: 11pt;
  box-sizing: border-box;
  margin: 5px;
}

/* Style achors in text paragraphs */
.paragraph.body-paragraph [data-type="content"] a {
	color: white;
}

/* Reset box-sizing of content paragraphs to their initial value */
.paragraph.body-paragraph [data-type="content"] * {
  box-sizing: initial;
}

.paragraph div:focus {
  outline: none;
}</STYLE></DIV><DIV class="paragraph style-paragraph collapsed" name="Paragraph Style" draggable="false" __wid="UWJ4p6BB"><STYLE data-type="content" type="text/css" codemirror="true" __wid="K5fH-k7D">.paragraph .paragraph-header {
  display: block;
  position: relative;
  display: block;
  background: rgba(0, 0, 0, .3);
  width: 100%;
  height: 30px;
  border-radius: 2px;
}

.paragraph .paragraph-header .action {
  position: relative;
  float: right;
  height: 100%;
  
  cursor: pointer;
  margin-right: 10px;
  opacity: .25;
  pointer-events: none;
}

.paragraph .paragraph-header .action:hover {
	color: orange;
}

.paragraph .paragraph-header:hover .action {
  pointer-events: initial;
  opacity: 1.0;
}

.paragraph .paragraph-header .action .material-icons {
  position: relative;
  top: 50%;
  transform: translate3d(0, -50%, 0);
}</STYLE></DIV><DIV class="paragraph code-paragraph collapsed" draggable="false" name="Paragraph Collapse Action Code" run-on-load="true" __wid="KAjNOLKq"><PRE data-type="content" type="text/javascript" __wid="y656fuK5">const SectionUtils = require('#paragraph-utils');

const addCollapsibleAction = function(paragraph) {
  SectionUtils.addHeaderAction(paragraph, "collapse-expand", () => {
    paragraph.classList.toggle("collapsed");
  }, {
		tooltip: true
	});

  // CodeMirror requires a refresh on the editor if any of the parent or
  // container styles changed.
  const updateEditor = () => {
    
    const content = paragraph.querySelector('[data-type="content"]');
      
    if (content && content.__editor && content.__editor.editor) {
      content.__editor.editor.refresh();
    }
  }
  
  paragraph.liveAttribute("class").changed(updateEditor);
}

document.liveQuerySelectorAll('.paragraph').added(addCollapsibleAction);</PRE></DIV><DIV class="paragraph style-paragraph collapsed" name="Paragraph Collapse Style" draggable="false" __wid="8eiJ_poA"><STYLE data-type="content" type="text/css" codemirror="true" __wid="_ohWAeA2">/* Icon expanded */
.collapse-expand i:after {
  content: "expand_less";
}

/* Tooltip expanded */
.collapse-expand:after {
	content: "Collapse";
}

/* Icon collapsed */
.paragraph.collapsed .collapse-expand i:after {
  content: "expand_more";
}

/* Tooltip collapsed */
.paragraph.collapsed .collapse-expand:after {
	content: "Expand";
}

/* Hide all content of a paragraph except the paragraph header */
.paragraph.collapsed > *:not(.paragraph-header) {
	display: none;
}</STYLE></DIV><DIV class="paragraph code-paragraph collapsed" name="Paragraph Sortable Action Code" draggable="false" run-on-load="true" last-execution-state="success" __wid="uOuGDw20"><PRE data-type="content" type="text/javascript" __wid="1xGULlIG">importLib("Sortable.js").then(() => {

  const ParagraphUtils = require('#paragraph-utils');

  const addSortableAction = function(paragraph) {
    ParagraphUtils.addHeaderAction(paragraph, "drag-handle");
		
		paragraph.addEventListener("dragstart", event => {
			let clonedNode = paragraph.cloneNode(true);
			clonedNode.classList.remove("dragging");
			clonedNode.removeAttribute("style");
			
			let transients = clonedNode.querySelectorAll('transient');
			Array.prototype.forEach.call(transients, transient => {
				transient.remove();
			});
			
			let html = clonedNode.outerHTML;
			
			let data = {
				webstrateId: webstrate.webstrateId,
				type: "paragraph",
				html: html
			}
			
			event.dataTransfer.setData('application/x-codestrate', JSON.stringify(data));
			
		}, false);
  }
	
	const initSortable = function(section) {
		
		/* events fired on the drop targets */
		section.addEventListener("dragover", event => {
			event.preventDefault();
		}, false);
		
		section.addEventListener("drop", event => {
			let plainData = event.dataTransfer.getData('application/x-codestrate');
			if (!plainData) return;
			
			let data = JSON.parse(plainData);
			
			// Drag and drop occured in the same codestrate, thus ignore it
			if (data.webstrateId === webstrate.webstrateId) {
				return;
			}
			
			let container = document.createElement("div");
			container.innerHTML = data.html;
			section.appendChild(container.children[0]);
		}, false);
		
    Sortable.create(section, {
      group: {
        name: "blocks"//,
        // pull: 'clone'
      },
      animation: 150,
      // sort: false,
      draggable: '.paragraph',
      handle: '.drag-handle',
      ghostClass: "dragging",  // Class name for the drop placeholder
      chosenClass: "dragging",  // Class name for the chosen item
      dragClass: "dragging",  // Class name for the dragging item
			
			scrollSensitivity: 30, // px, how near the mouse must be to an edge to start scrolling.
			scrollSpeed: 30, // px

      onChoose: function (/**Event*/evt) {

        if (window.Codestrate.focussedSection) {
          // removeConsole(window.Codestrate.focussedSection);
          window.Codestrate.focussedSection = null;
        }
      },

      // Element dragging started
      onStart: function (/**Event*/evt) {

        const codes = Array.from(document.querySelectorAll('pre[type],*[codemirror]'));
        codes.forEach(code => {
          if (code.__editor) {
            code.__editor.editor.setOption('dragDrop', false);
          }
        });
      },

      // Element dragging ended
      onEnd: function (/**Event*/evt) {
        const codes = Array.from(document.querySelectorAll('pre[type],*[codemirror]'));
        codes.forEach(code => {
          if (code.__editor) {
            code.__editor.editor.setOption('dragDrop', true);
          }
        });
      },
    });
  };

  document.liveQuerySelectorAll('.section').added(initSortable);
  document.liveQuerySelectorAll('.paragraph').added(addSortableAction);
});</PRE></DIV><DIV class="paragraph style-paragraph collapsed" name="Paragraph Sortable Style" draggable="false" __wid="MG68Q75f"><STYLE data-type="content" type="text/css" codemirror="true" __wid="LALm_Sbp">.paragraph .drag-handle {
  cursor: -webkit-grabbing;
  cursor: move;
  opacity: 0;
  pointer-events: none;
}

.paragraph.dragging > * {
  pointer-events: none;
}

.paragraph.dragging {
  opacity: .5;
}

/* Icon Drag Handle */
.paragraph .drag-handle i:after {
  content: "drag_handle";
}</STYLE></DIV><DIV class="paragraph code-paragraph collapsed" draggable="false" name="Paragraph Code Execution Actions" run-on-load="true" __wid="fJ61zgP7"><PRE data-type="content" type="text/javascript" __wid="qMhJHUKt">const SectionUtils = require('#paragraph-utils');

const runOnLoadAttributeName = "run-on-load";

const addExecuteAction = (paragraph) => {
  SectionUtils.addHeaderAction(paragraph, "execute-paragraph", () => {
    Codestrate.runCode(paragraph);
  }, {
		tooltip: true
	});
};

const addExecuteOnLoadAction = (paragraph) => {
  SectionUtils.addHeaderAction(paragraph, "run-on-load-paragraph", () => {
    
    if (paragraph.hasAttribute(runOnLoadAttributeName)) {
      paragraph.removeAttribute(runOnLoadAttributeName);
    }
    else {
      paragraph.setAttribute(runOnLoadAttributeName, "true");
    }
  }, {
		tooltip: true
	});
};

const addToggleConsoleAction = (paragraph) => {
  SectionUtils.addHeaderAction(paragraph, "toggle-console-paragraph", () => {
    if (paragraph.console) {
      const console = paragraph.console;
      console.toggle();
    }
  }, {
		tooltip: true
	});
};

document.liveQuerySelectorAll('.paragraph').added(paragraph => {
  // Only apply action to code paragraphs.
  if (!paragraph.querySelector('pre[type="text/javascript"]')) return;

  addExecuteOnLoadAction(paragraph);
  addToggleConsoleAction(paragraph);
  addExecuteAction(paragraph);
});</PRE></DIV><DIV class="paragraph style-paragraph collapsed" name="Paragraph Code Execution Styles" draggable="false" __wid="2BZYScWD"><STYLE data-type="content" type="text/css" codemirror="true" __wid="KjCpkpyb">.paragraph .execute-paragraph,
.paragraph .run-on-load-paragraph,
.paragraph .toggle-console-paragraph {
  margin-left: 5px;
}

.paragraph .run-on-load-paragraph {
  margin-right: 10px;
}

.paragraph[run-on-load] .run-on-load-paragraph {
  opacity: 1.0;
  pointer-events: all;
}

/* Icon Execute Code */
.paragraph .execute-paragraph i:after {
  content: "play_circle_outline";
}

/* Tooltip Execute Code */
.paragraph .execute-paragraph:after {
  content: "Execute Code";
}

/* Icon Execute Code on Load */
.paragraph .run-on-load-paragraph i:after {
  content: "directions_run";
}

/* Tooltip Enable Execute Code on Load */
.paragraph .run-on-load-paragraph:after {
  content: "Enable Execute Code on Load";
}

/* Icon Console */
.paragraph .toggle-console-paragraph i:after {
  content: "message";
}

/* Tooltip Console */
.paragraph .toggle-console-paragraph:after {
  content: "Toggle Console";
}

.paragraph[run-on-load] .run-on-load-paragraph i:after {
  color: lime;
}

/* Tooltip Disable Execute Code on Load */
.paragraph[run-on-load] .run-on-load-paragraph:after {
	content: "Disable Execute Code on Load";
}

.paragraph[last-execution-state="error"] .toggle-console-paragraph {
  opacity: 1.0;
}

.paragraph[last-execution-state="error"] .toggle-console-paragraph i:after {
  color: red;
}</STYLE></DIV><DIV class="paragraph code-paragraph collapsed" name="Paragraph Delete Action Code" draggable="false" run-on-load="true" __wid="Gi7fHxzo"><PRE data-type="content" type="text/javascript" __wid="FZKMHVYn">const SectionUtils = require('#paragraph-utils');

const addDeleteAction = (paragraph) => {
  SectionUtils.addHeaderAction(paragraph, "delete-paragraph", () => {
      
    const name = paragraph.getAttribute("name");

    let message = "Do you really want to delete this paragraph?";
    if (name && name !== "") {
      message = "Do you really want to delete paragraph " + name + " ?";
    }
		
		const result = confirm(message, "Delete Paragraph");

		if (result instanceof Promise) {
			result.then(r => {
				if (r) {
					paragraph.remove();
				}
			})
    }
		else if (result) {
			paragraph.remove();
		}
  }, {
		tooltip: true
	});
}

document.liveQuerySelectorAll('.paragraph').added(addDeleteAction);</PRE></DIV><DIV class="paragraph style-paragraph collapsed" name="Paragraph Delete Action Style" draggable="false" __wid="y9irRxQI"><STYLE data-type="content" type="text/css" codemirror="true" contenteditable="true" __wid="RVnY-dhy">.paragraph .delete-paragraph {
  margin-right: 10px;
}

/* Icon Delete */
.paragraph .delete-paragraph i:after {
  content: "delete";
}

/* Tooltip Delete */
.paragraph .delete-paragraph:after {
  content: "Delete";
}

.paragraph .delete-paragraph i:hover:after {
  color: red;
}</STYLE></DIV><DIV class="paragraph code-paragraph collapsed" name="Fullscreen Code" draggable="false" run-on-load="true" last-execution-state="success" __wid="Rci3e9yf"><PRE data-type="content" type="text/javascript" __wid="ciI0vYP1">const toggleFullscreen = (target) => {

	const isFullscreen = document.body.classList.contains("fullscreen");
	if (isFullscreen) {
		const paragraph = document.querySelector('.paragraph.fullscreen');

		document.body.classList.remove("fullscreen");
		paragraph.classList.remove("fullscreen");

		const content = paragraph.querySelector('[data-type="content"]');
		if (content && content.__editor && content.__editor.editor) {
			content.__editor.editor.refresh();
		}
	}
	else {
		const paragraph = target.closest('.paragraph:not(.collapsed)');

		if (paragraph) {
			paragraph.classList.add("fullscreen");
			document.body.classList.add("fullscreen");
		}
	}
}

// Add actions to save html and to toggle html to paragraph header. This
// code might move at some point to the actual active essay code.
const SectionUtils = require('#paragraph-utils');

const addFullscreenButton = (paragraph) => {
	SectionUtils.addHeaderAction(paragraph, "toggle-fullscreen", () => {
		toggleFullscreen(paragraph);
	}, {
		tooltip: true
	});
}

document.liveQuerySelectorAll('.paragraph').added(addFullscreenButton);

importLib([
	"mousetrap.min.js",
	"mousetrap-global-bind.min.js"
]).then(() => {

	// combinations
	Mousetrap.bindGlobal('ctrl+f', function(e) {
		toggleFullscreen(e.target);
		return false;
	});
});</PRE></DIV><DIV class="paragraph style-paragraph collapsed" name="Fullscreen Style" draggable="false" __wid="HWRhqFF1"><STYLE data-type="content" type="text/css" codemirror="true" contenteditable="true" __wid="8zd9tjjx">body.fullscreen {
  overflow: hidden;
}

.paragraph.fullscreen {
  position: fixed;
  left: 0;
  top: 0;
  bottom: 0;
  right: 0;
  width: 100vw;
  height: 100vh;
  z-index: 200;
  margin: 0;
  background: rgb(48, 48, 48);
	-webkit-overflow-scrolling: touch; /* enable elastic scroll on touch devices */
}

/* Prevent input on paragraphs not in fullscreen view */
body.fullscreen .paragraph:not(.fullscreen) {
	pointer-events: none;
}

.paragraph.fullscreen .paragraph-header,
.paragraph.body-paragraph.fullscreen .text-tools {
  position: fixed;
	z-index: 1;
}

/* "Hide" paragraph utils when in locked fullscreen view */
.paragraph.fullscreen.locked .paragraph-header {
	height: 0;
}

/* Position toggle fullscreen button in locked fullscreen view */
.paragraph.fullscreen.locked .paragraph-header > .toggle-fullscreen {
	position: absolute;
	top: 20px;
	right: 10px;
}

/* Position toggle fullscreen button in locked fullscreen view */
.paragraph.fullscreen.locked .paragraph-header > .lock-content {
	position: absolute;
	top: 20px;
	right: 40px;
}

/* !!! Bug: make actions interactive */
.paragraph.fullscreen.locked .paragraph-header .action {
	pointer-events: initial;
}

/* Hide paragraph icon */
.paragraph.fullscreen.locked .paragraph-header:before {
	display: none;
}

.paragraph.fullscreen .paragraph-header .delete-paragraph,
.paragraph.fullscreen .paragraph-header .drag-handle,
.paragraph.fullscreen .paragraph-header .collapse-expand {
	display: none;
}

/* Hide all paragraph actions excluding lock and toggle fullscreen */
.paragraph.fullscreen.locked .paragraph-header > *:not(.lock-content):not(.toggle-fullscreen) {
	display: none;
}

.paragraph.body-paragraph.fullscreen .text-tools {
  top: 30px;
}

.paragraph.fullscreen .CodeMirror {
	width: 100vw;
  height: 100vh;
	overflow: hidden !important;
  overflow-y: auto;
}


.paragraph.fullscreen:not(.locked) .CodeMirror {
  height: calc(100vh - 30px);
  overflow: auto;
}

/* Move CodeMirror down to make space for fixed paragraph utils */
.paragraph.fullscreen:not(.locked) .CodeMirror {
  margin-top: 30px;
}

/* This is a HACK as text paragraph cannot be scrolled in fullscreen otherwise */
.paragraph.body-paragraph.fullscreen [data-type="content"] {
	margin: 0;
	padding: 0;
	width: 100vw;
	height: 100vh;
  overflow: auto;
}

/* Move CodeMirror down to make space for fixed paragraph utils + text tools */
.paragraph.body-paragraph.fullscreen:not(.locked) [data-type="content"] {
	position: absolute;
  top: 75px;
  height: calc(100vh - 75px);
}

/* Icon Fullscreen */
.paragraph .paragraph-header .toggle-fullscreen i:after {
  content: "fullscreen";
}

/* Tooltip Fullscreen */
.paragraph .paragraph-header .toggle-fullscreen:after {
  content: "Fullscreen";
}

/* Icon Exit Fullscreen */
.paragraph.fullscreen .paragraph-header .toggle-fullscreen i:after {
  content: "fullscreen_exit";
}

/* Tooltip Exit Fullscreen */
.paragraph.fullscreen .paragraph-header .toggle-fullscreen:after {
  content: "Exit Fullscreen";
}</STYLE></DIV><DIV class="paragraph code-paragraph collapsed" name="Paragraph Title Code" run-on-load="true" style="null" __wid="R4GiP7eu"><PRE data-type="content" type="text/javascript" __wid="8hLZION9">const ParagraphUtils = require('#paragraph-utils');

document.liveQuerySelectorAll('.paragraph').added(paragraph => {
  
  const header = ParagraphUtils.getHeaderElement(paragraph);
  const content = ParagraphUtils.getContentElement(paragraph);
  
  ParagraphUtils.addEditableElement(header, "name", paragraph);
  ParagraphUtils.addEditableElement(header, "id", content);
  ParagraphUtils.addEditableElement(header, "class", content);
});</PRE></DIV><DIV class="paragraph style-paragraph collapsed" name="Paragraph Title Style" __wid="Jf-zoNIX"><STYLE data-type="content" type="text/css" codemirror="true" __wid="XrcFRoWO">.paragraph .paragraph-header:before {
	font-family: 'Material Icons';
	font-weight: normal;
	font-style: normal;
/* 	font-size: 24px; */
	display: inline-block;
	line-height: 1;
	text-transform: none;
	letter-spacing: normal;
	word-wrap: normal;
	white-space: nowrap;
	direction: ltr;
	-webkit-font-smoothing: antialiased;
	text-rendering: optimizeLegibility;
	-moz-osx-font-smoothing: grayscale;
	font-feature-settings: 'liga';
	
  position: relative;
  top: 7px;
  left: 7px;
}

.paragraph.body-paragraph .paragraph-header:before {
  content: "text_fields";
}

.paragraph.code-paragraph .paragraph-header:before {
  content: "code";
}

.paragraph.style-paragraph .paragraph-header:before {
  content: "brush";
}

.paragraph.data-paragraph .paragraph-header:before {
  content: "storage";
}

.paragraph .paragraph-header .input {
  position: relative;
  top: 5px;
  font-size: .9em;
  z-index: 1;
  display: inline-block;
}


.paragraph .paragraph-header .input:focus {
  outline: none;
}

.paragraph .paragraph-header .input:empty:focus {
  outline: 1px solid white;
  opacity: 1.0;
  animation-name: blink-cursor;
  animation-duration: 500ms;
  animation-direction: alternate;
  animation-iteration-count: infinite;
  animation-timing-function: ease-in-out;
}

.paragraph .paragraph-header .input:empty:before {
  opacity: .5;
}

.paragraph .paragraph-header .input:empty:focus:before {
  content: "";
}

.paragraph .paragraph-header .name-input {
  left: 15px;
  margin-right: 15px;
}

.paragraph .paragraph-header .input:before {
  color: orange;
}

.paragraph .paragraph-header .name-input:empty:before {
  content: "name";
}

.paragraph .paragraph-header .id-input:not(:empty):before {
  content: "#";
}

.paragraph .paragraph-header .id-input:empty:before {
  content: "#id";
  opacity: 0;
  pointer-events: none;
}

.paragraph:hover .paragraph-header .id-input:empty:before {
  opacity: 1.0;
  pointer-events: all;
}

.paragraph .paragraph-header .id-input {
  margin-left: 10px;
}

.paragraph .paragraph-header .class-input:not(:empty):before {
  content: "class: ";
}

.paragraph .paragraph-header .class-input:empty:before {
  content: "class: ";
  opacity: 0;
  pointer-events: none;
}

.paragraph:hover .paragraph-header .class-input:empty:before {
  opacity: 1.0;
  pointer-events: all;
}

.paragraph .paragraph-header .class-input {
  margin-left: 10px;
}</STYLE></DIV><DIV class="paragraph code-paragraph collapsed" name="Text Tools Code" run-on-load="true" __wid="WftY-8N_"><PRE data-type="content" type="text/javascript" __wid="ROhocPwi">const ActionUtils = require('#action-utils');

const addExecCommandAction = (tools, command, options, formatBlock = false) => {
	const commandAction = ActionUtils.create((event) => {
		event.preventDefault();
		document.execCommand(command, null, formatBlock);
	}, options);

	// Need to prevent mousedown and touchstart or otherwise the event does not work.
	commandAction.addEventListener("mousedown", (event) => event.preventDefault());
	commandAction.addEventListener("touchstart", (event) => event.preventDefault());

	tools.appendChild(commandAction);
};

const augmentText = (textElement) => {

	if (textElement.parentElement.querySelector('.text-tools')) return;

	const tools = document.createElement("transient");
	tools.setAttribute("class", "text-tools");

	addExecCommandAction(tools, "bold", { classNames: "text-bold", tooltip: true });
	addExecCommandAction(tools, "italic", { classNames: "text-italic", tooltip: true });
	addExecCommandAction(tools, "underline", { classNames: "text-underline", tooltip: true });
	addExecCommandAction(tools, "strikethrough", { classNames: "text-strikethrough", tooltip: true });

	addExecCommandAction(tools, "InsertUnorderedList", { classNames: "text-list-bulleted", tooltip: true });
	addExecCommandAction(tools, "InsertOrderedList", { classNames: "text-list-numbered", tooltip: true });
	addExecCommandAction(tools, "indent", { classNames: "text-list-indent", tooltip: true });
	addExecCommandAction(tools, "outdent", { classNames: "text-list-outdent", tooltip: true });

	addExecCommandAction(tools, "formatBlock", { classNames: "text-h1", text: "H1", tooltip: true }, "&lt;h1>");

	addExecCommandAction(tools, "formatBlock", { classNames: "text-h2", text: "H2", tooltip: true }, "&lt;h2>");

	addExecCommandAction(tools, "formatBlock", { classNames: "text-h3", text: "H3", tooltip: true }, "&lt;h3>");

	const addVariableAction = ActionUtils.create(() => {
		
		const addVariable = (name) => {
			const variable = document.createElement("div");
			variable.setAttribute("class", "variable");
			variable.setAttribute("tabindex", "-1");
			variable.setAttribute("contenteditable", "false");
			variable.setAttribute("data-name", name);
			
// 			variable.addEventListener("keyup", event => {
// 				const newVariableName = variable.innerText.trim();
				
// 				// Ignore if variable name did not change, e.g., key events
// 				const oldVariableName = variable.getAttribute("data-name");
// 				if (newVariableName === oldVariableName) return;
				
// 				// Delete variable when variable name is empty
// 				if (!newVariableName || newVariableName === "") {
// 					variable.remove();
// 					return;
// 				}
				
// 				// Set new variable name
// 				variable.setAttribute("data-name", newVariableName);
// 			});

			textElement.appendChildAtCaret(variable);
		}

		const result = prompt('Set variable name', "", "Add Variable");
		
		if (result instanceof Promise) {
			result.then(r => {
				if (r) {
					addVariable(r);
				}
			});
		}
		else {
			if (result) {
				addVariable(result);
			}
		}
	}, { classNames: "text-set-variable", text: "Add Variable", tooltip: true });
	tools.appendChild(addVariableAction);

	const hideVariableNamesAction = ActionUtils.create(() => {
		textElement.classList.toggle("hide-variable-names");
	}, { classNames: "text-hide-variable-names", text: "Hide Variable Names", tooltip: true });
	tools.appendChild(hideVariableNamesAction);

	const convertToHtmlAction = ActionUtils.create(() => {
		if (window.getSelection) {
			const text = window.getSelection().toString();
			HTMLUtils.pasteHtmlAtCaret(text);
		}
	}, { classNames: "text-convert-to-html", text: "Convert Html", tooltip: true });
	tools.appendChild(convertToHtmlAction);

	textElement.parentElement.insertBefore(tools, textElement);
};

document.liveQuerySelectorAll('.paragraph.body-paragraph [data-type="content"][contenteditable]').added(augmentText);</PRE></DIV><DIV class="paragraph style-paragraph collapsed" name="Text Tools Style" __wid="LzqNSXMf"><STYLE data-type="content" type="text/css" codemirror="true" contenteditable="true" __wid="6T-6G32S">.text-tools {
/* 	position: relative; */
  display: block;
  width: 100%;
  background-color: rgba(0, 0, 0, .3);
  padding: 5px;
  padding-top: 10px;
  margin-top: 1px;
  border-radius: 2px;
  
/*  border-top: 1px solid rgba(255, 255, 255, .1);*/
  
  -webkit-user-select: none;  /* Chrome all / Safari all */
  -moz-user-select: none;     /* Firefox all */
  -ms-user-select: none;      /* IE 10+ */
  user-select: none;          /* Likely future */   
}

.paragraph.collapsed .text-tools {
  display: none;
}

.text-tools .action {
	position: relative;
  cursor: pointer;
  display: inline-block;
  margin-left: 5px;
}

.text-tools .action:hover {
  color: orange;
}

/* Icon Bold */
.text-tools .text-bold i:after {
  content: "format_bold";
}

/* Tooltip Bold */
.text-tools .text-bold:after {
  content: "Bold";
}

/* Icon Italic */
.text-tools .text-italic i:after {
  content: "format_italic";
}

/* Tooltip Italic */
.text-tools .text-italic:after {
  content: "Italic";
}

/* Icon Underline */
.text-tools .text-underline i:after {
  content: "format_underline";
}

/* Tooltip Underline */
.text-tools .text-underline:after {
  content: "Underline";
}

/* Icon Strikethrough */
.text-tools .text-strikethrough i:after {
  content: "format_strikethrough";
}

/* Tooltip Strikethrough */
.text-tools .text-strikethrough:after {
  content: "Strikethrough";
}

/* Icon Bullets */
.text-tools .text-list-bulleted i:after {
  content: "format_list_bulleted";
}

/* Tooltip Bullets */
.text-tools .text-list-bulleted:after {
  content: "Bullets";
}

/* Icon Numbering */
.text-tools .text-list-numbered i:after {
  content: "format_list_numbered";
}

/* Tooltip Numbering */
.text-tools .text-list-numbered:after {
  content: "Numbering";
}

/* Icon Increase Indent */
.text-tools .text-list-indent i:after {
  content: "format_indent_increase";
}

/* Tooltip Increase Indent */
.text-tools .text-list-indent:after {
  content: "Increase Indent";
}

/* Icon Decrease Indent */
.text-tools .text-list-outdent i:after {
  content: "format_indent_decrease";
}

/* Tooltip Decrease Indent */
.text-tools .text-list-outdent:after {
  content: "Decrease Indent";
}

.text-tools .text-h1,
.text-tools .text-h2,
.text-tools .text-h3,
.text-tools .text-set-variable,
.text-tools .text-hide-variable-names, 
.text-tools .text-convert-to-html {
  margin-left: 10px;
  margin-top: 2px;
  vertical-align: top;
}

/* Tooltip Section */
.text-tools .text-h1:after {
	content: "Format Heading 1"
}

/* Tooltip Subsection */
.text-tools .text-h2:after {
	content: "Format Heading 2"
}

/* Tooltip Subsection */
.text-tools .text-h3:after {
	content: "Format Heading 3"
}

/* Tooltip Add Variable */
.text-tools .text-set-variable:after {
	content: "Add Variable"
}

/* Tooltip Hide Variable Names */
.text-tools .text-hide-variable-names:after {
	content: "Hide Variable Names"
}

/* Tooltip Convert HTML */
.text-tools .text-convert-to-html:after {
	content: "Convert HTML"
}</STYLE></DIV><DIV class="paragraph code-paragraph collapsed" name="Lock Paragraph Code" run-on-load="true" draggable="false" __wid="I_BzCPZa"><PRE data-type="content" type="text/javascript" contenteditable="true" __wid="8xg-iaaO">const SectionUtils = require('#paragraph-utils');

const addLockAction = paragraph => {
  const lockElement = SectionUtils.addHeaderAction(paragraph, "lock-content", () => {
//     window.console.log('lock action');
    
    const content = paragraph.querySelector('[data-type="content"]');
    if (content) {
      if (!content.hasAttribute("contenteditable") || content.getAttribute("contenteditable") === "true") {
        content.setAttribute("contenteditable", "false");
      }
      else {
        content.setAttribute("contenteditable", "true");
      }
    }
  }, {
		tooltip: true
	});
  
  const content = paragraph.querySelector('[data-type="content"]');

//   window.console.log(content);

  if (content) {
    content.liveAttribute("contenteditable").changed((value, oldValue) => {
      const readOnly = value && value === "false" ? true : false;
      if (readOnly) {
        paragraph.classList.add("locked");
      }
      else {
        paragraph.classList.remove("locked");
      }
    });
  }
};

document.liveQuerySelectorAll('.paragraph').added(addLockAction);</PRE></DIV><DIV class="paragraph style-paragraph collapsed" name="Lock Paragraph Style" draggable="false" __wid="ZV0Qy4GG"><STYLE data-type="content" type="text/css" codemirror="true" contenteditable="true" __wid="hQE_9eYM">.paragraph:not(:hover):not(.locked) .paragraph-header .lock-content {
  opacity: 0.25;
  pointer-events: none;
}

.paragraph.locked .paragraph-header .lock-content {
  opacity: 1.0;
}

.paragraph.locked .text-tools {
  display: none;
}

/* Icon Lock */
.paragraph .paragraph-header .lock-content i:after {
  content: "lock_open";
}

/* Tooltip Lock */
.paragraph .paragraph-header .lock-content:after {
  content: "Lock";
}

/* Icon Unlock */
.paragraph.locked .paragraph-header .lock-content i:after {
  content: "lock_outline";
}

/* Tooltip Unlock */
.paragraph.locked .paragraph-header .lock-content:after {
  content: "Unlock";
}

/* .paragraph.fullscreen .paragraph-header .lock-content {
  display: block;
} */</STYLE></DIV><DIV class="paragraph code-paragraph collapsed" name="Load Style (material-icons.css)" run-on-load="true" __wid="Sa5Bh6dE"><PRE data-type="content" type="text/javascript" __wid="OzRnbCzY">importStyle("material-icons.css");</PRE></DIV><DIV class="paragraph code-paragraph collapsed" name="Asset Utils Code" draggable="false" __wid="5OaiWbtl"><PRE data-type="content" type="text/javascript" id="asset-utils" __wid="eToM5JPh">// 1024 bytes * 1024 kB * 20 => 20 MB
const MAX_FILE_SIZE = 1024 * 1024 * 20;

const acceptFileOrThrowError = file => {
  if (file.size > MAX_FILE_SIZE) {
    throw new Error(`File size of ${file.name} is to large. Maximum file size is ${MAX_FILE_SIZE} bytes.`);
  }

  return true;
};

exports.uploadFiles = (files, onUploaded, onBeforeUpload, onError) => {
  
  if (files.length === 0) {
    return;
  }

  files.forEach(file => {

    try {
      acceptFileOrThrowError(file);
      
//       window.console.log('file', file);

      const uuid = webstrates.util.randomString();

      const reader = new FileReader();
      reader.onload = function (e) {
        const asset = {
          uuid: uuid,
          fileName: file.name,
          mimeType: file.type,
          source: e.target.result
        }
        
        if (typeof onBeforeUpload === 'function') {
          onBeforeUpload(asset);
        }

        const formData = new FormData();
        formData.append("file", file, file.name);

        const request = new XMLHttpRequest();
        request.open("POST", window.location.pathname);
        request.send(formData);
        request.addEventListener("load", (e) => {
          const asset = JSON.parse(request.responseText);
          asset.uuid = uuid;
          asset.source = asset.fileName;

          onUploaded(asset);
        });
      }
      reader.readAsDataURL(file);
    }
    catch (error) {
      onError(error);
    }
  });
};

exports.getElementFromAsset = asset => {

  let node;

  switch (asset.mimeType) {
    case "image/jpeg":
    case "image/png":
      node = document.createElement("img");
      node.setAttribute("src", asset.source);
      break;
    case "audio/mp3":
      node = document.createElement("audio");
      node.setAttribute("src", asset.source);
      node.setAttribute("controls", "true");
      break;
    case "video/mp4":
      node = document.createElement("video");
      node.setAttribute("src", asset.source);
      node.setAttribute("controls", "true");
      break;
    default:
			node = document.createElement("a");
			node.setAttribute("href", asset.source);
			node.setAttribute("target", "_blank");
			node.innerHTML = asset.source;
      break;
  }
	
// 	// Disable (text) selection. It is, for example, necessary to make
// 	// links clickeable.
// 	node.setAttribute("contenteditable", "false");

  return node;
};</PRE></DIV><DIV class="paragraph code-paragraph collapsed" name="Drop Assets Code" run-on-load="true" __wid="HDZrMQsX"><PRE data-type="content" type="text/javascript" __wid="KbIOeO0f">const AssetUtils = require('#asset-utils');

// Get the text paragraph.
var contents = document.liveQuerySelectorAll('.paragraph.body-paragraph [data-type="content"]');

const handleFileDrop = (event, onUploaded, onBeforeUpload, onError) => {
  const files = Array.from(event.dataTransfer.files);
  AssetUtils.uploadFiles(files, onUploaded, onBeforeUpload, onError);
};

const addDropListener = (content) => {
  
  // Listen for a drop
  content.addEventListener("drop", event => {
		
		let isFileDrop = false;
		if (event.dataTransfer.types) {
			for (var i = 0; i&lt; event.dataTransfer.types.length; i++) {
				if (event.dataTransfer.types[i] === "Files") {
					isFileDrop = true;
					break;
				}
			}
		}
		
		// Continue only on file transfer
		if (!isFileDrop) return;
		
    // Prevent the default behavior
    event.preventDefault();

    // Get the position where file(s) where dropped.
    const range = document.caretRangeFromPoint(event.clientX, event.clientY);
  
    /**
     * Called when asset uploaded completely.
     */
    const onUploaded = asset => {
      let node = AssetUtils.getElementFromAsset(asset);

      const uploadInProgress = content.querySelector(`[data-upload-id="${asset.uuid}"]`);

      if (uploadInProgress) {
        uploadInProgress.parentElement.replaceChild(node, uploadInProgress);
      }
      else {
        range.insertNode(node);
      }
    };

    /**
     * Called before asset is going to be uploaded.
     */
    const onBeforeUpload = asset => {

      let node = AssetUtils.getElementFromAsset(asset);

      const uploadInProgress = document.createElement("transient");
      uploadInProgress.setAttribute("data-upload-id", asset.uuid);
      uploadInProgress.setAttribute("class", "upload-in-progress");
      uploadInProgress.appendChild(node);

      range.insertNode(uploadInProgress);
    };

    const onError = error => {
      alert(error);
    };

    // Handle file drop with uploaded, before upload, and error callbacks.
    handleFileDrop(event, onUploaded, onBeforeUpload, onError);
  });
};

contents.added(addDropListener);</PRE></DIV><DIV class="paragraph style-paragraph collapsed" name="Drop Assets Style" __wid="MSWZI9eo"><STYLE data-type="content" type="text/css" codemirror="true" __wid="rAduFIIN">.paragraph [data-type="content"] .upload-in-progress {
  opacity: .25;
}

.paragraph [data-type="content"] video,
.paragraph [data-type="content"] img {
  max-width: 100%;
}</STYLE></DIV><DIV class="paragraph code-paragraph collapsed" name="Add File Code" run-on-load="true" last-execution-state="success" draggable="false" __wid="6aQzlfd2"><PRE data-type="content" type="text/javascript" __wid="syqi5eZd">const AssetUtils = require('#asset-utils');

const createDomNode = (textElement) => {

  const pictureTools = document.createElement("div");
  pictureTools.setAttribute("class", "action add-file");
	pictureTools.setAttribute("tooltip", true);

  const label = document.createElement("label");
  label.setAttribute("class", "material-icons input-button");

  this.input = document.createElement("input");
  this.input.setAttribute("type", "file");
//   this.input.setAttribute("accept", "image/*");

  this.input.addEventListener("change", event => {
    const files = Array.from(this.input.files);
    
//     console.log('upload files %o', files);
    
    AssetUtils.uploadFiles(files, (asset) => {
      addImage(asset, textElement);
    }, null, error => {
      console.error(error);
    });
    
    this.input.value = "";
  });

  label.appendChild(this.input);
  pictureTools.appendChild(label);

  return pictureTools;
}

const addImageTool = (textElement) => {
  
  const tools = textElement.parentElement.querySelector('.text-tools');
  
  if (!tools) return;
  
  // Only add image tools once.
  if (tools.querySelector('.add-file')) return;
  
  const imageTool = createDomNode(textElement);
  tools.appendChild(imageTool)
};

const addImage = (asset, textElement) => {
  
//   console.log('add image %o', asset);
  
  const element = AssetUtils.getElementFromAsset(asset);
  if (element) {
    if (!HTMLUtils.appendChildAtCaret(element, (range) => {
      return textElement.contains(range.commonAncestorContainer);
    })) {
      textElement.appendChild(element);
    }
  }
}

document.liveQuerySelectorAll('.paragraph.body-paragraph [data-type="content"][contenteditable]').added(addImageTool);

// const resizeImage = (img) => {
//   let width = img.width;
//   let height = img.height;

//   const max = Math.max(width, height);
//   const min = Math.min(width, height);

//   const maxSize = 800;

//   // Resize image when to large.
//   if (max > maxSize) {

//     let newWidth = width > height ? maxSize : (min / max) * maxSize;
//     let newHeight = height > width ? maxSize : (min / max) * maxSize;
//     width = newWidth;
//     height = newHeight;

//     const canvas = document.createElement('canvas');
//     const ctx = canvas.getContext('2d');
//     canvas.width = newWidth;
//     canvas.height = newHeight;

//     /// step 1 - resize to 50%
//     const oc = document.createElement('canvas');
//     const octx = oc.getContext('2d');

//     oc.width = img.width * 0.5;
//     oc.height = img.height * 0.5;
//     octx.drawImage(img, 0, 0, oc.width, oc.height);

//     /// step 2 - resize 50% of step 1
//     octx.drawImage(oc, 0, 0, oc.width * 0.5, oc.height * 0.5);

//     /// step 3, resize to final size
//     ctx.drawImage(oc, 0, 0, oc.width * 0.5, oc.height * 0.5, 0, 0, canvas.width, canvas.height);

//     img.src = canvas.toDataURL("image/png");
//   }
// }</PRE></DIV><DIV class="paragraph style-paragraph collapsed" name="Add File Style" draggable="false" __wid="bE5To-uL"><STYLE data-type="content" type="text/css" codemirror="true" __wid="XQqu2Cdw">/* Hide native upload file UI element */
.add-file input[type="file"] {
  display: none;
}

/* Icon Upload File */
.add-file label.material-icons:after {
  content: "file_upload";
}

/* Tooltip Upload File */
.add-file:after {
  content: "Upload File";
}</STYLE></DIV><DIV class="paragraph code-paragraph collapsed" run-on-load="true" name="Permission Code" draggable="false" __wid="cGpBzuDb"><PRE data-type="content" type="text/javascript" __wid="jBznkCkj">var Permissions = (function () {

  this.version = "0.0.2";

  /**
   * Get permissions object of current document.
   */
  const getPermissions = function () {
    const htmlElement = document.documentElement;
    const auth = htmlElement.dataset.auth;
    return auth ? JSON.parse(auth) : [];
  };

  /**
   * Applies permissions to current document.
   * 
   * @param [] auth Array containing document permissions (e.g., [{username:"raedle",
   * provider:"github",permissions:"rw"}.{username:"anonymous",provider:"",
   * permissions:"r"}])
   */
  const applyPermissions = function (auth) {
    const htmlElement = document.documentElement;

    if (auth && auth.length) {
      htmlElement.dataset.auth = JSON.stringify(auth);
    }
    else {
      clearPermissions();
    }
  }

  /**
   * Clear all document permissions aka. removes data-auth attribute.
   */
  const clearPermissions = function () {
    const htmlElement = document.documentElement;
    delete htmlElement.dataset.auth;
  }
  /**
   * Grant permissions to username using the given authentication provider.
   * 
   * @param String username Username of user that is granted specific permissions to
   * the current document.
   * @param String permissions Document permissions for username (e.g., "r" or "rw").
   * @param String provider="" Authentication provider, e.g., "github" for GitHub.
   */
  this.grant = function (username, permissions, provider = "") {
    const auth = getPermissions();
    const userPermission = auth.find(item => item.username === username && item.provider === provider);
    if (userPermission) {
      userPermission.permissions = permissions
    }
    else {
      auth.push({
        username,
        provider,
        permissions
      });
    }

    applyPermissions(auth);
  };

  /**
   * @param String username Revoke permissions for username.
   * @param String provider="" Revoke permissions given the particular authentication provider.
   */
  this.revoke = function (username, provider = "") {
    const auth = getPermissions();
    const permissionIndex = auth.findIndex(item => item.username === username && item.provider === provider);
    if (permissionIndex > -1) {
      auth.splice(permissionIndex, 1);
    }
    applyPermissions(auth);
  };

  /**
   * List permissions of current document.
   */
  this.list = function () {
    const auth = getPermissions();
    console.log("Document permissions");
    auth.forEach(({username, permissions, provider}) => {
      console.log("Username %s has %s permissions using %s provider.", username, permissions, provider);
    });
  }

  return this;
}).call({});

window.webstrate.permissions = Permissions;</PRE></DIV><DIV class="paragraph code-paragraph collapsed" name="Hash Scroll Code" run-on-load="true" __wid="xx3zhcO9"><PRE data-type="content" type="text/javascript" __wid="knakXNrH">const element = document.getElementById(window.location.hash.substr(1));

if (element) {
  const scrollToElement = element.parentElement;

  window.addEventListener("codestrateloaded", () => {
    if (scrollToElement) {
      window.scrollTo(0, scrollToElement.getBoundingClientRect().top);
    }
  });
}</PRE></DIV><DIV class="paragraph code-paragraph collapsed" name="Code Failure Handling" run-on-load="true" last-execution-state="success" __wid="xIVV01jX"><PRE data-type="content" type="text/javascript" __wid="xjqCjuay">Codestrate.addEventListener("successruncode", event => {
//   window.console.log(event);
  
  const { paragraph } = event;
  
  paragraph.setAttribute("last-execution-state", "success");
});

Codestrate.addEventListener("errorruncode", event => {
//   window.console.log(event);
  
  const { paragraph } = event;
  
  paragraph.setAttribute("last-execution-state", "error");
});</PRE></DIV><DIV class="paragraph style-paragraph collapsed" name="Tooltip" __wid="AylaylYv"><STYLE data-type="content" type="text/css" codemirror="true" __wid="DVxQb4V2">*[tooltip]:after {
	position: absolute;
	bottom: 0px;
	left: 50%;
	z-index: 98;
	padding: 5px 15px;
	
	color: white;
	background: #333;
	background-color: rgba(0,0,0,.8);
	border-radius: 2px;
	display: inline;
	width: 200px;
	text-align: center;
	transform: translate3d(-50%, -36px, 0);
	opacity: 0;
	
	pointer-events: none;
	
  -webkit-font-smoothing: antialiased; /* webkit text rendering fix */
}

*[tooltip]:hover:after {
	opacity: 1.0;
	transition: opacity 500ms ease-in-out 1500ms;
}

*[tooltip]:before {
	content: "";
	border: solid;
	bottom: 0;
	border-color: #333 transparent;
	border-color: rgba(0,0,0,.8) transparent;
	border-width: 6px 6px 0 6px;
	left: 50%;
	transform: translate3d(-50%, -30px, 0);
	position: absolute;
	z-index: 99;
	opacity: 0;
	
	pointer-events: none;
	
  -webkit-font-smoothing: antialiased; /* webkit text rendering fix */
}

*[tooltip]:hover:before {
	opacity: 1.0;
	transition: opacity 500ms ease-in-out 1500ms;
}</STYLE></DIV></DIV><DIV name="Pull Sections" data-type="system" class="section section-hidden" __wid="7uIApj0R"><DIV class="paragraph code-paragraph collapsed" last-execution-state="success" name="Adding Pull System Sections Action to Articles" __wid="ak2BXbcp"><PRE data-type="content" type="text/javascript" __wid="qUDAFdfc">const ActionUtils = require('#action-utils');

const addUpdateAction = (section) => {
	
	if (webstrate.webstrateId === "Codestrate") {
		console.warn("The prototype of the Inventor's Notebook cannot be updated. Omitting the update feature.");
		return;
	}
	
	const header = section.querySelector('.section-header');
	
	if (!header) return;
	
	const updateAction = ActionUtils.create((event) => {
		console.log('update', webstrate);
	}, { classNames: 'update', text: 'Update' });
	
	header.appendChild(updateAction);
};

document.liveQuerySelectorAll('.section').added(addUpdateAction);</PRE></DIV><DIV class="paragraph code-paragraph collapsed" name="Adding Pull System Sections Action to Global Menu" last-execution-state="success" run-on-load="true" __wid="6yVn-_Zi"><PRE data-type="content" type="text/javascript" __wid="ySEmUxjg">// if (webstrate.webstrateId !== "Codestrate") {

	const globalMenu = document.querySelector('#global-menu');

	globalMenu.appendChild(document.createElement('hr'));

	const updateAction = document.createElement('button');
	updateAction.innerHTML = "Pull System Sections";
	updateAction.addEventListener("click", event => {
		const Puller = require('#pull-system-sections');

		const result = Codestrate.showPullSystemSectionsDialog();
		if (result instanceof Promise) {
			result.then(data => {
				if (data) {
					Puller.pull(data.pullFrom, data.pullClass, data.pullVersion);				
				}
			});
		}
		else if (result) {
			Puller.pull("Codestrate", "", tagOrVersion);
		}
	});

	globalMenu.appendChild(updateAction);
// }
// else {
// 	console.warn("The Codestrate prototype cannot be updated. Omitting the update feature.");
// 	return;
// }</PRE></DIV><DIV class="paragraph code-paragraph collapsed" name="Pull System Sections Code" __wid="nXSyDiO1"><PRE data-type="content" type="text/javascript" id="pull-system-sections" __wid="-_G_iv6w">// from: https://github.com/jserz/js_piece/blob/master/DOM/ChildNode/replaceWith()/replaceWith().md
(function (arr) {
  arr.forEach(function (item) {
    if (item.hasOwnProperty('replaceWith')) {
      return;
    }
    Object.defineProperty(item, 'replaceWith', {
      configurable: true,
      enumerable: true,
      writable: true,
      value: function replaceWith() {
        var argArr = Array.prototype.slice.call(arguments),
          docFrag = document.createDocumentFragment();
        
        argArr.forEach(function (argItem) {
          var isNode = argItem instanceof Node;
          docFrag.appendChild(isNode ? argItem : document.createTextNode(String(argItem)));
        });
        
        this.parentNode.replaceChild(docFrag, this);
      }
    });
  });
})([Element.prototype, CharacterData.prototype, DocumentType.prototype]);

const loadPrototype = (url) => {

	return new Promise((resolve, reject) => {

		const transient = document.createElement("transient");

		// Transclude prototype webstrate only once.
		let iframe = document.querySelector(`iframe[src="${url}"]`);
		if (iframe) {
			if (iframe.webstrate.transcluded) {
				resolve(iframe);
				return;
			}
		}
		else {
			iframe = document.createElement("iframe");
			iframe.setAttribute("src", url);
			iframe.style.display = "none";
			transient.appendChild(iframe);
			document.body.appendChild(transient);
		}

		iframe.webstrate.on("transcluded", (webstrateId) => {

			// Continue if it is not this webstrate that transcluded
			if (iframe.contentWindow.webstrate.webstrateId !== webstrateId) return;

			resolve(iframe);
			return;
		});
	});
};

exports.pull = (pullFrom, pullClass, pullVersion) => {
	
	// The head of the prototype is the webstrate without versionOrTag path
	let versionOrTag = pullVersion;
	if (versionOrTag === "HEAD") {
		versionOrTag = null;
	}
	
	let systemSectionQuerySelector = '.section[data-type="system"]';
	let pullQuerySelector = systemSectionQuerySelector;
	if (pullClass !== "") {
		pullQuerySelector += `.${pullClass}`;
	}

	// Assemble prototype url.
	const url = versionOrTag ? `/${pullFrom}/${versionOrTag}/` : `/${pullFrom}/`;

	loadPrototype(`${url}?exec=no`).then((iframe) => {
		
		const frameWindow = iframe.contentWindow;
		const frameDocument = frameWindow.document;
		
		webstrate.tag(`Tag of version ${webstrate.version} before update to ${url} version ${pullVersion}`);

		let oldSections = Array.from(document.querySelectorAll(pullQuerySelector));
		let newSections = Array.from(frameDocument.querySelectorAll(pullQuerySelector));
		
		let lastSectionInserted;
		
		// Replace old sections with new sections
		oldSections.forEach(oldSection => {
			
			// Replace new section with an old section as long as there are new sections
			// left. Otherwise, remove remaining old sections.
			if (newSections.length > 0) {
				// Create a clone of section!!!
				let section = newSections.splice(0, 1)[0];
				let newSection = section.cloneNode(true);
				oldSection.replaceWith(newSection);
				lastSectionInserted = newSection;
			}
			else {
				oldSection.remove();
			}
		});

		// Append all remaining new sections
		newSections.forEach(section => {
			
			// Create a clone of section!!!
			let newSection = section.cloneNode(true);
			
			// If no section was inserted then find the last system section in the document
			// to append the remaining new sections
			if (!lastSectionInserted) {
				let systemSections = document.querySelectorAll(systemSectionQuerySelector);
				if (systemSections.length > 0) {
					lastSectionInserted = systemSections[systemSections.length - 1];
				}
				else {
					lastSectionInserted = document.body.firstElementChild;
				}
			}
			
			let parentElement = lastSectionInserted.parentElement;
			parentElement.insertBefore(newSection, lastSectionInserted.nextSibling);
			lastSectionInserted = newSection;
		});

		// Force webstrate to reload after all DOM mutations happened and sharedb
		// synchronized changes to the server. The double setTimeout makes sure to put the
		// location.reload after sharedb did its magic.
		alert("The codestrate will reload in 5 seconds", "Syncing to server");
		setTimeout(() => {
			setTimeout(() => {
				location.reload();
			}, 2500)
		}, 2500);
	});

	// 	const systems = Array.from(document.querySelectorAll('.section[data-type="system"]'));	
};</PRE></DIV><DIV class="paragraph code-paragraph collapsed" run-on-load="true" last-execution-state="success" name="Pull System Sections Dialog" __wid="oNbXUoCp"><PRE data-type="content" type="text/javascript" __wid="SLThAiqK">Codestrate.showPullSystemSectionsDialog = () => {

	return new Promise((resolve, reject) => {

		const transient = document.createElement("transient");

		const elements = require('#dialog-template', {
			title: "Codestrate Tags",
			message: `&lt;div>From what codestrate do you want to pull from?&lt;/div>
&lt;input class="pull-from" value="Codestrate">
&lt;div>What sections (class) do you want to pull? (Leave empty for all system sections)&lt;/div>
&lt;input class="pull-class" value="">
&lt;div>From what version do you want to pull from?&lt;/div>
&lt;input class="pull-version" value="HEAD">`,
			actions: `&lt;div class="button pull">Pull&lt;/div>
&lt;div class="button cancel">Cancel&lt;/div>`
		});

		elements.forEach(e => transient.appendChild(e));

		const pullBtn = transient.querySelector('.pull');
		const cancelBtn = transient.querySelector('.cancel');
		const pullFromInput = transient.querySelector('.pull-from');
		const pullClassInput = transient.querySelector('.pull-class');
		const pullVersionInput = transient.querySelector('.pull-version');

		const tagElements = Array.from(transient.querySelectorAll('.tag'));
		tagElements.forEach(element => {
			element.addEventListener("click", e => {
				const tag = element.getAttribute("data-tag");
				webstrate.restore(tag);
				window.location.reload();
			});
		});
		
		const pull = () => {
			
			const pullFrom = pullFromInput.value;
			const pullClass = pullClassInput.value;
			const pullVersion = pullVersionInput.value;
			
			transient.remove();
			
			resolve({
				pullFrom,
				pullClass,
				pullVersion
			});
		}

		const cancel = () => {
			transient.remove();
			resolve(false);
		}

		pullBtn.addEventListener("click", pull);
		cancelBtn.addEventListener("click", cancel);
		
		const inputEventHandler = (e) => {
			e.stopPropagation();

			if (e.keyCode === 13) {
				e.preventDefault();
				pull();
			}
			else if (e.keyCode === 27) {
				e.preventDefault();
				cancel();
			}
		};

		pullFromInput.addEventListener("keydown", inputEventHandler);
		pullClassInput.addEventListener("keydown", inputEventHandler);
		pullVersionInput.addEventListener("keydown", inputEventHandler);

		document.body.appendChild(transient);

		pullFromInput.focus();
	});
};</PRE></DIV></DIV><DIV class="section section-hidden" name="Drawing (experimental)" data-type="system" __wid="GKgl5dmS"><DIV class="paragraph code-paragraph" last-execution-state="success" name="Drawing Main Code" draggable="false" __wid="udhfb5pv"><PRE data-type="content" type="text/javascript" __wid="aqL2WYSf">const enableDrawing = drawable => {
// 	console.log(drawable);

	let penColor = "white";
	let ctx;
	
	const begin = point => {
		const DrawingUtil = require('#drawing-util');
		ctx = DrawingUtil.begin(drawable, penColor);
		ctx.addPoint(point);
	};
	
	const move = point => {
		ctx.addPoint(point);
	}
	
	const end = point => {
		// empty
	}
	
	const MouseHandler = require('#drawing-mouse-handler');
	MouseHandler.enable(drawable, {
		begin,
		move,
		end
	});
	
	const ApplePenHandler = require('#drawing-apple-pen-handler');
	ApplePenHandler.enable(drawable, {
		begin,
		move,
		end
	});
};

document.liveQuerySelectorAll('.drawable').added(enableDrawing);</PRE></DIV><DIV class="paragraph code-paragraph" name="Drawing Event Utils" draggable="false" __wid="4QLQUyKO"><PRE data-type="content" type="text/javascript" id="event-util" __wid="3uWVRzu5">exports.getCoordinate = (target, event) => {

	const rect = target.getBoundingClientRect();

	return {
		x: Math.floor(event.clientX - rect.left),
		y: Math.floor(event.clientY - rect.top)
	};
};</PRE></DIV><DIV class="paragraph code-paragraph" draggable="false" __wid="jpGZcc4P"><PRE data-type="content" type="text/javascript" id="drawing-util" __wid="MzKdIJOh">const ns = "http://www.w3.org/2000/svg";

const getDrawingCanvas = drawable => {
	let svg = drawable.querySelector(':scope > svg.drawing-canvas');

	if (!svg) {
		svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
		svg.setAttribute("xmlns", "http://www.w3.org/2000/svg");
		svg.setAttribute("xlink", "http://www.w3.org/1999/xlink");
		svg.setAttribute("xmlns:xlink", "");
		svg.setAttribute("class", "drawing-canvas")

		drawable.insertBefore(svg, drawable.firstElementChild);
	}

	return svg;
};

/**
 * Calculates the mid-point between the two points A and B and then returns
 * the mid-point.
 *
 * @param {any} pointA The point A.
 * @param {any} pointB The point B.
 * @returns The mid-point between point A and point B.
 */
const midPointBetween = (pointA, pointB) => {
	return {
		x: pointA.x + (pointB.x - pointA.x) / 2,
		y: pointA.y + (pointB.y - pointA.y) / 2
	};
}

/**
 * Generates a path with regard to thickness of each point in path. This
 * implementation was done by @clemens.
 *
 * @param {any} points Path points with x- and y-position and a thickness per
 * point.
 * @returns The path as string.
 */
const generatePath = (points) => {

	const newPoints = [];
	newPoints.push(points[0]);

	for (let j = 1; j &lt; points.length - 1; j++) {
		let p1 = points[j - 1];
		let p = points[j];
		let p2 = points[j + 1];
		let c = {
			x: p2.x - p1.x,
			y: p2.y - p1.y
		};
		let n = {
			x: -c.y,
			y: c.x
		};
		let len = Math.sqrt(n.x * n.x + n.y * n.y);
		if (len == 0) continue;
		let u = {
			x: n.x / len,
			y: n.y / len
		};

		newPoints.push({
			x: p.x + u.x * p.thickness,
			y: p.y + u.y * p.thickness
		});
	}
	newPoints.push(points[points.length - 1]);

	for (let j = points.length - 2; j > 0; j--) {
		let p1 = points[j + 1];
		let p = points[j];
		let p2 = points[j - 1];
		let c = {
			x: p2.x - p1.x,
			y: p2.y - p1.y
		};
		let n = {
			x: -c.y,
			y: c.x
		};
		let len = Math.sqrt(n.x * n.x + n.y * n.y);
		if (len == 0) continue;
		let u = {
			x: n.x / len,
			y: n.y / len
		};

		newPoints.push({
			x: p.x + u.x * p.thickness,
			y: p.y + u.y * p.thickness
		});
	}
	let p1 = newPoints[0];
	let p2 = newPoints[1];
	let pathString = "M" + p1.x + " " + p1.y;
	for (let j = 1; j &lt; newPoints.length; j++) {
		let midPoint = midPointBetween(p1, p2);
		if (isNaN(p1.x) || isNaN(p1.y) || isNaN(midPoint.x) || isNaN(midPoint.y)) {
			console.log("NaN");
		}
		pathString = pathString += " Q " + p1.x + " " + p1.y + " " + midPoint.x + " " + midPoint.y;
		p1 = newPoints[j];
		p2 = newPoints[j + 1];
	}

	return pathString;
}

exports.begin = (drawable, penColor = "black") => {
	const path = document.createElementNS(ns, "path");
	path.setAttribute("fill", penColor);
	
	const points = [];
	const addPoint = point => {
		points.push(point);
		path.setAttribute("d", generatePath(points));		
	}
	
	const svg = getDrawingCanvas(drawable);
	svg.appendChild(path);
	
	return {
		addPoint
	};
}</PRE></DIV><DIV class="paragraph code-paragraph" draggable="false" __wid="jJiYFMa8"><PRE data-type="content" type="text/javascript" id="drawing-mouse-handler" __wid="Nvb7mxV9">exports.enable = (drawable, events) => {

	let isDrawing = false;

	const { begin, move, end } = events;

	const getPoint = event => {
		const EventUtil = require('#event-util');
		const coords = EventUtil.getCoordinate(drawable, event);

		return {
			x: coords.x,
			y: coords.y,
			thickness: 3
		};
	};

	const consumeEvent = event => {
		event.preventDefault();
		event.stopPropagation();
		event.stopImmediatePropagation();
	};

	drawable.addEventListener("mousedown", event => {
		// 		console.log('ctrl', event.ctrlKey);
		if (!event.ctrlKey) return;

		consumeEvent(event);

		isDrawing = true;
		begin(getPoint(event));
	});

	drawable.addEventListener("mousemove", event => {
		if (!isDrawing) return;
		consumeEvent(event);
		move(getPoint(event));
	});

	drawable.addEventListener("mouseup", event => {
		end(getPoint(event));
		consumeEvent(event);
		isDrawing = false;
	});

	drawable.addEventListener("mouseleave", event => {
		end(getPoint(event));
		consumeEvent(event);
		isDrawing = false;
	});

	drawable.addEventListener('contextmenu', event => {
		if (event.ctrlKey) {
			event.preventDefault();
		}
	});
};</PRE></DIV><DIV class="paragraph code-paragraph" draggable="false" __wid="uCvwG5JR"><PRE data-type="content" type="text/javascript" id="drawing-apple-pen-handler" __wid="zXfTdFG0">exports.enable = (drawable, events) => {

	const { begin, move, end } = events;
	
	/**
   * Checks if the event is a valid pen event.
   */
	const isValidTouchPenEvent = (event) => {
		// PROBLEM: Currently, Safari does not implement an API that supports distinguishing
		// Apple Pen from 3D Touch in Safari. 
		// WORKAROUND: Because force touch is messing up on the "force touch" enabled
		// devices, we check to make sure that it won't draw like a pen on force.   
		var isiPad = true;// didn't work: navigator.userAgent.match(/iPad/i) != null;
		
// 		return isDrawingMode ||
// 		(
// 			event.touches &&
// 			event.touches.length === 1 &&
// 			event.touches[0].force &&
// 			event.touches[0].force > 0
// 		) && isiPad;
		
		return (
					!!event.touches &&
					event.touches.length === 1 &&
					!!event.touches[0].force &&
					event.touches[0].force > 0
		);
	};

	/**
   * Get a pen object containing proper x- and y-coordinates and force if
   * available.
   */
	const getPoint = (event) => {

		let touch = event;
		if (event.touches) {
			touch = event.touches[0];
		}

		const EventUtil = require('#event-util');
		const coords = EventUtil.getCoordinate(drawable, touch);

		return {
			x: coords.x,
			y: coords.y,
			thickness: (touch.force || touch.pressure || 1) * 3
		};
	};
	
	const consumeEvent = event => {
		event.preventDefault();
	};

	drawable.addEventListener("touchstart", event => {
		if (!isValidTouchPenEvent(event)) return;
		consumeEvent(event);
		begin(getPoint(event));
	});

	drawable.addEventListener("touchmove", event => {
		if (!isValidTouchPenEvent(event)) return;
		consumeEvent(event);
		move(getPoint(event));
	});

	drawable.addEventListener("touchend", event => {
		if (!isValidTouchPenEvent(event)) return;
		consumeEvent(event);
		end(getPoint(event));
	});
};</PRE></DIV><DIV class="paragraph style-paragraph" draggable="false" __wid="MU8m1nUM"><STYLE data-type="content" type="text/css" codemirror="true" __wid="ki_mfYuq">.drawable {
	position: relative;
	/*   background-color: orange; */
	overflow: hidden;
}

.drawable img {
	display: block;  
}

.darkroom-container img {
	display: inline !important;
}

svg.drawing-canvas {
	/*   background-color: #f00; */
	/*   opacity: .5; */
	position: absolute;
	top: 0;
	left: 0;
	bottom: 0;
	right: 0;
	border: 0;
	padding: 0;
	margin: 0;
	box-sizing: border-box;
	width: 100%;
	height: 100%;
	pointer-events: none;
}</STYLE></DIV></DIV><DIV name="Shared Pointers (experimental)" class="section section-hidden" data-type="system" __wid="_Zvw1f2q"><DIV class="paragraph code-paragraph collapsed" name="Shared Pointers Code" run-on-load="true" last-execution-state="success" __wid="kjAtYFS7"><PRE data-type="content" type="text/javascript" __wid="b12TiEHb">const UserManager = require('#user-manager');

var clients = {};

const adjustCoords = (x, y) => {
	
	const rect = document.body.getBoundingClientRect();
	const elemAtPoint = document.elementFromPoint(window.innerWidth/2, y-document.body.scrollTop);
	const paragraphAtCursor = elemAtPoint ? elemAtPoint.closest(".paragraph") : null;

	let paraX = 0;
	let paraY = 0;
	let paraId = null;
	
	if (paragraphAtCursor !== null) {
		paraId = paragraphAtCursor.webstrate.id;
		let paraRect = paragraphAtCursor.getBoundingClientRect();
		paraX = x - paraRect.left;
		paraY = y - paraRect.top - document.body.scrollTop;
	}
	
	return {
		paraId: paraId,
		paraX: paraX,
		paraY: paraY,
		x: x - rect.left,
		y: y
	};
};

document.addEventListener("mousedown", function(e) {
	const pos = adjustCoords(e.pageX, e.pageY);
  throttledSignal({cmd: "click", data: pos});
});

document.addEventListener("touchstart", function(e) {
	if (e.touches.length > 0) {
		const touch = e.touches[0];
		const pos = adjustCoords(touch.pageX, touch.pageY);		
		throttledSignal({cmd: "click", data: pos});
	}
});

document.addEventListener("mousemove", function(e) {
	const pos = adjustCoords(e.pageX, e.pageY);
  throttledSignal({cmd: "pos", data: pos});
});

document.addEventListener("touchmove", function(e) {
	if (e.touches.length > 0) {
		const touch = e.touches[0];
		const pos = adjustCoords(touch.pageX, touch.pageY);		
		throttledSignal({cmd: "pos", data: pos});
	}
});

document.body.webstrate.on("signal", function(msg, clientId) {
  if (clientId == window.webstrate.clientId) return;
  if (msg.cmd === undefined) return;
  else if (msg.cmd === "pos") {
		
    if (clients[clientId] === undefined) return;

		
		const remoteCursorPostion = getRemoteCursorPostion(msg);
		
    clients[clientId].style.left = remoteCursorPostion.x + "px";
    clients[clientId].style.top = remoteCursorPostion.y + "px";
  }
  else if (msg.cmd === "click") {
//     console.log("clicked", msg.data, clientId);
    clicked(msg, clientId);
  }
});

webstrate.on("signal", (message, senderId) => {
	
	if (message.type === "IdleTimer") {
		
		if (message.cmd === "awake") {
			clientJoin(senderId);
		}
		else if (message.cmd === "idle") {
			clientPart(senderId);
		}
	}
});

webstrate.on("clientJoin", function(clientId) {
  clientJoin(clientId);
});

webstrate.on("clientPart", function(clientId) {
  clientPart(clientId);
});

function clientJoin(clientId) {
	// Ignore own cursor
	if (clientId === webstrate.clientId) return;
	
  clients[clientId] = createCursor(clientId);	  
}

function clientPart(clientId) {
	if (!clients.hasOwnProperty(clientId)) return;
  clients[clientId].parentElement.removeChild(clients[clientId]);
  delete clients[clientId];
}

function createCursor(clientId) {
  var cursor = document.createElement("transient");
  cursor.classList.add("remote-cursor");
  cursor.style.borderColor = UserManager.getUserColor(clientId);
  cursor.setAttribute("data-client-id", clientId);
  document.body.appendChild(cursor);
//   console.log(cursor);
  return cursor;
}

function clicked(msg, clientId) {
	
	//const rect = document.body.getBoundingClientRect();
	//const x = msg.data.x;// + rect.left;
	//const y = msg.data.y; // + rect.top;
  
	const remoteCursorPostion = getRemoteCursorPostion(msg);
	
  const click = document.createElement("transient");
  click.classList.add("remote-click");
  click.style.left = remoteCursorPostion.x + "px";
  click.style.top = remoteCursorPostion.y + "px";
  click.style.borderColor = clients[clientId].style.borderColor;
  click.addEventListener("transitionend", function(event) {
    if (event.propertyName === "transform") {
      click.remove();
    }
  });
  document.body.appendChild(click);
  
  // Add animation with timeout to make it actually animate
  setTimeout(() => {
    click.classList.add("animate");
  }, 10);
  
  setTimeout(() => {
    click.remove();
  }, 200);
}

function getRemoteCursorPostion(msg) {
		let x = msg.data.x;
		let y = msg.data.y;
		if (msg.paraId !== null) {
			let paragraphs = document.querySelectorAll(".paragraph");
			let paragraph = null;
			for (var i = 0; i &lt; paragraphs.length; i++) {
					if (paragraphs[i].webstrate.id === msg.data.paraId) {
						paragraph = paragraphs[i];
						break;
					}
			}
			
			if (paragraph !== null) {	
				let paraRect = paragraph.getBoundingClientRect();
				let bodyRect = document.body.getBoundingClientRect();
				x = msg.data.paraX + paraRect.left - bodyRect.left;
				y = msg.data.paraY + paraRect.top - bodyRect.top;
			}
		}
	
		return {x: x, y: y};
}

var count = 0;
function signal(msg, clientId) {
  if (clientId) document.body.webstrate.signal(msg, clientId);  
  else document.body.webstrate.signal(msg);
}

const throttledSignal = throttleFn(signal, 100);

function throttleFn(fn, limit) {
	var timeout;
	var lastCall = 0;
	return function(...args) {
		var now = Date.now();
		var delay = lastCall + limit - now;
		if (delay &lt;= 0) {
			fn(...args);	
			lastCall = now;
		} else {
			clearTimeout(timeout);
			timeout = setTimeout(function() {
				fn(...args);
				lastCall = now;
			}, delay);
		}
	};
};

/*
for (var i = 0; i&lt;webstrate.clients.length; i++) {
  if (webstrate.clients[i] == webstrate.clientId) continue;
  clientJoin(webstrate.clients[i]); 
}*/
webstrate.clients.forEach(clientJoin);</PRE></DIV><DIV class="paragraph style-paragraph collapsed" name="Shared Pointers Style" __wid="d2rxwIxT"><STYLE data-type="content" type="text/css" codemirror="true" __wid="kh3yKJaS">.remote-cursor {
  position: absolute;
	
	/* Set the cursor offscreen initially. If top is not set then cursor will be appended like regular position: initial */
	top: -100px;
	
  z-index: 999;
  width: 12px;
  height: 12px;
  background-color: transparent;
  border-left: 4px solid;
  border-top: 4px solid;
  box-sizing: border-box;
	pointer-events: none;
/* 	transition: top 1ms, left 1ms;*/
/*   transform: translate3d(20px, -0px, 0); */
	transition: all 0.05s ease 0s;
}

.remote-click {
  position: absolute;
  z-index: 998;
  width: 50px;
  height: 50px;
/*   background-color: orange; */
  transform: translate3d(-25px, -25px, 0) scale(0);
  transition: transform 150ms ease-in-out, opacity 150ms ease-in;
  border-radius: 50%;
  border: 4px solid orange;
  pointer-events: none;
	filter: blur(2px);
	opacity: 1.0;
}

.remote-click.animate {
/*   width: 50px;
  height: 50px; */
  transform: translate3d(-25px, -25px, 0) scale(1.0);
	opacity: 0;
}</STYLE></DIV></DIV><DIV name="Allow iframe Fullscreen (experimental)" class="section section-hidden" data-type="system" __wid="07Gv4nDA"><DIV class="paragraph code-paragraph collapsed" last-execution-state="success" name="Allow iframe Fullscreen Code" draggable="false" __wid="92xV5oEa"><PRE data-type="content" type="text/javascript" __wid="hnYs9OVQ">importLib([
  "mousetrap.min.js",
  "mousetrap-global-bind.min.js"
]).then(() => {

  const makeAllowFullscreen = iframe => {

    const transientStyle = document.createElement("transient");
    
    const materialStyle = document.createElement("link");
    materialStyle.setAttribute("rel", "stylesheet");
    materialStyle.setAttribute("href", "/stdlib/material-icons.css");
    transientStyle.appendChild(materialStyle);
    
    const style = document.createElement("style");
    transientStyle.appendChild(style);

    const updateStyle = () => {
      const icon = iframe.classList.contains("fullscreen") ? "fullscreen_exit" : "fullscreen";
      
      style.innerHTML = require('#allow-fullscreen-style', { icon });
    }

    iframe.webstrate.on("transcluded", (webstrateId) => {

      if (webstrateId !== iframe.contentWindow.webstrate.webstrateId) return;

      updateStyle();
      
      iframe.contentWindow.document.head.appendChild(transientStyle);

      // Add fullscreen button
      const toggleFullscreen = document.createElement("transient");
      toggleFullscreen.innerHTML = `&lt;i class="material-icons">&lt;/i>`;
      toggleFullscreen.setAttribute("class", "go-to-fullscreen");
      toggleFullscreen.addEventListener("click", event => {
        iframe.classList.toggle("fullscreen");
        updateStyle();
      });

      iframe.contentWindow.document.body.appendChild(toggleFullscreen);

      iframe.contentWindow.addEventListener("keydown", event => {
        if (event.ctrlKey && event.keyCode === 70) {
          iframe.classList.toggle("fullscreen");
        }
      }, true);
    });
  };

  document.liveQuerySelectorAll('.paragraph.body-paragraph iframe.allow-fullscreen').added(makeAllowFullscreen);
});</PRE></DIV><DIV class="paragraph style-paragraph collapsed" name="Allow iframe Fullscreen Style" draggable="false" __wid="7pWW4dnX"><STYLE data-type="content" type="text/css" codemirror="true" __wid="2i9q2ORQ">/* .paragraph.body-paragraph {
  overflow: hidden;
}

.paragraph.body-paragraph iframe.allow-fullscreen {
  border: 0;
  overflow: hidden;
  background-color: white;
  width: 100%;
  min-width: 100%;
  height: 500px;
  min-height: 500px;
  max-height: 500px;
}

.paragraph.body-paragraph iframe.allow-fullscreen.fullscreen {
  position: fixed;
  top: 0;
  left: 0;
  bottom: 0;
  right: 0;
  width: 100vw;
  height: 100vh;
  max-height: 100vh;
  z-index: 99;
} */</STYLE></DIV><DIV class="paragraph style-paragraph collapsed" name="Allow iframe Fullscreen (iframe Style)" draggable="false" __wid="wVfSUFQn"><STYLE data-type="content" type="text/css" codemirror="true" id="allow-fullscreen-style" __wid="QKgOTfrb">/* .go-to-fullscreen {
  background-color: white;
  position: fixed;
  top: 10px;
  right: 10px;
  z-index: 999;
  cursor: pointer;
}

.go-to-fullscreen:hover i:before {
  color: orange;
}

.go-to-fullscreen i:before {
  content: "${icon}";
} */</STYLE></DIV></DIV><DIV name="CodeMirror" class="section section-hidden" data-type="system" __wid="XSVNcU58"><DIV class="paragraph body-paragraph" draggable="false" __wid="n99XZxLD"><DIV data-type="content" contenteditable="true" class="hide-variable-names" __wid="GErg3Lcz">CodeMirror integration, touching the code below should be done with <I __wid="mJpCF2Go">serious</I>care :-D<DIV __wid="183_y38i"><BR __wid="-9wxonQt"/></DIV><DIV __wid="dgS29bFE">Using CodeMirror version<DIV class="variable" contenteditable="false" data-name="version" __wid="lA0cnQvL"></DIV><SPAN style="font-size: 11pt;" __wid="jPv0qYAQ">.</SPAN></DIV><DIV __wid="2s5GmIwQ"><SPAN style="font-size: 11pt;" __wid="yEvjtsyB"><BR __wid="UjZXYL7W"/></SPAN></DIV><DIV __wid="j82o-3ke"><SPAN style="font-size: 11pt;" __wid="uHEJQBg2">Modes<DIV class="variable" contenteditable="false" data-name="modes" __wid="dES2DPxZ"></DIV></SPAN></DIV></DIV></DIV><DIV class="paragraph code-paragraph collapsed" name="CodeMirror integration code" run-on-load="true" last-execution-state="success" __wid="7jnEBFQl"><PRE data-type="content" type="text/javascript" __wid="ekcPZOgK">// Import CodeMirror basics style.
importStyle([
	"codemirror.css",
  "codemirror-addon-show-hint.css",
  "codemirror-addon-foldgutter.css"
]);

importLib([
  "codemirror.js",

  "codemirror-addon-show-hint.js",
  "codemirror-addon-javascript-hint.js",
  "codemirror-addon-xml-hint.js",
  "codemirror-addon-html-hint.js",
  "codemirror-addon-css-hint.js",
  "codemirror-addon-anyword-hint.js",
  
  "codemirror-addon-comment.js",
  "codemirror-addon-continuecomment.js",

  "codemirror-addon-foldcode.js",
  "codemirror-addon-foldgutter.js",
  "codemirror-addon-brace-fold.js",
  "codemirror-addon-xml-fold.js",
  "codemirror-addon-markdown-fold.js",
  "codemirror-addon-comment-fold.js",
  "codemirror-addon-indent-fold.js",
  
  "codemirror-addon-matchbrackets.js",
  "codemirror-addon-matchtags.js",
  "codemirror-addon-closebrackets.js",
  "codemirror-addon-closetag.js",
  
  "codemirror-mode-xml.js",
  "codemirror-mode-htmlmixed.js",
  "codemirror-mode-javascript.js",
  "codemirror-mode-css.js",
	
	"beautify-html.js"
]).then(() => {

  // Print CodeMirror version.
  Variable("version").set(`&lt;transient>${CodeMirror.version}&lt;/transient>`);
  
  // Print installed CodeMirror modes.
  Variable("modes").set(`&lt;transient>&lt;ul>${Object.keys(CodeMirror.modes).map(v => { return `&lt;li>${v}&lt;/li>` }).join('\r\n')}&lt;/ul>&lt;/transient>`);

	const UserManager = require('#user-manager');

  /**
   * Base class for editors.
   */
  class Editor {

    constructor(target, editorOptions) {
      
      const contenteditable = target.getAttribute("contenteditable");
      let readOnly = contenteditable && contenteditable === "false" ? true : false;

      // Allow custom editor options.
      this.editorOptions = Object.assign({
        mode: "text/javascript",
        matchBrackets: true,
        theme: "monokai",
        indentUnit: 2,
        tabSize: 2,
        indentWithTabs: true,
        lineWrapping: true,
        lineNumbers: true,
        extraKeys: {},
        readOnly: readOnly
      }, editorOptions);
      
      target.liveAttribute("contenteditable").changed(value => {
        let readOnly = value && value === "false" ? true : false;
//         window.console.log(value, this.editor);
        this.readOnly = readOnly;
      });
    }
    
    set readOnly(readOnly) {
      if (this.editor) {
        this.editor.setOption("readOnly", readOnly);
      }
    }
    
    get readOnly() {
      if (this.editor) {
        return this.editor.getOption("readOnly");
      }
      throw new Error("editor not initialized");
    }
  }

  /**
   * HTML editor synchronizing content between contenteditable element and
   * a CodeMirror instance.
   */
  class HtmlEditor extends Editor {

    constructor(target, editorOptions) {

      super(target, Object.assign({
        mode: "htmlmixed"
      }, editorOptions));

      //window.console.log('html editor');

      const parent = target.parentElement;

      const transient = document.createElement("transient");
      transient.setAttribute("class", "html-editor hidden");

      const textArea = document.createElement("textarea");
      transient.appendChild(textArea);
      
      // Insert code editor before console
      if (parent.console && parent.console.container) {
        const consoleContainer = parent.console.container;
        parent.insertBefore(transient, consoleContainer);
      }
      else {
        parent.appendChild(transient);
      }

      this.editor = CodeMirror.fromTextArea(textArea, this.editorOptions);

      const updateEditor = () => {
        let html = target.innerHTML;
        this.editor.setValue(html);
        setTimeout(() => {
          this.editor.refresh();
        }, 0);
      }

			let observer;
			const enableMutationObserver = () => {
				
				// Only allow one observer
				if (observer) return;
				
				// Listen to any updates that happen inside of the target element and update
				// the CodeMirror instance accordingly. For now, any update will override 
				// contents of the CodeMirror and transient changes get lost.
				observer = new MutationObserver(mutations => {
					updateEditor();
				});
				observer.observe(target, {
					childList: true,
					characterData: true,
					subtree: true,
					attributes: true
				});
			}
			
			const disableMutationObserver = () => {
				if (observer) {
					observer.disconnect();
					observer = null;
				}
			}
			
			const beautifyHtmlOpts = {
				indent_size: 2,
				indent_char: " ",
				indent_with_tabs: false,
				eol: "\n",
				end_with_newline: false,
				indent_level: 0,
				preserve_newlines: true,
				max_preserve_newlines: 5,
				space_in_paren: false,
				space_in_empty_paren: false,
				jslint_happy: false,
				space_after_anon_function: false,
				brace_style: "collapse",
				break_chained_methods: false,
				keep_array_indentation: false,
				unescape_strings: false,
				wrap_line_length: 0,
				e4x: false,
				comma_first: false,
				operator_position: "before-newline"
			}
			
			const beautifyHtml = (html) => {
				return html_beautify(html, beautifyHtmlOpts);
			};
      
      // Save html and persist it with Webstrates.
      const saveHtml = () => {
        const cursor = this.editor.getCursor();
        
        let html = this.editor.getValue();
        target.innerHTML = html;
        
        setTimeout(() => {
          this.editor.setCursor(cursor);
        }, 0);
      };
      
      // Update the editor on paste. This fixes a bug that occurs sometimes
      // When pasting large portions of code into the editor.
      this.editor.on("paste", () => {
				setTimeout(() => {
					this.editor.refresh();
				}, 0);
      });
			
      // A convenient save option to save html instead of showing the open
      // file dialog.
      this.editor.addKeyMap({
        "Cmd-S": cm => {
          saveHtml();
				},
				"Cmd-.": (cm) => {
					const html = cm.getValue();
					const beautifulHtml = beautifyHtml(html);
					cm.setValue(beautifulHtml);
				}
			});

      // Add actions to save html and to toggle html to paragraph header. This
      // code might move at some point to the actual active essay code.
      const ParagraphUtils = require('#paragraph-utils');
      
      ParagraphUtils.addHeaderAction(parent, "save-html", () => {
        saveHtml();
      }, {
				tooltip: true
			});

      ParagraphUtils.addHeaderAction(parent, "toggle-html", () => {
        transient.classList.toggle("hidden");
				
				// Disable and enable mutation observer
				if (transient.classList.contains("hidden")) {
					disableMutationObserver();
				}
				else {
					enableMutationObserver();
					updateEditor();
				}
      }, {
				tooltip: true
			});
    }
  }

  class DefaultEditor extends Editor {

    constructor(target, parent, editorOptions) {

      super(target, editorOptions);

      // window.console.log('default editor');

      this.suppress = false;
      this.timer = null;

      if (parent === undefined) parent = target;

      this.textNode = target.firstChild;
      
//       window.console.log(this.textNode, target);
      
      if (!this.textNode || this.textNode.nodeType !== 3) {
        console.error("First child node of target is not a text node", target);
        throw Error("First child node of target is not a text node");
      }
      const transient = document.createElement("transient");
      transient.setAttribute("class", "default-editor");

      const textArea = document.createElement("textarea");
      transient.appendChild(textArea);
      
      // Insert code editor before console
      if (parent.console && parent.console.container) {
        const consoleContainer = parent.console.container;
        parent.insertBefore(transient, consoleContainer);
      }
      else {
        parent.appendChild(transient);
      }

      this.editor = CodeMirror.fromTextArea(textArea, this.editorOptions);

      this.editor.setValue(this.textNode.textContent);
      setTimeout(() => {
        this.editor.refresh();
      }, 0);

      const insertTextCallback = (pos, val) => {
        this.editor.off("change", editorChangeCallback);
        this.editor.replaceRange(val, this.editor.posFromIndex(pos));
        this.editor.on("change", editorChangeCallback);
      }

      const deleteTextCallback = (pos, val) => {
        var from = this.editor.posFromIndex(pos);
        var to = this.editor.posFromIndex(pos + val.length);
        this.editor.off("change", editorChangeCallback);
        this.editor.replaceRange('', from, to);
        this.editor.on("change", editorChangeCallback);
      }

      const editorChangeCallback = () => {
        var newVal = this.editor.getValue();
        newVal = newVal.length == 0 ? ' ' : newVal;
        this.textNode.textContent = newVal;
      }

      this.textNode.webstrate.on("insertText", insertTextCallback);
      this.textNode.webstrate.on("deleteText", deleteTextCallback);

      this.editor.on("change", editorChangeCallback);
			
      // Update the editor on paste. This fixes a bug that occurs sometimes
      // When pasting large portions of code into the editor.
      this.editor.on("paste", () => {
				setTimeout(() => {
					this.editor.refresh();
				}, 0);
      });

      this.editor.on("cursorActivity", () => {
        var range = this.editor.doc.sel.ranges[0];
        target.webstrate.signal(range);
      });

      const markers = {};
      target.webstrate.on("signal", (sel, clientId) => {
        if (clientId === webstrate.clientId) return;
				
				if (markers[clientId]) markers[clientId].clear();
				
				const color = UserManager.getUserColor(clientId);
				const backgroundColor = UserManager.getUserColorInRGBA(clientId, .3);

        if (sel.anchor.line > sel.head.line || (sel.anchor.line == sel.head.line && sel.anchor.ch > sel.head.ch)) { // Backwards selection
          let temp = sel.anchor;
          sel.anchor = sel.head;
          sel.head = temp;
        }
        if (sel.anchor.line == sel.head.line && sel.anchor.ch == sel.head.ch) {
          var widget = document.createElement("span");
          widget.classList.add("remoteCursor");
          widget.setAttribute("style", `outline: 1px solid ${color}`);
          markers[clientId] = this.editor.doc.setBookmark(sel.anchor, { widget: widget });
        } else {
          markers[clientId] = this.editor.doc.markText(sel.anchor, sel.head, { className: "remoteSelection", css: `background-color: ${backgroundColor};` });
        }
      });

      webstrate.on("clientPart", (clientId) => {
        if (!markers[clientId]) return;
        markers[clientId].clear();
        delete markers[clientId];
      });
    }
  }

  const extraKeys = {
    "Ctrl-Space": "autocomplete",
    "Cmd-/": "toggleComment"
  };
	
	//////////
	// magic
	//////////
	
	const sectionSelector = '.section';
	const sectionHiddenClass = "section-hidden";

  const codeSelectors = [
		'pre[type]',
		'*[codemirror="true"]'
	];

  const createEditor = function (element) {
		
// 		debugger;

//     window.console.log("create editor for element %o", element);

    if (!element.__editor) {
      const codeType = element.getAttribute("type");

      let editor;
      if ((!codeType || codeType === "text/html") && element.hasAttribute("contenteditable")) {
        editor = new HtmlEditor(element, { extraKeys });
      }
      else {
        editor = new DefaultEditor(element, element.parentElement, {
          mode: codeType,
          extraKeys
        });
      }

      element.__editor = editor;
    }
  };

//   // Create code editors on initial load.
//   const createEditors = function () {
		
// 		const selector = codeSelectors.map(cs => {
// 			return `${sectionSelector}:not(.${sectionHiddenClass}) ${cs}`;
// 		}).join(",");
		
//     const pres = Array.from(document.querySelectorAll(selector));
//     pres.forEach(pre => createEditor(pre));
//   };
//   createEditors();

  const hasCodeType = (node) => {
    return node.matches(codeSelectors.join(","));
  }
	
	const isSectionVisible = (node) => {
		// Only create editor if section is visible
		const section = node.closest(sectionSelector);
// 		console.log('isSectionVisible', section, section.classList.contains(sectionHiddenClass));
		return section && !section.classList.contains(sectionHiddenClass);
	}

  const isCodeEditor = (node) => {
    return hasCodeType(node) && node.__editor;
  }

  const destroyEditor = (node) => {
    node.__editor.editor.toTextArea();
  }
	
	const magic = (node) => {
		// Continue if section is not visible
		if (!isSectionVisible(node)) return;

		if (!isCodeEditor(node) && hasCodeType(node)) {
			createEditor(node);
		}
		else {
			const subNodes = Array.from(node.querySelectorAll(codeSelectors.join(",")));
			subNodes.forEach(subNode => {

				// Continue if section is not visible
				if (!isSectionVisible(subNode)) return;

				if (!isCodeEditor(subNode) && hasCodeType(subNode)) {
					createEditor(subNode);
				}
			});
		}
	}

//   /**
//    * Check on DOM mutations and create editors for nodes that are either
//    * pre elements with a type attribute or elements that have a codemirror
//    * attribute set.
//    */
//   const observer = new MutationObserver(function (mutations) {

//     mutations.forEach(mutation => {

//       switch (mutation.type) {
//         case "childList":

//           mutation.addedNodes.forEach(node => {
//             if (node.nodeType === 1) {
// 							magic(node);
//             }
//           });
//           break;
// 				case "attributes":
// // 					magic(mutation.target);
// 					break;
// 													 }
//     });
//   });
//   observer.observe(document.body, {
// 		subtree: true,
// 		childList: true//,
// // 		attributes: true,
// // 		attributeFilter: ["class"]
// 	});
	
	document.liveQuerySelectorAll(codeSelectors.join(",")).added(code => {
// 		console.log('code', code);
		magic(code);
	});
	
	document.liveQuerySelectorAll(sectionSelector).added(section => {
// 		console.log('section', section);
		
		section.liveAttribute("class").changed(() => {
// 			console.log('section hidden? ', section.classList.contains(sectionHiddenClass));
			
			if (!section.classList.contains(sectionHiddenClass)) {
				magic(section);
			}
		});
	});
});</PRE></DIV><DIV class="paragraph style-paragraph collapsed" name="CodeMirror Monokai Theme" __wid="3fzBQLVG"><STYLE data-type="content" type="text/css" codemirror="true" __wid="X99d8ePY">/* Based on Sublime Text's Monokai theme */

.cm-s-monokai.CodeMirror { background: rgb(48, 48, 48); color: #f8f8f2 !important; }
.cm-s-monokai.CodeMirror div {}
.cm-s-monokai div.CodeMirror-selected { background: #49483E; }
.cm-s-monokai .CodeMirror-line::selection, .cm-s-monokai .CodeMirror-line > span::selection, .cm-s-monokai .CodeMirror-line > span > span::selection { background: rgba(73, 72, 62, .99); }
.cm-s-monokai .CodeMirror-line::-moz-selection, .cm-s-monokai .CodeMirror-line > span::-moz-selection, .cm-s-monokai .CodeMirror-line > span > span::-moz-selection { background: rgba(73, 72, 62, .99); }
.cm-s-monokai .CodeMirror-gutters { background: rgb(48, 48, 48); border-right: 0px; }
.cm-s-monokai .CodeMirror-guttermarker { color: white; }
.cm-s-monokai .CodeMirror-guttermarker-subtle { color: #d0d0d0; }
.cm-s-monokai .CodeMirror-linenumber { color:rgb(135, 135, 129); }
.cm-s-monokai .CodeMirror-cursor { border-left: 1px solid #f8f8f0; }

.cm-s-monokai span.cm-comment { color: rgb(135, 135, 129); }
.cm-s-monokai span.cm-atom { color: #ae81ff; }
.cm-s-monokai span.cm-number { color: #ae81ff; }

.cm-s-monokai span.cm-property, .cm-s-monokai span.cm-attribute { color: #a6e22e; }
.cm-s-monokai span.cm-keyword { color: rgb(234, 53, 134); }
.cm-s-monokai span.cm-builtin { color: #66d9ef; }
.cm-s-monokai span.cm-string { color: #e6db74; }

.cm-s-monokai span.cm-variable { color: #f8f8f2; }
.cm-s-monokai span.cm-variable-2 { color: #9effff; }
.cm-s-monokai span.cm-variable-3 { color: #66d9ef; }
.cm-s-monokai span.cm-def { color: #fd971f; }
.cm-s-monokai span.cm-bracket { color: #f8f8f2; }
.cm-s-monokai span.cm-tag { color: rgb(234, 53, 134); }
.cm-s-monokai span.cm-header { color: #ae81ff; }
.cm-s-monokai span.cm-link { color: #ae81ff; }
.cm-s-monokai span.cm-error { background: rgb(234, 53, 134); color: #f8f8f0; }

.cm-s-monokai .CodeMirror-activeline-background { background: #373831; }
.cm-s-monokai .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: white !important;
}</STYLE></DIV><DIV class="paragraph style-paragraph collapsed" name="CodeMirror integration CSS" __wid="ZxOaMAiH"><STYLE data-type="content" type="text/css" codemirror="true" __wid="vQRk92N-">.CodeMirror {
    isolation: isolate;
    height: auto;
    font-family: "Menlo", "consolas", monospace;
    font-size: 11pt;
    height: auto;
    -webkit-font-smoothing: antialiased;
		clear: both;
	
}

.paragraph.body-paragraph > transient.hidden {
  display: none;
}

.paragraph.body-paragraph transient.html-editor:before {
  content: "HTML of the above";
  display: block;
  margin-top: 20px;
  background-color: #222;
  padding: 3px;
  border-radius: 2px;
  pointer-events: none;
	clear: both;
}

/* Icon Save HTML */
.paragraph .paragraph-header .save-html i:after {
  content: "save";
}

/* Tooltip Save HTML */
.paragraph .paragraph-header .save-html:after {
  content: "Save HTML";
}

.paragraph .paragraph-header .toggle-html i:after {
  content: "visibility";
}

.paragraph .paragraph-header .toggle-html:after {
  content: "Toggle HTML Editor";
}</STYLE></DIV></DIV><DIV name="Darkroom (Image Crop) (experimental)" class="section section-hidden" data-type="system" __wid="Z9i0meho"><DIV class="paragraph code-paragraph collapsed" name="darkroom.js" run-on-load="true" last-execution-state="success" __wid="yQJJI45r"><PRE data-type="content" type="text/javascript" __wid="qqt0C5A2">importStyle("darkroom.css");

importLib([
	"fabric.js"
]).then(() => {

	(function() {
		'use strict';

		window.Darkroom = Darkroom;

		// Core object of DarkroomJS.
		// Basically it's a single object, instanciable via an element
		// (it could be a CSS selector or a DOM element), some custom options,
		// and a list of plugin objects (or none to use default ones).
		function Darkroom(element, options, plugins) {
			return this.constructor(element, options, plugins);
		}

		// Create an empty list of plugin objects, which will be filled by
		// other plugin scripts. This is the default plugin list if none is
		// specified in Darkroom'ss constructor.
		Darkroom.plugins = [];

		Darkroom.prototype = {
			// Reference to the main container element
			containerElement: null,

			// Reference to the Fabric canvas object
			canvas: null,

			// Reference to the Fabric image object
			image: null,

			// Reference to the Fabric source canvas object
			sourceCanvas: null,

			// Reference to the Fabric source image object
			sourceImage: null,

			// Track of the original image element
			originalImageElement: null,

			// Stack of transformations to apply to the image source
			transformations: [],

			// Default options
			defaults: {
				// Canvas properties (dimension, ratio, color)
				minWidth: null,
				minHeight: null,
				maxWidth: null,
				maxHeight: null,
				ratio: null,
				backgroundColor: 'transparent',

				// Plugins options
				plugins: {},

				// Post-initialisation callback
				initialize: function() { /* noop */ }
			},

			// List of the instancied plugins
			plugins: {},

			// This options are a merge between `defaults` and the options passed
			// through the constructor
			options: {},

			constructor: function(element, options, plugins) {
				this.options = Darkroom.Utils.extend(options, this.defaults);

				if (typeof element === 'string')
					element = document.querySelector(element);
				if (null === element)
					return;

				// Darkroom uuid.
				this.uuid = webstrates.util.randomString();

				var image = new Image();
				image.onload = function() {
					// Initialize the DOM/Fabric elements

					this._initializeDOM(element);
					this._initializeImage();

					// Then initialize the plugins
					this._initializePlugins(Darkroom.plugins);

					// Necessary for Webstrates
					this._hideOriginalImageWithTransientStyle(element);

					// Public method to adjust image according to the canvas
					this.refresh(function() {
						// Execute a custom callback after initialization
						this.options.initialize.bind(this).call();
					}.bind(this));

				}.bind(this)

				//image.crossOrigin = 'anonymous';
				image.src = element.src;
			},

			selfDestroy: function() {
				var container = this.containerElement;
				container.remove();

				this.originalImageElement.classList.remove(`darkroom-image-${this.uuid}`);
				this.transientStyle.remove();
			},

			// Add ability to attach event listener on the core object.
			// It uses the canvas element to process events.
			addEventListener: function(eventName, callback) {
				var el = this.canvas.getElement();
				if (el.addEventListener){
					el.addEventListener(eventName, callback);
				} else if (el.attachEvent) {
					el.attachEvent('on' + eventName, callback);
				}
			},

			dispatchEvent: function(eventName) {
				// Use the old way of creating event to be IE compatible
				// See https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Creating_and_triggering_events
				var event = document.createEvent('Event');
				event.initEvent(eventName, true, true);

				this.canvas.getElement().dispatchEvent(event);
			},

			// Adjust image & canvas dimension according to min/max width/height
			// and ratio specified in the options.
			// This method should be called after each image transformation.
			refresh: function(next) {
				var clone = new Image();
				clone.onload = function() {
					this._replaceCurrentImage(new fabric.Image(clone));

					if (next) next();
				}.bind(this);
				clone.src = this.sourceImage.toDataURL();
			},

			_replaceCurrentImage: function(newImage) {
				if (this.image) {
					this.image.remove();
				}

				this.image = newImage;
				this.image.selectable = false;

				// Adjust width or height according to specified ratio
				var viewport = Darkroom.Utils.computeImageViewPort(this.image);
				var canvasWidth = viewport.width;
				var canvasHeight = viewport.height;

				if (null !== this.options.ratio) {
					var canvasRatio = +this.options.ratio;
					var currentRatio = canvasWidth / canvasHeight;

					if (currentRatio > canvasRatio) {
						canvasHeight = canvasWidth / canvasRatio;
					} else if (currentRatio &lt; canvasRatio) {
						canvasWidth = canvasHeight * canvasRatio;
					}
				}

				// Then scale the image to fit into dimension limits
				var scaleMin = 1;
				var scaleMax = 1;
				var scaleX = 1;
				var scaleY = 1;

				if (null !== this.options.maxWidth && this.options.maxWidth &lt; canvasWidth) {
					scaleX =  this.options.maxWidth / canvasWidth;
				}
				if (null !== this.options.maxHeight && this.options.maxHeight &lt; canvasHeight) {
					scaleY =  this.options.maxHeight / canvasHeight;
				}
				scaleMin = Math.min(scaleX, scaleY);

				scaleX = 1;
				scaleY = 1;
				if (null !== this.options.minWidth && this.options.minWidth > canvasWidth) {
					scaleX =  this.options.minWidth / canvasWidth;
				}
				if (null !== this.options.minHeight && this.options.minHeight > canvasHeight) {
					scaleY =  this.options.minHeight / canvasHeight;
				}
				scaleMax = Math.max(scaleX, scaleY);

				var scale = scaleMax * scaleMin; // one should be equals to 1

				canvasWidth *= scale;
				canvasHeight *= scale;

				// Finally place the image in the center of the canvas
				this.image.setScaleX(1 * scale);
				this.image.setScaleY(1 * scale);
				this.canvas.add(this.image);
				this.canvas.setWidth(canvasWidth);
				this.canvas.setHeight(canvasHeight);
				this.canvas.centerObject(this.image);
				this.image.setCoords();
			},

			// Apply the transformation on the current image and save it in the
			// transformations stack (in order to reconstitute the previous states
			// of the image).
			applyTransformation: function(transformation) {
				this.transformations.push(transformation);

				transformation.applyTransformation(
					this.sourceCanvas,
					this.sourceImage,
					this._postTransformation.bind(this)
				);
			},

			_postTransformation: function(newImage) {
				if (newImage)
					this.sourceImage = newImage;

				this.refresh(function() {
					this.dispatchEvent('core:transformation');
				}.bind(this));
			},

			// Initialize image from original element plus re-apply every
			// transformations.
			reinitializeImage: function() {
				this.sourceImage.remove();
				this._initializeImage();
				this._popTransformation(this.transformations.slice())
			},

			_popTransformation: function(transformations) {
				if (0 === transformations.length) {
					this.dispatchEvent('core:reinitialized');
					this.refresh();
					return;
				}

				var transformation = transformations.shift();

				var next = function(newImage) {
					if (newImage) this.sourceImage = newImage;
					this._popTransformation(transformations)
				};

				transformation.applyTransformation(
					this.sourceCanvas,
					this.sourceImage,
					next.bind(this)
				);
			},

			// Create the DOM elements and instanciate the Fabric canvas.
			// The image element is replaced by a new `div` element.
			// However the original image is re-injected in order to keep a trace of it.
			_initializeDOM: function(imageElement) {

				// Container
				var mainContainerElement = document.createElement('transient');
				mainContainerElement.setAttribute("id", `darkroom-container-${this.uuid}`);
				mainContainerElement.setAttribute("tabindex", "-1");
				mainContainerElement.setAttribute("contenteditable", "false");
				//     mainContainerElement.className = 'darkroom-container';
				mainContainerElement.setAttribute("class", `darkroom-container ${imageElement.getAttribute("class")}`);

				mainContainerElement.addEventListener("keydown", event => {
					if (event.keyCode === 27) {
						this.selfDestroy();
					}
				}, true);

				// Toolbar
				var toolbarElement = document.createElement('div');
				toolbarElement.className = 'darkroom-toolbar';
				mainContainerElement.appendChild(toolbarElement);

				// Viewport canvas
				var canvasContainerElement = document.createElement('div');
				canvasContainerElement.className = 'darkroom-image-container';
				var canvasElement = document.createElement('canvas');
				canvasContainerElement.appendChild(canvasElement);
				mainContainerElement.appendChild(canvasContainerElement);

				// Source canvas
				var sourceCanvasContainerElement = document.createElement('div');
				sourceCanvasContainerElement.className = 'darkroom-source-container';
				sourceCanvasContainerElement.style.display = 'none';
				var sourceCanvasElement = document.createElement('canvas');
				sourceCanvasContainerElement.appendChild(sourceCanvasElement);
				mainContainerElement.appendChild(sourceCanvasContainerElement);

				//     // Original image
				//     imageElement.parentNode.replaceChild(mainContainerElement, imageElement);
				//     imageElement.style.display = 'none';
				//     mainContainerElement.appendChild(imageElement);

				//     imageElement.style.position = '';
				imageElement.parentNode.insertBefore(mainContainerElement, imageElement);

				mainContainerElement.focus();
				//         });

				//     mainContainerElement.setAttribute("style", `position: absolute; top: ${imageElement.offsetTop}px; left: ${imageElement.offsetLeft}px;`);

				// Instanciate object from elements
				this.containerElement = mainContainerElement;
				this.originalImageElement = imageElement;

				this.toolbar = new Darkroom.UI.Toolbar(toolbarElement);

				this.canvas = new fabric.Canvas(canvasElement, {
					selection: false,
					backgroundColor: this.options.backgroundColor
				});

				this.sourceCanvas = new fabric.Canvas(sourceCanvasElement, {
					selection: false,
					backgroundColor: this.options.backgroundColor
				});
			},

			// Instanciate the Fabric image object.
			// The image is created as a static element with no control,
			// then it is add in the Fabric canvas object.
			_initializeImage: function() {
				this.sourceImage = new fabric.Image(this.originalImageElement, {
					// Some options to make the image static
					selectable: false,
					evented: false,
					lockMovementX: true,
					lockMovementY: true,
					lockRotation: true,
					lockScalingX: true,
					lockScalingY: true,
					lockUniScaling: true,
					hasControls: false,
					hasBorders: false,
				});

				this.sourceCanvas.add(this.sourceImage);

				// Adjust width or height according to specified ratio
				var viewport = Darkroom.Utils.computeImageViewPort(this.sourceImage);
				var canvasWidth = viewport.width;
				var canvasHeight = viewport.height;

				this.sourceCanvas.setWidth(canvasWidth);
				this.sourceCanvas.setHeight(canvasHeight);
				this.sourceCanvas.centerObject(this.sourceImage);
				this.sourceImage.setCoords();
			},

			// Initialize every plugins.
			// Note that plugins are instanciated in the same order than they
			// are declared in the parameter object.
			_initializePlugins: function(plugins) {
				for (var name in plugins) {
					var plugin = plugins[name];
					var options = this.options.plugins[name];

					// Setting false into the plugin options will disable the plugin
					if (options === false)
						continue;

					// Avoid any issues with _proto_
					if (!plugins.hasOwnProperty(name))
						continue;

					this.plugins[name] = new plugin(this, options);
				}
			},

			_hideOriginalImageWithTransientStyle: function(imageElement) {

				this.transientStyle = document.createElement("transient");
				const style = document.createElement("style");

				style.innerHTML = `
#darkroom-container-${this.uuid} {
  display: inline-block;
}

img.darkroom-image-${this.uuid} {
  display: none !important;
}
`;
				
				this.transientStyle.appendChild(style);
				document.head.appendChild(this.transientStyle);
				
				imageElement.classList.add(`darkroom-image-${this.uuid}`);
			}
		}

	})();
});</PRE></DIV><DIV class="paragraph code-paragraph collapsed" name="darkroom-plugin.js" run-on-load="true" last-execution-state="success" __wid="AMCvR-Vw"><PRE data-type="content" type="text/javascript" __wid="O-8UyAR5">(function() {
'use strict';

Darkroom.Plugin = Plugin;

// Define a plugin object. This is the (abstract) parent class which
// has to be extended for each plugin.
function Plugin(darkroom, options) {
  this.darkroom = darkroom;
  this.options = Darkroom.Utils.extend(options, this.defaults);
  this.initialize();
}

Plugin.prototype = {
  defaults: {},
  initialize: function() { }
}

// Inspired by Backbone.js extend capability.
Plugin.extend = function(protoProps) {
  var parent = this;
  var child;

  if (protoProps && protoProps.hasOwnProperty('constructor')) {
    child = protoProps.constructor;
  } else {
    child = function(){ return parent.apply(this, arguments); };
  }

  Darkroom.Utils.extend(child, parent);

  var Surrogate = function(){ this.constructor = child; };
  Surrogate.prototype = parent.prototype;
  child.prototype = new Surrogate;

  if (protoProps) Darkroom.Utils.extend(child.prototype, protoProps);

  child.__super__ = parent.prototype;

  return child;
}

})();</PRE></DIV><DIV class="paragraph code-paragraph collapsed" name="darkroom-transformation.js" run-on-load="true" last-execution-state="success" __wid="WiLUelv6"><PRE data-type="content" type="text/javascript" __wid="NI0nMbiW">(function() {
'use strict';

Darkroom.Transformation = Transformation;

function Transformation(options) {
  this.options = options;
}

Transformation.prototype = {
  applyTransformation: function(image) { /* no-op */  }
}

// Inspired by Backbone.js extend capability.
Transformation.extend = function(protoProps) {
  var parent = this;
  var child;

  if (protoProps && protoProps.hasOwnProperty('constructor')) {
    child = protoProps.constructor;
  } else {
    child = function(){ return parent.apply(this, arguments); };
  }

  Darkroom.Utils.extend(child, parent);

  var Surrogate = function(){ this.constructor = child; };
  Surrogate.prototype = parent.prototype;
  child.prototype = new Surrogate;

  if (protoProps) Darkroom.Utils.extend(child.prototype, protoProps);

  child.__super__ = parent.prototype;

  return child;
}

})();</PRE></DIV><DIV class="paragraph code-paragraph collapsed" name="darkroom-ui.js" run-on-load="true" last-execution-state="success" __wid="jVupr5Zt"><PRE data-type="content" type="text/javascript" __wid="1EymgW5R">(function() {
'use strict';

Darkroom.UI = {
  Toolbar: Toolbar,
  ButtonGroup: ButtonGroup,
  Button: Button,
};

// Toolbar object.
function Toolbar(element) {
  this.element = element;
}

Toolbar.prototype = {
  createButtonGroup: function(options) {
    var buttonGroup = document.createElement('div');
    buttonGroup.className = 'darkroom-button-group';
    this.element.appendChild(buttonGroup);

    return new ButtonGroup(buttonGroup);
  }
};

// ButtonGroup object.
function ButtonGroup(element) {
  this.element = element;
}

ButtonGroup.prototype = {
  createButton: function(options) {
    var defaults = {
      image: 'help',
      type: 'default',
      group: 'default',
      hide: false,
      disabled: false
    };

    options = Darkroom.Utils.extend(options, defaults);

    var buttonElement = document.createElement('button');
    buttonElement.type = 'button';
    buttonElement.className = 'darkroom-button darkroom-button-' + options.type;
    buttonElement.innerHTML = '&lt;i class="material-icons">' + options.image + '&lt;/i>';
    this.element.appendChild(buttonElement);

    var button = new Button(buttonElement);
    button.hide(options.hide);
    button.disable(options.disabled);

    return button;
  }
}

// Button object.
function Button(element) {
  this.element = element;
}

Button.prototype = {
  addEventListener: function(eventName, listener) {
    if (this.element.addEventListener){
      this.element.addEventListener(eventName, listener);
    } else if (this.element.attachEvent) {
      this.element.attachEvent('on' + eventName, listener);
    }
  },
  removeEventListener: function(eventName, listener) {
    if (this.element.removeEventListener){
      this.element.removeEventListener(eventName, listener);
    }
  },
  active: function(value) {
    if (value)
      this.element.classList.add('darkroom-button-active');
    else
      this.element.classList.remove('darkroom-button-active');
  },
  hide: function(value) {
    if (value)
      this.element.classList.add('darkroom-button-hidden');
    else
      this.element.classList.remove('darkroom-button-hidden');
  },
  disable: function(value) {
    this.element.disabled = (value) ? true : false;
  }
};

})();</PRE></DIV><DIV class="paragraph code-paragraph collapsed" name="darkroom-utils.js" run-on-load="true" last-execution-state="success" __wid="lUdLvSCA"><PRE data-type="content" type="text/javascript" __wid="f4YwKgE6">(function() {
'use strict';

Darkroom.Utils = {
  extend: extend,
  computeImageViewPort: computeImageViewPort,
};


// Utility method to easily extend objects.
function extend(b, a) {
  var prop;
  if (b === undefined) {
    return a;
  }
  for (prop in a) {
    if (a.hasOwnProperty(prop) && b.hasOwnProperty(prop) === false) {
      b[prop] = a[prop];
    }
  }
  return b;
}

function computeImageViewPort(image) {
  return {
    height: Math.abs(image.getWidth() * (Math.sin(image.getAngle() * Math.PI/180))) + Math.abs(image.getHeight() * (Math.cos(image.getAngle() * Math.PI/180))),
    width: Math.abs(image.getHeight() * (Math.sin(image.getAngle() * Math.PI/180))) + Math.abs(image.getWidth() * (Math.cos(image.getAngle() * Math.PI/180))),
  }
}

})();</PRE></DIV><DIV class="paragraph code-paragraph collapsed" name="darkroom-plugin-crop.js" run-on-load="true" last-execution-state="success" __wid="2QAf5UOh"><PRE data-type="content" type="text/javascript" __wid="KyRdjMwa">(function() {
'use strict';

var Crop = Darkroom.Transformation.extend({
  applyTransformation: function(canvas, image, next) {
    // Snapshot the image delimited by the crop zone
    var snapshot = new Image();
    snapshot.onload = function() {
      // Validate image
      if (height &lt; 1 || width &lt; 1)
        return;

      var imgInstance = new fabric.Image(this, {
        // options to make the image static
        selectable: false,
        evented: false,
        lockMovementX: true,
        lockMovementY: true,
        lockRotation: true,
        lockScalingX: true,
        lockScalingY: true,
        lockUniScaling: true,
        hasControls: false,
        hasBorders: false
      });

      var width = this.width;
      var height = this.height;

      // Update canvas size
      canvas.setWidth(width);
      canvas.setHeight(height);

      // Add image
      image.remove();
      canvas.add(imgInstance);

      next(imgInstance);
    };

    var viewport = Darkroom.Utils.computeImageViewPort(image);
    var imageWidth = viewport.width;
    var imageHeight = viewport.height;

    var left = this.options.left * imageWidth;
    var top = this.options.top * imageHeight;
    var width = Math.min(this.options.width * imageWidth, imageWidth - left);
    var height = Math.min(this.options.height * imageHeight, imageHeight - top);

    snapshot.src = canvas.toDataURL({
      left: left,
      top: top,
      width: width,
      height: height,
    });
  }
});

var CropZone = fabric.util.createClass(fabric.Rect, {
  _render: function(ctx) {
    this.callSuper('_render', ctx);

    var canvas = ctx.canvas;
    var dashWidth = 7;

    // Set original scale
    var flipX = this.flipX ? -1 : 1;
    var flipY = this.flipY ? -1 : 1;
    var scaleX = flipX / this.scaleX;
    var scaleY = flipY / this.scaleY;

    ctx.scale(scaleX, scaleY);

    // Overlay rendering
    ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
    this._renderOverlay(ctx);

    // Set dashed borders
    if (ctx.setLineDash !== undefined)
      ctx.setLineDash([dashWidth, dashWidth]);
    else if (ctx.mozDash !== undefined)
      ctx.mozDash = [dashWidth, dashWidth];

    // First lines rendering with black
    ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
    this._renderBorders(ctx);
    this._renderGrid(ctx);

    // Re render lines in white
    ctx.lineDashOffset = dashWidth;
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
    this._renderBorders(ctx);
    this._renderGrid(ctx);

    // Reset scale
    ctx.scale(1/scaleX, 1/scaleY);
  },

  _renderOverlay: function(ctx) {
    var canvas = ctx.canvas;

    //
    //    x0    x1        x2      x3
    // y0 +------------------------+
    //    |\\\\\\\\\\\\\\\\\\\\\\\\|
    //    |\\\\\\\\\\\\\\\\\\\\\\\\|
    // y1 +------+---------+-------+
    //    |\\\\\\|         |\\\\\\\|
    //    |\\\\\\|    0    |\\\\\\\|
    //    |\\\\\\|         |\\\\\\\|
    // y2 +------+---------+-------+
    //    |\\\\\\\\\\\\\\\\\\\\\\\\|
    //    |\\\\\\\\\\\\\\\\\\\\\\\\|
    // y3 +------------------------+
    //

    var x0 = Math.ceil(-this.getWidth() / 2 - this.getLeft());
    var x1 = Math.ceil(-this.getWidth() / 2);
    var x2 = Math.ceil(this.getWidth() / 2);
    var x3 = Math.ceil(this.getWidth() / 2 + (canvas.width - this.getWidth() - this.getLeft()));

    var y0 = Math.ceil(-this.getHeight() / 2 - this.getTop());
    var y1 = Math.ceil(-this.getHeight() / 2);
    var y2 = Math.ceil(this.getHeight() / 2);
    var y3 = Math.ceil(this.getHeight() / 2 + (canvas.height - this.getHeight() - this.getTop()));

    ctx.beginPath();
    
    // Draw outer rectangle.
    // Numbers are +/-1 so that overlay edges don't get blurry.
    ctx.moveTo(x0 - 1, y0 - 1);
    ctx.lineTo(x3 + 1, y0 - 1);
    ctx.lineTo(x3 + 1, y3 + 1);
    ctx.lineTo(x0 - 1, y3 - 1);
    ctx.lineTo(x0 - 1, y0 - 1);
    ctx.closePath();

    // Draw inner rectangle.
    ctx.moveTo(x1, y1);
    ctx.lineTo(x1, y2);
    ctx.lineTo(x2, y2);
    ctx.lineTo(x2, y1);
    ctx.lineTo(x1, y1);

    ctx.closePath();
    ctx.fill();
  },

  _renderBorders: function(ctx) {
    ctx.beginPath();
    ctx.moveTo(-this.getWidth()/2, -this.getHeight()/2); // upper left
    ctx.lineTo(this.getWidth()/2, -this.getHeight()/2); // upper right
    ctx.lineTo(this.getWidth()/2, this.getHeight()/2); // down right
    ctx.lineTo(-this.getWidth()/2, this.getHeight()/2); // down left
    ctx.lineTo(-this.getWidth()/2, -this.getHeight()/2); // upper left
    ctx.stroke();
  },

  _renderGrid: function(ctx) {
    // Vertical lines
    ctx.beginPath();
    ctx.moveTo(-this.getWidth()/2 + 1/3 * this.getWidth(), -this.getHeight()/2);
    ctx.lineTo(-this.getWidth()/2 + 1/3 * this.getWidth(), this.getHeight()/2);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(-this.getWidth()/2 + 2/3 * this.getWidth(), -this.getHeight()/2);
    ctx.lineTo(-this.getWidth()/2 + 2/3 * this.getWidth(), this.getHeight()/2);
    ctx.stroke();
    // Horizontal lines
    ctx.beginPath();
    ctx.moveTo(-this.getWidth()/2, -this.getHeight()/2 + 1/3 * this.getHeight());
    ctx.lineTo(this.getWidth()/2, -this.getHeight()/2 + 1/3 * this.getHeight());
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(-this.getWidth()/2, -this.getHeight()/2 + 2/3 * this.getHeight());
    ctx.lineTo(this.getWidth()/2, -this.getHeight()/2 + 2/3 * this.getHeight());
    ctx.stroke();
  }
});

Darkroom.plugins['crop'] = Darkroom.Plugin.extend({
  // Init point
  startX: null,
  startY: null,

  // Keycrop
  isKeyCroping: false,
  isKeyLeft: false,
  isKeyUp: false,

  defaults: {
    // min crop dimension
    minHeight: 1,
    minWidth: 1,
    // ensure crop ratio
    ratio: null,
    // quick crop feature (set a key code to enable it)
    quickCropKey: false
  },

  initialize: function InitDarkroomCropPlugin() {
    var buttonGroup = this.darkroom.toolbar.createButtonGroup();

    this.cropButton = buttonGroup.createButton({
      image: 'crop'
    });
    this.okButton = buttonGroup.createButton({
      image: 'done',
      type: 'success',
      hide: true
    });
    this.cancelButton = buttonGroup.createButton({
      image: 'close',
      type: 'danger',
      hide: true
    });

    // Buttons click
    this.cropButton.addEventListener('click', this.toggleCrop.bind(this));
    this.okButton.addEventListener('click', this.cropCurrentZone.bind(this));
    this.cancelButton.addEventListener('click', this.releaseFocus.bind(this));

    // Canvas events
    this.darkroom.canvas.on('mouse:down', this.onMouseDown.bind(this));
    this.darkroom.canvas.on('mouse:move', this.onMouseMove.bind(this));
    this.darkroom.canvas.on('mouse:up', this.onMouseUp.bind(this));
    this.darkroom.canvas.on('object:moving', this.onObjectMoving.bind(this));
    this.darkroom.canvas.on('object:scaling', this.onObjectScaling.bind(this));

    fabric.util.addListener(fabric.document, 'keydown', this.onKeyDown.bind(this));
    fabric.util.addListener(fabric.document, 'keyup', this.onKeyUp.bind(this));

    this.darkroom.addEventListener('core:transformation', this.releaseFocus.bind(this));
  },

  // Avoid crop zone to go beyond the canvas edges
  onObjectMoving: function(event) {
    if (!this.hasFocus()) {
      return;
    }

    var currentObject = event.target;
    if (currentObject !== this.cropZone)
      return;

    var canvas = this.darkroom.canvas;
    var x = currentObject.getLeft(), y = currentObject.getTop();
    var w = currentObject.getWidth(), h = currentObject.getHeight();
    var maxX = canvas.getWidth() - w;
    var maxY = canvas.getHeight() - h;

    if (x &lt; 0)
      currentObject.set('left', 0);
    if (y &lt; 0)
      currentObject.set('top', 0);
    if (x > maxX)
      currentObject.set('left', maxX);
    if (y > maxY)
      currentObject.set('top', maxY);

    this.darkroom.dispatchEvent('crop:update');
  },

  // Prevent crop zone from going beyond the canvas edges (like mouseMove)
  onObjectScaling: function(event) {
    if (!this.hasFocus()) {
      return;
    }

    var preventScaling = false;
    var currentObject = event.target;
    if (currentObject !== this.cropZone)
      return;

    var canvas = this.darkroom.canvas;
    var pointer = canvas.getPointer(event.e);
    var x = pointer.x;
    var y = pointer.y;

    var minX = currentObject.getLeft();
    var minY = currentObject.getTop();
    var maxX = currentObject.getLeft() + currentObject.getWidth();
    var maxY = currentObject.getTop() + currentObject.getHeight();

    if (null !== this.options.ratio) {
      if (minX &lt; 0 || maxX > canvas.getWidth() || minY &lt; 0 || maxY > canvas.getHeight()) {
        preventScaling = true;
      }
    }

    if (minX &lt; 0 || maxX > canvas.getWidth() || preventScaling) {
      var lastScaleX = this.lastScaleX || 1;
      currentObject.setScaleX(lastScaleX);
    }
    if (minX &lt; 0) {
      currentObject.setLeft(0);
    }

    if (minY &lt; 0 || maxY > canvas.getHeight() || preventScaling) {
      var lastScaleY = this.lastScaleY || 1;
      currentObject.setScaleY(lastScaleY);
    }
    if (minY &lt; 0) {
      currentObject.setTop(0);
    }

    if (currentObject.getWidth() &lt; this.options.minWidth) {
      currentObject.scaleToWidth(this.options.minWidth);
    }
    if (currentObject.getHeight() &lt; this.options.minHeight) {
      currentObject.scaleToHeight(this.options.minHeight);
    }

    this.lastScaleX = currentObject.getScaleX();
    this.lastScaleY = currentObject.getScaleY();

    this.darkroom.dispatchEvent('crop:update');
  },

  // Init crop zone
  onMouseDown: function(event) {
    if (!this.hasFocus()) {
      return;
    }

    var canvas = this.darkroom.canvas;

    // recalculate offset, in case canvas was manipulated since last `calcOffset`
    canvas.calcOffset();
    var pointer = canvas.getPointer(event.e);
    var x = pointer.x;
    var y = pointer.y;
    var point = new fabric.Point(x, y);

    // Check if user want to scale or drag the crop zone.
    var activeObject = canvas.getActiveObject();
    if (activeObject === this.cropZone || this.cropZone.containsPoint(point)) {
      return;
    }

    canvas.discardActiveObject();
    this.cropZone.setWidth(0);
    this.cropZone.setHeight(0);
    this.cropZone.setScaleX(1);
    this.cropZone.setScaleY(1);

    this.startX = x;
    this.startY = y;
  },

  // Extend crop zone
  onMouseMove: function(event) {
    // Quick crop feature
    if (this.isKeyCroping)
      return this.onMouseMoveKeyCrop(event);

    if (null === this.startX || null === this.startY) {
      return;
    }

    var canvas = this.darkroom.canvas;
    var pointer = canvas.getPointer(event.e);
    var x = pointer.x;
    var y = pointer.y;

    this._renderCropZone(this.startX, this.startY, x, y);
  },

  onMouseMoveKeyCrop: function(event) {
    var canvas = this.darkroom.canvas;
    var zone = this.cropZone;

    var pointer = canvas.getPointer(event.e);
    var x = pointer.x;
    var y = pointer.y;

    if (!zone.left || !zone.top) {
      zone.setTop(y);
      zone.setLeft(x);
    }

    this.isKeyLeft =  x &lt; zone.left + zone.width / 2 ;
    this.isKeyUp = y &lt; zone.top + zone.height / 2 ;

    this._renderCropZone(
      Math.min(zone.left, x),
      Math.min(zone.top, y),
      Math.max(zone.left+zone.width, x),
      Math.max(zone.top+zone.height, y)
    );
  },

  // Finish crop zone
  onMouseUp: function(event) {
    if (null === this.startX || null === this.startY) {
      return;
    }

    var canvas = this.darkroom.canvas;
    this.cropZone.setCoords();
    canvas.setActiveObject(this.cropZone);
    canvas.calcOffset();

    this.startX = null;
    this.startY = null;
  },

  onKeyDown: function(event) {
    if (false === this.options.quickCropKey || event.keyCode !== this.options.quickCropKey || this.isKeyCroping)
      return;

    // Active quick crop flow
    this.isKeyCroping = true ;
    this.darkroom.canvas.discardActiveObject();
    this.cropZone.setWidth(0);
    this.cropZone.setHeight(0);
    this.cropZone.setScaleX(1);
    this.cropZone.setScaleY(1);
    this.cropZone.setTop(0);
    this.cropZone.setLeft(0);
  },

  onKeyUp: function(event) {
    if (false === this.options.quickCropKey || event.keyCode !== this.options.quickCropKey || !this.isKeyCroping)
      return;

    // Unactive quick crop flow
    this.isKeyCroping = false;
    this.startX = 1;
    this.startY = 1;
    this.onMouseUp();
  },

  selectZone: function(x, y, width, height, forceDimension) {
    if (!this.hasFocus())
      this.requireFocus();

    if (!forceDimension) {
      this._renderCropZone(x, y, x+width, y+height);
    } else {
      this.cropZone.set({
        'left': x,
        'top': y,
        'width': width,
        'height': height
      });
    }

    var canvas = this.darkroom.canvas;
    canvas.bringToFront(this.cropZone);
    this.cropZone.setCoords();
    canvas.setActiveObject(this.cropZone);
    canvas.calcOffset();

    this.darkroom.dispatchEvent('crop:update');
  },

  toggleCrop: function() {
    if (!this.hasFocus())
      this.requireFocus();
    else
      this.releaseFocus();
  },

  cropCurrentZone: function() {
    if (!this.hasFocus())
      return;

    // Avoid croping empty zone
    if (this.cropZone.width &lt; 1 && this.cropZone.height &lt; 1)
      return;

    var image = this.darkroom.image;

    // Compute crop zone dimensions
    var top = this.cropZone.getTop() - image.getTop();
    var left = this.cropZone.getLeft() - image.getLeft();
    var width = this.cropZone.getWidth();
    var height = this.cropZone.getHeight();

    // Adjust dimensions to image only
    if (top &lt; 0) {
      height += top;
      top = 0;
    }

    if (left &lt; 0) {
      width += left;
      left = 0;
    }

    // Apply crop transformation.
    // Make sure to use relative dimension since the crop will be applied
    // on the source image.
    this.darkroom.applyTransformation(new Crop({
      top: top / image.getHeight(),
      left: left / image.getWidth(),
      width: width / image.getWidth(),
      height: height / image.getHeight(),
    }));
  },

  // Test wether crop zone is set
  hasFocus: function() {
    return this.cropZone !== undefined;
  },

  // Create the crop zone
  requireFocus: function() {
    this.cropZone = new CropZone({
      fill: 'transparent',
      hasBorders: false,
      originX: 'left',
      originY: 'top',
      //stroke: '#444',
      //strokeDashArray: [5, 5],
      //borderColor: '#444',
      cornerColor: '#444',
      cornerSize: 8,
      transparentCorners: false,
      lockRotation: true,
      hasRotatingPoint: false,
    });

    if (null !== this.options.ratio) {
      this.cropZone.set('lockUniScaling', true);
    }

    this.darkroom.canvas.add(this.cropZone);
    this.darkroom.canvas.defaultCursor = 'crosshair';

    this.cropButton.active(true);
    this.okButton.hide(false);
    this.cancelButton.hide(false);
  },

  // Remove the crop zone
  releaseFocus: function() {
    if (undefined === this.cropZone)
      return;

    this.cropZone.remove();
    this.cropZone = undefined;

    this.cropButton.active(false);
    this.okButton.hide(true);
    this.cancelButton.hide(true);

    this.darkroom.canvas.defaultCursor = 'default';

    this.darkroom.dispatchEvent('crop:update');
  },

  _renderCropZone: function(fromX, fromY, toX, toY) {
    var canvas = this.darkroom.canvas;

    var isRight = (toX > fromX);
    var isLeft = !isRight;
    var isDown = (toY > fromY);
    var isUp = !isDown;

    var minWidth = Math.min(+this.options.minWidth, canvas.getWidth());
    var minHeight = Math.min(+this.options.minHeight, canvas.getHeight());

    // Define corner coordinates
    var leftX = Math.min(fromX, toX);
    var rightX = Math.max(fromX, toX);
    var topY = Math.min(fromY, toY);
    var bottomY = Math.max(fromY, toY);

    // Replace current point into the canvas
    leftX = Math.max(0, leftX);
    rightX = Math.min(canvas.getWidth(), rightX);
    topY = Math.max(0, topY)
    bottomY = Math.min(canvas.getHeight(), bottomY);

    // Recalibrate coordinates according to given options
    if (rightX - leftX &lt; minWidth) {
      if (isRight)
        rightX = leftX + minWidth;
      else
        leftX = rightX - minWidth;
    }
    if (bottomY - topY &lt; minHeight) {
      if (isDown)
        bottomY = topY + minHeight;
      else
        topY = bottomY - minHeight;
    }

    // Truncate truncate according to canvas dimensions
    if (leftX &lt; 0) {
      // Translate to the left
      rightX += Math.abs(leftX);
      leftX = 0
    }
    if (rightX > canvas.getWidth()) {
      // Translate to the right
      leftX -= (rightX - canvas.getWidth());
      rightX = canvas.getWidth();
    }
    if (topY &lt; 0) {
      // Translate to the bottom
      bottomY += Math.abs(topY);
      topY = 0
    }
    if (bottomY > canvas.getHeight()) {
      // Translate to the right
      topY -= (bottomY - canvas.getHeight());
      bottomY = canvas.getHeight();
    }

    var width = rightX - leftX;
    var height = bottomY - topY;
    var currentRatio = width / height;

    if (this.options.ratio && +this.options.ratio !== currentRatio) {
      var ratio = +this.options.ratio;

      if(this.isKeyCroping) {
        isLeft = this.isKeyLeft;
        isUp = this.isKeyUp;
      }

      if (currentRatio &lt; ratio) {
        var newWidth = height * ratio;
        if (isLeft) {
          leftX -= (newWidth - width);
        }
        width = newWidth;
      } else if (currentRatio > ratio) {
        var newHeight = height / (ratio * height/width);
        if (isUp) {
          topY -= (newHeight - height);
        }
        height = newHeight;
      }

      if (leftX &lt; 0) {
        leftX = 0;
        //TODO
      }
      if (topY &lt; 0) {
        topY = 0;
        //TODO
      }
      if (leftX + width > canvas.getWidth()) {
        var newWidth = canvas.getWidth() - leftX;
        height = newWidth * height / width;
        width = newWidth;
        if (isUp) {
          topY = fromY - height;
        }
      }
      if (topY + height > canvas.getHeight()) {
        var newHeight = canvas.getHeight() - topY;
        width = width * newHeight / height;
        height = newHeight;
        if (isLeft) {
          leftX = fromX - width;
        }
      }
    }

    // Apply coordinates
    this.cropZone.left = leftX;
    this.cropZone.top = topY;
    this.cropZone.width = width;
    this.cropZone.height = height;

    this.darkroom.canvas.bringToFront(this.cropZone);

    this.darkroom.dispatchEvent('crop:update');
  }
});

})();</PRE></DIV><DIV class="paragraph code-paragraph collapsed" name="darkroom-plugin-history.js" run-on-load="true" last-execution-state="success" __wid="EUs16bJq"><PRE data-type="content" type="text/javascript" __wid="P6iTunZm">;(function(window, document, Darkroom, fabric) {
  'use strict';

  Darkroom.plugins['history'] = Darkroom.Plugin.extend({
    undoTransformations: [],

    initialize: function InitDarkroomHistoryPlugin() {
      this._initButtons();

      this.darkroom.addEventListener('core:transformation', this._onTranformationApplied.bind(this));
    },

    undo: function() {
      if (this.darkroom.transformations.length === 0) {
        return;
      }

      var lastTransformation = this.darkroom.transformations.pop();
      this.undoTransformations.unshift(lastTransformation);

      this.darkroom.reinitializeImage();
      this._updateButtons();
    },

    redo: function() {
      if (this.undoTransformations.length === 0) {
        return;
      }

      var cancelTransformation = this.undoTransformations.shift();
      this.darkroom.transformations.push(cancelTransformation);

      this.darkroom.reinitializeImage();
      this._updateButtons();
    },

    _initButtons: function() {
      var buttonGroup = this.darkroom.toolbar.createButtonGroup();

      this.backButton = buttonGroup.createButton({
        image: 'undo',
        disabled: true
      });

      this.forwardButton = buttonGroup.createButton({
        image: 'redo',
        disabled: true
      });

      this.backButton.addEventListener('click', this.undo.bind(this));
      this.forwardButton.addEventListener('click', this.redo.bind(this));

      return this;
    },

    _updateButtons: function() {
      this.backButton.disable((this.darkroom.transformations.length === 0))
      this.forwardButton.disable((this.undoTransformations.length === 0))
    },

    _onTranformationApplied: function() {
      this.undoTransformations = [];
      this._updateButtons();
    }
  });
})(window, document, Darkroom, fabric);</PRE></DIV><DIV class="paragraph code-paragraph collapsed" name="darkroom-plugin-rotate.js" run-on-load="true" last-execution-state="success" __wid="rW9VK939"><PRE data-type="content" type="text/javascript" __wid="MgZcz2qh">(function() {
'use strict';

var Rotation = Darkroom.Transformation.extend({
  applyTransformation: function(canvas, image, next) {
    var angle = (image.getAngle() + this.options.angle) % 360;
    image.rotate(angle);

    var width, height;
    height = Math.abs(image.getWidth()*(Math.sin(angle*Math.PI/180)))+Math.abs(image.getHeight()*(Math.cos(angle*Math.PI/180)));
    width = Math.abs(image.getHeight()*(Math.sin(angle*Math.PI/180)))+Math.abs(image.getWidth()*(Math.cos(angle*Math.PI/180)));

    canvas.setWidth(width);
    canvas.setHeight(height);

    canvas.centerObject(image);
    image.setCoords();
    canvas.renderAll();

    next();
  }
});

Darkroom.plugins['rotate'] = Darkroom.Plugin.extend({

  initialize: function InitDarkroomRotatePlugin() {
    var buttonGroup = this.darkroom.toolbar.createButtonGroup();

    var leftButton = buttonGroup.createButton({
      image: 'rotate_left'
    });

    var rightButton = buttonGroup.createButton({
      image: 'rotate_right'
    });

    leftButton.addEventListener('click', this.rotateLeft.bind(this));
    rightButton.addEventListener('click', this.rotateRight.bind(this));
  },

  rotateLeft: function rotateLeft() {
    this.rotate(-90);
  },

  rotateRight: function rotateRight() {
    this.rotate(90);
  },

  rotate: function rotate(angle) {
    this.darkroom.applyTransformation(
      new Rotation({angle: angle})
    );
  }

});

})();</PRE></DIV><DIV class="paragraph code-paragraph collapsed" name="darkroom-plugin-save.js" run-on-load="true" last-execution-state="success" __wid="TjMKWekr"><PRE data-type="content" type="text/javascript" __wid="ui2q_ERl">(function() {
'use strict';

Darkroom.plugins['save'] = Darkroom.Plugin.extend({

  defaults: {
    callback: function() {
      this.darkroom.selfDestroy();
    }
  },

  initialize: function InitializeDarkroomSavePlugin() {
    var buttonGroup = this.darkroom.toolbar.createButtonGroup();

    this.destroyButton = buttonGroup.createButton({
      image: 'save'
    });

    this.destroyButton.addEventListener('click', this.options.callback.bind(this));
  },
});

})();</PRE></DIV><DIV class="paragraph code-paragraph collapsed" name="Initialize Image Crop" last-execution-state="success" __wid="qtn0O2ai"><PRE data-type="content" type="text/javascript" __wid="993OGTwj">importStyle("darkroom.css");

if (!HTMLCanvasElement.prototype.toBlob) {
  Object.defineProperty(HTMLCanvasElement.prototype, 'toBlob', {
    value: function (callback, type, quality) {

      var binStr = atob( this.toDataURL(type, quality).split(',')[1] ),
          len = binStr.length,
          arr = new Uint8Array(len);

      for (var i = 0; i &lt; len; i++ ) {
        arr[i] = binStr.charCodeAt(i);
      }

      callback( new Blob( [arr], {type: type || 'image/png'} ) );
    }
  });
}

const darkroomize = image => {

  const fullPath = image.src;

  // first strips path... second strips extension
  const filename = fullPath.replace(/^.*[\\\/]/, '').replace(/\.[^/.]+$/, "");
  
  const bounds = image.getBoundingClientRect();

  const dkrm = new Darkroom(image, {
    
    maxWidth: bounds.width,
		maxHeight: bounds.height,
		
    plugins: {
      save: {
        callback: function() {
          this.darkroom.selfDestroy(); // Cleanup

          //               console.log(this);

          this.darkroom.canvas.lowerCanvasEl.toBlob(blob => {
            //           window.console.log(blob);

            const formData = new FormData();
            formData.append("file", blob, `${filename}.png`);

            const request = new XMLHttpRequest();
            request.open("POST", window.location.pathname);
            request.send(formData);
            request.addEventListener("load", (e) => {
              const asset = JSON.parse(request.responseText);

              window.console.log("uploaded", asset);

              //             window.console.log(dr.sourceImage._element);
              //             window.console.log(dr.sourceImage._element.src);

              image.src = `${asset.fileName}?version=${asset.v}`;
              //                   image.removeAttribute("darkroom");
              //                   transient.remove();
            });
          });
        }
      }
    }
  });
};

importLib([
  "hammer.min.js",
  "hammer-time.min.js",
  "fabric.js"
]).then(() => {

  var mc = new Hammer.Manager(window);

  // Tap recognizer with minimal 2 taps
  mc.add( new Hammer.Tap({ event: 'doubletap', taps: 2 }) );

  mc.on("doubletap", function(event) {

    const target = event.srcEvent.target;

//     console.log('doubletap %o', target);

    if (target.tagName.toUpperCase() === "IMG") {
      darkroomize(target);
    }

  });

  //   document.addEventListener("dblclick", darkroomize, true);
});</PRE></DIV><DIV class="paragraph style-paragraph collapsed" name="Custom Darkroom Style" __wid="euwXU6Qe"><STYLE data-type="content" type="text/css" codemirror="true" __wid="r7bfFy_3">transient.darkroom-container {
  outline: none;
}

.darkroom-button-default {
  color: white;
}

.darkroom-button-success {
  color: lime;
}

.darkroom-button-danger {
  color: red;
}

.paragraph.body-paragraph [data-type="content"] img {
  cursor: default;
}</STYLE></DIV></DIV><DIV name="Avatars" data-type="system" class="section section-hidden" __wid="Rw8mO-DS"><DIV class="paragraph body-paragraph" draggable="false" name="Documentation and Example Rendering" __wid="RRKjzg8m"><DIV data-type="content" type="text/html" codemirror="true" contenteditable="true" __wid="Lmoxuayb"><H2 __wid="6GAGrDUZ">Example of user list<BR __wid="dOiaqxBo"/></H2>

<DIV class="avatars-test" __wid="69gclFsr">
	<DIV class="avatar" client-id="test3" username="unknown" style="background-image: url(&quot;unknown.jpg&quot;); border-color: rgb(99, 178, 252);" __wid="aG_5nvgg"></DIV>

	<DIV class="avatar" client-id="test2" username="cklokmose" style="background-image: url(&quot;https://avatars.githubusercontent.com/u/1607207?v=3&quot;); border-color: rgb(254, 83, 124);" __wid="jl8KO0g4"></DIV>

	<DIV class="avatar self" client-id="test1" username="raedle" style="background-image: url(&quot;https://avatars.githubusercontent.com/u/489051?v=3&quot;); border-color: rgb(226, 178, 252);" __wid="AyIJENW3"></DIV>
</DIV></DIV></DIV><DIV class="paragraph code-paragraph collapsed" name="Avatars Code" run-on-load="true" last-execution-state="success" __wid="QchpAA39"><PRE data-type="content" type="text/javascript" __wid="QwHKER6A">const UserManager = require('#user-manager');
const FlashScreen = require('#flash-screen');

const anonymousUrl = "unknown.jpg";

// How often the idle time is updated (in milliseconds)
const UPDATE_IDLE_TIME_INTERVAL = 10 * 1000;

// Add users element
const avatars = document.createElement("transient");
avatars.classList.add("avatars");
document.body.appendChild(avatars);

/**
 * Get other client ids (all connected client ids except for own client id).
 */
const otherClientIds = () => {
	return webstrate.clients.filter(c => c !== webstrate.clientId);
};

/**
 * Add a user's avatar to the avatars list.
 */
const addAvatar = (username, url, clientId) => {
	
// 	console.log('add avatar', username, url, clientId);

	if (avatars.querySelector(`.avatar[client-id=${clientId}]`)) return;
	
// 	console.log('will add avatar', username, url, clientId);

	const avatar = document.createElement("div");
	avatar.classList.add("avatar");
	avatar.setAttribute("client-id", clientId);
	avatar.setAttribute("username", username || clientId);
	avatar.style.backgroundImage = `url(${url})`;
	
// 	setTimeout(() => {
		avatar.style.borderColor = UserManager.getUserColor(clientId);
// 	}, 1000);

	if (clientId === webstrate.clientId) {
		avatar.classList.add("self");
	}

	// Send flash screen command to sender
	avatar.addEventListener("click", event => {
		webstrate.signal({ cmd: "flashScreen" }, clientId);
	});

	avatars.appendChild(avatar);
};

/**
 * Removes an avatar from the avatars list.
 *
 * @param {string} clientId The client's id associated with the avatar.
 */
const removeAvatar = (clientId) => {
	const avatar = avatars.querySelector(`.avatar[client-id="${clientId}"]`);
	if (avatar) {
		avatar.remove();
	}
};

/**
 * Send avatar to all other users.
 */
const sendAvatar = (clientId, giveMeYourAvatar = true) => {

	const url = (webstrate.user && webstrate.user.avatarUrl) ?
				webstrate.user.avatarUrl : anonymousUrl;

	const otherClients = otherClientIds();
	
// 	console.debug('send avatar to', JSON.stringify(otherClients));
	
	webstrate.signal({
		cmd: "avatar",
		username: webstrate.user.username,
		avatarUrl: url,
		giveMeYourAvatar
	}, clientId ? [clientId] : otherClients);
};

const updateIdleTime = (senderId, idleTime) => {
	
// 	console.log(senderId, idleTime);
	
	const avatar = avatars.querySelector(`.avatar[client-id="${senderId}"]`);
	
	if (!avatar) {
// 		console.warn(`Client ${senderId} keeps pinging but avatar does not exist anymore... Why?`);
		return;
	}
	
	var snoozeBox = avatar.querySelector(".snooze");
	if (idleTime > 0) {
		avatar.classList.add("snoozed");
		if (!snoozeBox) {
			snoozeBox = document.createElement("div");
			snoozeBox.classList.add("snooze");
			avatar.appendChild(snoozeBox);
		}
		snoozeBox.innerHTML = `${(idleTime/1000/60)|0}m`;
	} else if (snoozeBox) {
		avatar.classList.remove("snoozed");
		snoozeBox.remove();
	}
};

const idleUsers = [];

const stopUpdateIdleTime = (clientId) => {
	// Clear update interval
	const users = idleUsers.filter(u => u.clientId === clientId)
	.forEach(u => clearInterval(u.interval));
};

/**
 * Clear all update idle timers.
 */
const clearUpdateIdleTimers = () => {
	idleUsers.forEach(u => clearInterval(u.interval));
};

/**
 * Listen for other users to signal their avatar url.
 */
webstrate.on("signal", (message, senderId) => {
	
	if (message.type === "IdleTimer") {
// 		console.log(message, senderId);
		
		if (message.cmd === "awake") {
			stopUpdateIdleTime(senderId);
			updateIdleTime(senderId, 0);
		}
		else if (message.cmd === "idle") {
			
			const lastAction = Date.now() - message.idleTime;
			
			updateIdleTime(senderId, Date.now() - lastAction);
			const interval = setInterval(() => {
				updateIdleTime(senderId, Date.now() - lastAction);
			}, UPDATE_IDLE_TIME_INTERVAL);
				
			idleUsers.push({
				clientId: senderId,
				interval: interval
			});
		}
		
		return;
	}

	if (message.cmd === "avatar") {

		// Ignore own message -> remove when code is stable.
		if (webstrate.clientId === senderId) {
// 			throw new Error("This should not happen");
			return;
		}

		addAvatar(message.username, message.avatarUrl, senderId);
		
		if (message.giveMeYourAvatar) {
			// Also send back own avatar to sender client.
			sendAvatar(senderId, false);
		}
	}
	else if (message.cmd === "flashScreen") {

		// Ignore own message -> remove when code is stable.
		if (webstrate.clientId === senderId) {
// 			throw new Error("This should not happen");
			return;
		}

		// Flash, flash!
		FlashScreen.flash();

		// Show little star next to whoever flashed.
		senderAvatar = avatars.querySelector(`.avatar[client-id="${senderId}"]`);
		var div = document.createElement("div");
		div.classList.add("star");
		div.innerHTML = "&#10039;";
		senderAvatar.appendChild(div);
		setTimeout(() => div.remove(), 5000);
	}
});

const start = () => {
	
// 	console.log('user', webstrate.user);
// 	console.log('username', webstrate.user.username);
// 	console.log('avatarUrl', webstrate.user.avatarUrl);
// 	console.log('clientId', webstrate.clientId);
// 	console.log('avatars', avatars);
	
	/**
   * Add own avatar.
   */
	if (webstrate.user) {
		addAvatar(webstrate.user.username || "anonymous",
							webstrate.user.avatarUrl || anonymousUrl,
							webstrate.clientId);
	}

	sendAvatar();
};

start();

webstrate.on("clientJoin", (clientId) => {
	
// 	console.log("Client joined", clientId === webstrate.clientId ? "#SELF'" : "#OTHER", clientId, JSON.stringify(webstrate.clients));
	
	if (clientId === webstrate.clientId) {
		start();
	}
	else {
// 		setTimeout(() => {
		sendAvatar(clientId);
// 		}, 10000);
	}
});

/**
 * Remove a user's avatar when the user disconnects and also stop its update idle
 * timer.
 */
webstrate.on("clientPart", (clientId) => {
	stopUpdateIdleTime(clientId);
	removeAvatar(clientId);
});

// Clear all update idle timers and remove all avatars.
webstrate.on("disconnect", () => {
	
	// Clear all update idle timers.
	clearUpdateIdleTimers();
	
	// Clear all avatars
	avatars.innerHTML = "";
});

// webstrate.on("signal", (message, senderId) => {
// 	console.log(message, senderId);
// });</PRE></DIV><DIV class="paragraph style-paragraph collapsed" name="Avatars Style" __wid="PE45bgQZ"><STYLE data-type="content" type="text/css" codemirror="true" __wid="2eh7-BC2">.avatars {
	position: fixed;
	bottom: 10px;
	left: 10px;
}

/* Make the .avatars-test only occupy minimal space */
.avatars-test {
	float: left;
	position: relative;
	bottom: 10px;
	left: 10px;
}

.avatars .avatar,
.avatars-test .avatar {
	box-sizing: content-box;
	position: relative;
	width: 45px;
	height: 45px;
	margin-top: 10px;
	background-size: contain;
	border-radius: 50%;
	border: 2px solid white;
	box-shadow: 0px 0px 5px #000;
}
.avatars .avatar:not(.self) {
	cursor: pointer;
}
.avatars:hover .avatar:after,
.avatars-test:hover .avatar:after {
	content: attr(username);
	display: inline-block;
	background: #000;
	padding: 2px 6px;
	font-size: .8em;
	transform: translate3d(60px, 10px, 0) rotate(4deg);
}
.avatars .avatar > div.star {
	color: rgba(255,255,255,.3);
	position: absolute;
	margin-left: 47px;
	margin-top: 47px;
}
.avatars .avatar > div.snooze {
	color: #fff;
	font-size: 65%;
	font-weight: bold;
	text-shadow: 1px 1px #000;
	position: absolute;
	margin-left: 53px;
	margin-top: -3px;
}
.avatars .avatar.snoozed {
	opacity: .25;
}
@media only screen and (max-width: 950px) {
	.avatars {
		top: 5px;
		left: 5px;
	}
	.avatars .avatar {
		width: 30px;
		height: 30px;
		margin-bottom: 5px;
		border-width: 1px;
	}
	.avatars:hover .avatar:after {
		font-size: 60%;
		transform: translate3d(30px, 10px, 0) rotate(4deg);
	}
	.avatar > div.star {
		font-size: 40%;
	  margin-left: 23px;
	  margin-top: 23px;
	}
	.avatar > div.snooze {
		display: none;
	}
}
@media only screen and (max-width: 875px) {
	.avatars {
		display: none;
	}
}</STYLE></DIV><DIV class="paragraph code-paragraph collapsed" name="Flash Screen Code" last-execution-state="success" __wid="wWirNG3m"><PRE data-type="content" type="text/javascript" id="flash-screen" __wid="IoryQiQa">exports.flash = () => {
	const overlay = document.createElement("transient");
	overlay.classList.add("flash-overlay");
	setTimeout(() => overlay.remove(), 200);
	document.body.appendChild(overlay);
};</PRE></DIV><DIV class="paragraph style-paragraph collapsed" name="Flash Screen Style" __wid="VanI27X9"><STYLE data-type="content" type="text/css" codemirror="true" __wid="CXv36i7P">@keyframes pulse {
  0% {
    background: transparent;
  }
  50% {
    background: rgba(255,255,255,.3);
  }
  100% {
    background: transparent;
  }
}

.flash-overlay {
	position: fixed;
	top: 0;
	left: 0;
	right: 0;
	bottom: 0;
	max-width: 100vw;
	max-height: 100vh;
  animation: pulse 0.2s ease-in-out;
}</STYLE></DIV><DIV class="paragraph code-paragraph collapsed" name="Idle Time Code" last-execution-state="success" __wid="6tv7xckv"><PRE data-type="content" type="text/javascript" id="idle-time" __wid="ikFawizD">var lastAction = Date.now();
const updateLastAction = () => lastAction = Date.now();
//document.addEventListener("keydown", updateLastAction);
document.addEventListener("mousemove", updateLastAction);
document.addEventListener("touchstart", updateLastAction);
exports.get = () => ((Date.now() - lastAction) / 1000) | 0;</PRE></DIV></DIV><DIV class="section section-hidden" name="WebRTC Video on Avatar (experimental)" data-type="system" __wid="cTpuJNn2"><DIV class="paragraph style-paragraph collapsed" draggable="false" name="WebRTC Style" __wid="6LbEvWh9"><STYLE data-type="content" type="text/css" codemirror="true" __wid="_ToS7gzW">.avatars .avatar .video-wrapper {
	position: absolute;
	top: 0;
	left: 0;
	width: 100%;
	height: 100%;
	border-radius: 50%;
	-webkit-mask-image: -webkit-radial-gradient(circle, white 100%, black 100%); 
	-webkit-transform: rotate(0.000001deg); 
	-webkit-border-radius: 50%; 
	-moz-border-radius: 50%;
	transform: translateZ(0);
}

.avatars .avatar .video-wrapper video {
	position: absolute;
	left: 50%;
	top: 50%;
	height: 100%;
	transform: translate3d(-50%, -50%, 0);
}

.avatars .avatar.self .video-wrapper video {
	transform: translate3d(-50%, -50%, 0) scaleX(-1);
}</STYLE></DIV><DIV class="paragraph code-paragraph collapsed" name="Event Handling" run-on-load="true" last-execution-state="success" __wid="QubzULun"><PRE data-type="content" type="text/javascript" __wid="7U-6Xn7A">webstrate.on("signal", (message, senderId) => {

	if (message.type === "Call") {

		// Received request for video call.
		if (message.cmd === "video") {
			console.log("Requesting video");
			
			const result = confirm(`User ${senderId} calls you. Do you want to accept the call?`);
			
			if (result) {
				VideoManager.start(senderId);

				// Signal accept
				webstrate.signal({ type: "Call", cmd: "accept" }, senderId);
			}
			else {
				// Signal reject
				webstrate.signal({ type: "Call", cmd: "reject" }, senderId);
			}
		}
		// Approved video call request.
		else if (message.cmd === "accept") {
			console.log("Accepting video");
			
			VideoManager.start(senderId);
		}
		else if (message.cmd === "reject") {
			console.log("Rejecting video");
			alert(`User ${senderId} rejected call.`);
		}

		return;
	}
});

const createUserVideo = (clientId) => {
	const avatar = document.querySelector(`.avatars .avatar[client-id="${clientId}"]`);

	var videoWrapper = document.createElement("div");
	videoWrapper.classList.add("video-wrapper");
	
	var video = document.createElement("video");
	video.classList.add("remote-video");
	videoWrapper.appendChild(video);
	avatar.appendChild(videoWrapper);
	
	return video;
};

const listenForStreams = (clientId, meta, accept) => {
	console.log('create user video', clientId);
	const videoElement = createUserVideo(clientId);

	if (videoElement) {
		console.log('create user element', videoElement);
		
		var conn = accept(function(stream) {
			// Add stream to video element and play it.
			videoElement.srcObject = stream;
			videoElement.play();
			
			conn.onclose(function() {
				if (stream) {
					stream.getVideoTracks().forEach(t => t.stop());
					stream.getAudioTracks().forEach(t => t.stop());
				}

				videoElement.closest('.video-wrapper').remove();
				
				document.body.webstrate.on("signalStream", listenForStreams);
			});
		});
	}
	
// 	// Listen for further streams...
// 	document.body.webstrate.on("signalStream", listenForStreams);
};

document.body.webstrate.on("signalStream", listenForStreams);</PRE></DIV><DIV class="paragraph code-paragraph collapsed" name="Video Manager" __wid="USCD-RF6"><PRE data-type="content" type="text/javascript" id="video-manager" __wid="UJXM8eJ_">const createUserVideo = (clientId) => {
	const avatar = document.querySelector(`.avatar[client-id="${clientId}"]`);

	// no avatar for client id found
	if (!avatar) return;

	let video = avatar.querySelector('video');
	if (video) {
		return video;
	}

	const videoWrapper = document.createElement("div");
	videoWrapper.classList.add("video-wrapper");

	video = document.createElement("video");
	video.classList.add("local-video");
	video.setAttribute("muted", "");

	videoWrapper.appendChild(video);
	avatar.appendChild(videoWrapper);

	return video;
};

const signalStream = (clientId, accept) => {
	// Get audio and video feed.
	
	if (clientId === webstrate.clientId) return;

	try {
		const videoElement = createUserVideo(webstrate.clientId);

		if (!videoElement.__cons) {
			videoElement.__cons = [];
		}

		if (videoElement.__stream) {
			// And send it to the requesting client.
			var meta = { title: "My Video Stream" };
			var conn = accept(videoElement.__stream, meta, function() {
				// Connection has been established.
			});

			videoElement.__cons.push(conn);
		}
		else {
			const mediaDevices = navigator.mediaDevices;
			mediaDevices.getUserMedia({ audio: true, video: true })
				.then(function(stream) {

				videoElement.__stream = stream;
				videoElement.srcObject = stream;
				videoElement.play();

				// And send it to the requesting client.
				var meta = { title: "My Video Stream" };
				var conn = accept(stream, meta, function() {
					// Connection has been established.
				});

				videoElement.__cons.push(conn);
			});
		}
	}
	catch (error) {
		console.error(error);
	}
};

exports.hearMe = () => {
	document.body.webstrate.signalStream(signalStream);
};

exports.stopHearMe = () => {
	document.body.webstrate.stopStreamSignal(signalStream);

	const video = createUserVideo(webstrate.clientId);
	if (video.__cons) {
		video.__cons.forEach(c => c.close());
		delete video.__cons;
	}

	if (video.__stream) {
		const stream = video.__stream;
		stream.getVideoTracks().forEach(t => t.stop());
		stream.getAudioTracks().forEach(t => t.stop());
		delete video.__stream;
	}

	video.closest('.video-wrapper').remove();
}</PRE></DIV><DIV class="paragraph code-paragraph collapsed" name="Augment Avatar" run-on-load="true" last-execution-state="success" __wid="dm-a-Kbu"><PRE data-type="content" type="text/javascript" __wid="LUH4I9BA">const VideoManager = require('#video-manager');

const augmentAvatar = (avatar) => {
	const hearMe = document.createElement("div");
	hearMe.classList.add("hear-me");

	const icon = document.createElement("i");
	icon.classList.add("material-icons");
	hearMe.appendChild(icon);

	hearMe.addEventListener("click", event => {

		if (avatar.classList.contains("talking")) {
			VideoManager.stopHearMe();
			avatar.classList.remove("talking");
		}
		else {
			VideoManager.hearMe();
			avatar.classList.add("talking");
		}
	});

	avatar.appendChild(hearMe);
}

document.liveQuerySelectorAll('.avatars .avatar.self').added(augmentAvatar);</PRE></DIV><DIV class="paragraph style-paragraph collapsed" name="Augmented Avatar Style" __wid="eHMpBVkR"><STYLE data-type="content" type="text/css" codemirror="true" __wid="V-5qBuiW">.avatars .avatar .hear-me {
	position: absolute;
	top: 0;
	left: 0;
	z-index: 1;
	width: 45px;
	height: 45px;
	background-color: deepskyblue;
	border-radius: 50%;
	border: 2px solid white;
	box-shadow: 0px 0px 5px #000;
	opacity: 0;
	transition: transform 250ms ease-in-out 250ms, opacity 250ms ease-in-out 250ms;
}

.avatars .avatar .hear-me i:after {
	content: "videocam";
	position: absolute;
	left: 50%;
	top: 50%;
	transform: translate3d(-50%, -50%, 0);
}

.avatars .avatar .hear-me:hover {
	background-color: green;
}

.avatars .avatar.talking .hear-me i:after {
	content: "videocam_off";
}

.avatars .avatar:hover .hear-me {
	opacity: 1.0;
	transform: translate3d(50px, 0, 0);
	pointer-events: all;
	cursor: pointer;
}</STYLE></DIV></DIV><DIV class="section section-hidden" name="Chat" data-type="system" __wid="2dn3oKlo"><DIV class="paragraph body-paragraph locked" name="Chat" __wid="8TQydjKF"><DIV data-type="content" type="text/html" codemirror="true" contenteditable="false" id="chat" class="chat chat-closed" __wid="bdDFfe5X"><DIV class="chat-handle" __wid="2w2choGc"></DIV>
<UL class="messages" __wid="VbHLcUXS">
  <LI class="message" username="raedle" __wid="0xs4Y61h">asdf</LI>
  <LI class="message" username="raedle" __wid="1PIz58mm">as</LI>
  <LI class="message" username="raedle" __wid="iSamzWxQ">df</LI>
  <LI class="message" username="raedle" __wid="zAgIvIvs">sadf</LI>
  <LI class="message" username="raedle" __wid="kFwuq5so">asdf</LI>
  <LI class="message" username="raedle" __wid="bXazuxJz">sa</LI>
  <LI class="message" username="raedle" __wid="F-Gajh4_">f</LI>
  <LI class="message" username="raedle" __wid="_JpMZxlT">asdf</LI>
  <LI class="message" username="raedle" __wid="y4MDxRmb">sadf</LI>
  <LI class="message" username="raedle" __wid="5UVAtSva">sad</LI>
  <LI class="message" username="raedle" __wid="o_LBI2A5">f</LI>
  <LI class="message" username="raedle" __wid="IiYWt3zR">asd</LI>
  <LI class="message" username="raedle" __wid="nruPzYeW">asf</LI>
  <LI class="message" username="raedle" __wid="vjPCaWB4">dsf</LI>
  <LI class="message" username="raedle" __wid="O3xSDLem">asdf</LI>
  <LI class="message" username="raedle" __wid="ookBbq2x">as</LI>
  <LI class="message" username="raedle" __wid="FcR8gN6z">f</LI>
  <LI class="message" username="raedle" __wid="V0F94OXk">asdf</LI>
  <LI class="message" username="raedle" __wid="ECmJ0o9x">sadf</LI>
  <LI class="message" username="raedle" __wid="L_luQQ3e">asdf</LI>
  <LI class="message" username="raedle" __wid="I4sf9bBL">asd</LI>
  <LI class="message" username="raedle" __wid="P8OLOILO">fas</LI>
  <LI class="message" username="raedle" __wid="YxUmZHga">df</LI>
  <LI class="message" username="raedle" __wid="5mP6CJbC">sadf</LI>
  <LI class="message" username="raedle" __wid="ZcRFG5oL">Midas?</LI>
  <LI class="message" username="raedle" __wid="MADBA7Fl">Bettter?</LI>
  <LI class="message" username="raedle" __wid="gn4xjoBg">Test</LI>
  <LI class="message" username="raedle" __wid="WDcDN39t">a</LI>
  <LI class="message" username="MidasN" __wid="cLJUQRgX">sdsd</LI>
  <LI class="message" username="raedle" __wid="pcVYDf7l">Hello</LI>
  <LI class="message" username="raedle" __wid="pEazjAMP">It is a kind of working chat</LI>
  <LI class="message" username="raedle" __wid="bilPAKm1">Kind of working, yeah!</LI>
  <LI class="message" username="raedle" __wid="bksharXd">Hello</LI>
  <LI class="message" username="raedle" __wid="q2IXCqcI">ASDF</LI>
  <LI class="message" username="raedle" __wid="-kqX0FPO">Test</LI>
  <LI class="message" username="raedle" __wid="w0GjF8bS">Clemens?</LI>
  <LI class="message" username="raedle" __wid="hhDNdH2G">Tewst</LI>
  <LI class="message" username="raedle" __wid="KpmsIt7h">Hello World</LI>
  <LI class="message" username="raedle" __wid="ipPnKCoV">Great!</LI>
  <LI class="message" username="raedle" __wid="nGgY3Ltn">New message</LI>
  <LI class="message" username="raedle" __wid="_vjYMw-T">Another message</LI>
  <LI class="message" username="raedle" __wid="-kUTq3jM">Test</LI>
  <LI class="message" username="raedle" __wid="N2PcTJgR">ASDF</LI>
  <LI class="message" username="raedle" __wid="sO_ZOROm">Hello</LI>
  <LI class="message" username="raedle" __wid="Q_Fp7_F9">Better</LI>
  <LI class="message" username="raedle" __wid="NmgHPgzW">Grea</LI>
  <LI class="message" username="raedle" __wid="enqqq6p_">Aaah</LI>
  <LI class="message" username="raedle" __wid="MrTK_ze-">Better?</LI>
  <LI class="message" username="raedle" __wid="0duvbbxI">Beetteer</LI>
  <LI class="message" username="raedle" __wid="dYM87X4e">beter</LI>
  <LI class="message" username="raedle" __wid="ShxCMAUu">Hello?</LI>
  <LI class="message" username="raedle" __wid="EGpYrYYb">Simple chat</LI>
<LI class="message" username="raedle" __wid="OChNPcfV">Hello?</LI></UL>
<DIV class="input-wrapper" __wid="ZSy_bipM">
  <INPUT class="input" placeholder="Type in a message and press enter" __wid="U7iI8t6k"/>
</DIV></DIV></DIV><DIV class="paragraph style-paragraph collapsed" name="Chat Style" __wid="ertO5SFk"><STYLE data-type="content" type="text/css" codemirror="true" __wid="xy1n4YiJ">.chat {
	position: fixed;
	top: 0;
	left: 0;
	margin: 0 !important;
	width: 100vw;
	max-height: 40%;
	color: black;
	background-color: white;
	display: flex;
	flex-flow: column;
	transition: transform 250ms ease-in-out;
	z-index: 2;
}

.chat .chat-handle {
	color: white;
	position: absolute;
	bottom: 0;
	left: 10px;
	transform: translate3d(0, 100%, 0);
	cursor: pointer;
}

.chat .chat-handle:after {
  content: "drag_handle";
  font-family: "Material Icons";
  font-size: 1.6em;
  margin-right: 4px;
  border-bottom-right-radius: 2px;
  border-bottom-left-radius: 2px;
  background: rgba(20, 20, 20, 1.0);
}

.chat.chat-closed {
	transform: translate3d(0, -100%, 0);
}

.chat ul {
	position: relative;
	color: black;
	font-size: 1.4em;
	list-style: none;
	margin: 0;
	padding: 10px;
	flex: 1;
	overflow: hidden;
	overflow-y: scroll;
	height: 200px;
}

.chat ul li.message:before {
	content: attr(username) ": ";
	font-weight: bold;
}

.chat .input {
	font-size: 1.4em;
	padding: 10px 16px;
	width: calc(100% - 32px);
	border: 0;
	border-top: 1px solid rgba(0, 0, 0, .5);
	outline: 0;
}

.chat .input-wrapper {
	position: relative;
	width: 100%;
}

.chat .input-wrapper:after {
	content: "\21B5";
	position: absolute;
	right: 0;
	top: 50%;
	transform: translate3d(-50%, -40%, 0);
	pointer-events: none;
	font-size: 2em;
}</STYLE></DIV><DIV class="paragraph code-paragraph collapsed" last-execution-state="success" name="Chat Code" __wid="xLWNbFxu"><PRE data-type="content" type="text/javascript" __wid="8e4FI7S9">let chat = document.querySelector('#chat');
chat = chat.cloneNode(true);

let chatWrapper = document.createElement("transient");
chatWrapper.appendChild(chat);
document.body.appendChild(chatWrapper);

let messages = chat.querySelector('.messages');
let input = chat.querySelector('.input');
let chatHandle = chat.querySelector('.chat-handle');

chatHandle.addEventListener("click", event => {
	event.preventDefault();
	chat.classList.toggle("chat-closed");
}, true);

// document.addEventListener("click", event => {
// 	if (!event.target.closest('#chat')) {
// 		chat.classList.remove("chat-closed");
// 	}
// }, true);

input.addEventListener("keydown", event => {
	
	// ignore all keys except enter key
	if (event.keyCode !== 13) return;
	
	while (messages.children.length > 100) {
		messages.firstElementChild.remove();
	}
	
	let message = document.createElement("li");
	message.classList.add("message");
	message.setAttribute("username", webstrate.user.username);
	message.innerText = input.value;
	
	messages.appendChild(message);
	
// 	let scrollTop = document.body.scrollTop;
// 	message.scrollIntoView({ block: "end", behavior: "smooth" });
// 	document.body.scrollTop = scrollTop;
	messages.scrollTop = messages.scrollHeight;
	
	input.value = "";	
});</PRE></DIV></DIV><DIV class="section section-hidden" name="Section browser" data-type="system" __wid="V_9VvmXG"><DIV class="paragraph body-paragraph collapsed" draggable="false" name="Description" __wid="ojGfONcZ"><DIV data-type="content" type="text/html" codemirror="true" contenteditable="true" __wid="f-pHyr51"><H1 __wid="kswJCJi1">Section browser</H1><DIV __wid="fP2kD4zk">This is a prototype implementation of a section browser in the side menu.</DIV><DIV __wid="z73i545C"><BR __wid="lCzQjLxy"/></DIV><DIV __wid="5D5EU3dE">Usage:</DIV><DIV __wid="g2JN3-3A"><UL __wid="83yHv1R_"><LI __wid="w07zh_Ts">Click sections to expand/collapse</LI><LI __wid="Q_Wt5-Zm">Click paragraph to scroll them into view</LI><LI __wid="pTMYahNb">Click section eye to toggle visbility</LI></UL><DIV __wid="dPobIwBB">Bugs, ideas and ToDo</DIV></DIV><DIV __wid="uLHxJVii"><UL __wid="nLNZPTMI"><LI __wid="od9BI_Ss"><STRIKE __wid="tTqXujQB">Refresh CodeMirror instances on visibility change</STRIKE></LI><LI __wid="KDEmjL-m"><STRIKE __wid="gHC9xTV0">Toggle visibility and expand paragraph when clicking a paragraph</STRIKE></LI><LI __wid="0_RHKxyQ">Integrate properly in Roman's sidebar code<BR __wid="WjEctneM"/></LI><LI __wid="cru0rxD5"><STRIKE __wid="5akNdQ_p">Overflow of sections with many paragraphs. Scrolling?</STRIKE></LI><LI __wid="x_2En10X">Disable scrolling of main window when scrolling in section tree. But how?</LI></UL></DIV></DIV></DIV><DIV class="paragraph code-paragraph collapsed" last-execution-state="success" name="Section browser code" run-on-load="true" __wid="RyGB0R37"><PRE data-type="content" type="text/javascript" __wid="evKzB2FA">var SectionItem = function(section) {
	section.__sectionItem = this;
	this.section = section;
	// Create a list item for the section
	this.li = document.createElement("li");
	// Per default this is closed
	this.li.classList.add("closed");

	// Create an element indicating if a section is expanded or not
	this.expander = document.createElement("span");
	this.expander.innerHTML = '&lt;i class="material-icons">keyboard_arrow_right&lt;/i>';
	this.li.appendChild(this.expander);

	// Create an elemen used for showing and toggling visibility
	this.visibility = document.createElement("span");
	this.visibility.innerHTML = '&lt;i class="material-icons">&lt;/i>';
	this.visibility.classList.add("visibility");
	this.li.appendChild(this.visibility);
	if (this.section.classList.contains("section-hidden")) {
		this.li.classList.add("hidden");
		this.visibility.firstChild.innerText = "visibility_off";
	} else {
		this.visibility.firstChild.innerText = "visibility";		
	}
	
	// Create the title of a section
	this.title = document.createElement("span");
	this.title.classList.add("title");
	var sectionName = this.section.getAttribute("name");
	this.title.innerText = sectionName && sectionName.length > 0 ? sectionName : "No Name";	
	this.li.appendChild(this.title);

	// Create the list of paragraphs
	this.ul = document.createElement("ul");
	this.li.appendChild(this.ul);
	
	// Create all the paragraph objects
	this.createParagraphItems();
	
	// When clicking the list item it toggles open/clised
	this.li.addEventListener("click", (e) => {
		this.li.classList.toggle("closed");
		if (this.li.classList.contains("closed")) {
				this.expander.innerHTML = '&lt;i class="material-icons">keyboard_arrow_right&lt;/i>';
		} else {
				this.expander.innerHTML = '&lt;i class="material-icons">keyboard_arrow_down&lt;/i>';
		}
	});
	
	// If the visibility icon is clicked, visibility of the section is toggled
	this.visibility.addEventListener("click", (e) => {
		e.stopPropagation();
		this.section.classList.toggle("section-hidden");
	});
	
	// A mutation observer is used to observe changes to attributes and children
	this.mo = new MutationObserver(() => {
		this.ul.innerHTML = "";
		var sectionName = this.section.getAttribute("name");
		this.title.innerText = sectionName && sectionName.length > 0 ? sectionName : "No Name";	
		if (this.section.classList.contains("section-hidden")) {
			this.li.classList.add("hidden");	
			this.visibility.firstChild.innerText = "visibility_off";
		} else {
			this.li.classList.remove("hidden");	
			this.visibility.firstChild.innerText = "visibility";
			
			// CodeMirror requires a refresh on the editor if any of the parent or
    	// container styles changed.
    	var contents = Array.from(this.section.querySelectorAll('.paragraph:not(.collapsed) [data-type="content"]'));
      
      contents.forEach(content => {
        if (content && content.__editor && content.__editor.editor) {
          content.__editor.editor.refresh();
        }
			});
		}
		this.createParagraphItems();
	});
	
	this.mo.observe(this.section, {attributes: true, childList: true});
}

SectionItem.prototype.createParagraphItems = function() {
	Array.from(this.section.querySelectorAll(".paragraph")).forEach((paragraph) => {
		var paragraphItem = new ParagraphItem(paragraph);
		this.ul.appendChild(paragraphItem.li);
	});
}

var ParagraphItem = function(paragraph) {
	paragraph.__paragraphItem = this;
	this.paragraph = paragraph;
	
	// Create a list item for the paragraph
	this.li = document.createElement("li");
	
	// Create an element for showing and toggling collapse
	this.collapse = document.createElement("span");
	this.collapse.innerHTML = '&lt;i class="material-icons">&lt;/i>';
	this.collapse.classList.add("collapse");
	this.li.appendChild(this.collapse);
	if (this.paragraph.classList.contains("collapsed")) {
		this.collapse.firstChild.innerText = "radio_button_unchecked";
	} else {
		this.collapse.firstChild.innerText = "radio_button_checked";		
	}
	
	// Create an element for the title of the paragraph
	this.title = document.createElement("span");
	this.title.classList.add("title");
	this.title.innerText = paragraph.getAttribute("name");
	this.li.appendChild(this.title);
	
	// Observe changes to the attributes of the paragraph
	this.mo = new MutationObserver(() => {
		this.title.innerText = paragraph.getAttribute("name");
		if (this.paragraph.classList.contains("collapsed")) {
			this.collapse.firstChild.innerText = "radio_button_unchecked";
		} else {	
			this.collapse.firstChild.innerText = "radio_button_checked";
		}
	});
	
	this.mo.observe(this.paragraph, {attributes: true});
	
	// If the paragraph is clicked, scroll it into view
	this.li.addEventListener("click", (e) => {
		e.stopPropagation();
		this.paragraph.classList.remove("collapsed");
		this.paragraph.closest(".section").classList.remove("section-hidden");
		this.paragraph.scrollIntoView();
	});
	
	// If the visibility icon is clicked, visibility of the section is toggled
	this.collapse.addEventListener("click", (e) => {
		e.stopPropagation();
		this.paragraph.classList.toggle("collapsed");
	});
}

var tree = document.querySelector("#global-menu #section-tree");
var sections = Array.from(document.querySelectorAll(".section"));

tree.innerHTML = "";

sections.forEach((section) => {
	var sectionItem = new SectionItem(section);
	tree.appendChild(sectionItem.li);
});</PRE></DIV><DIV class="paragraph style-paragraph collapsed" name="Section browser style" __wid="IqrEt0u3"><STYLE data-type="content" type="text/css" codemirror="true" __wid="TywVMatU">#section-tree {
	padding-left: 0px;	
	user-select: none;
	max-height: 500px;
	overflow: auto;
}

#section-tree, #section-tree ul {
	list-style: none;	
}

#section-tree ul {
	margin-left: 1em;	
}

#section-tree li {
	color: gainsboro;
	vertical-align: middle;
	text-overflow: ellipsis;
	white-space: nowrap;
	overflow: hidden;
}

#section-tree .closed ul {
	display: none;	
}

#section-tree li {
	cursor: pointer;	
}

#section-tree li.hidden {
	opacity: 0.5;	
}

#section-tree li .title {
	margin-left: 0.5em;
	vertical-align: middle;
}

#section-tree li i {
	vertical-align: middle;	
}</STYLE></DIV></DIV>



    

    
    

    

    

    

    








    



<DIV name="Bugs & Features" class="section section-hidden" __wid="XRl5rca-"><DIV class="paragraph body-paragraph" name="Bugs" __wid="83qkwoQG"><DIV data-type="content" type="text/html" codemirror="true" contenteditable="true" __wid="sMSfahfB"><UL __wid="aE9V0x1B"><LI __wid="Imz1fpMf"><STRIKE __wid="XPbDw1NR">Moving around sections duplicates section headers.</STRIKE></LI><LI __wid="9OoirBBB"><STRIKE __wid="AaXYy2K9">Pressing the Console button, before the code has been run, does nothing.</STRIKE></LI><UL __wid="MxJJxRIy"><LI __wid="VUEopGRH"><STRIKE __wid="AVFhxOF9">Console only gets initialized and added to the DOM when a code paragraph was executed at least once. Instead of waiting for the code to run once, the console can be initialized for every code paragraph right away. Or even better, it could be initialized for visible code paragraphs only and destroyed when a code paragraph gets collapsed.</STRIKE><BR __wid="1LA1R-L1"/></LI></UL><LI __wid="kSGrtdaQ"><STRIKE __wid="EwkJWSun">When locking a paragraph, the toolbar (text-tools) should disappear (the one with B, I, ...)</STRIKE></LI><LI __wid="S7zAWEfv">When you write press enter in a h1 tag, the code below it should not also be h1. If that's difficult to fix, just add a "clear style" button to the toolbar.</LI><LI __wid="KO6iBhH5">Moving (e.g., drag and drop) text content (e.g., an image) within a content paragraph causes "That's not a file?" alerts.</LI><LI __wid="W4PC9V4y">If you lock a paragraph (you're editing with the HTML Editor) before saving it, weird stuff happens. &lt;span>s get added and shit. Simple fix: Automatically save before locking.</LI><UL __wid="A5ppj2iO"><LI __wid="mU7uVKlu">Note: Changes in the HTML Editor will be discarded when a paragraph is locked.</LI></UL><LI __wid="EqN5kafS">Sometimes clicking in a code paragraph will scroll the page to the top</LI></UL></DIV></DIV><DIV class="paragraph body-paragraph locked" name="Features" __wid="9FdMz0tA"><DIV data-type="content" type="text/html" codemirror="true" contenteditable="false" __wid="XIZ6OD0-"><UL style="font-size: 14.6667px;" __wid="iKLiDEma"><LI __wid="zRqwYqjx"><STRIKE __wid="GmrUubCQ">Color Console icon in toolbar when there was an error executing the code.</STRIKE></LI><LI __wid="AoFkPBP0">Console: support fold and unfold of complex objects including HTMLElement objects or objects with functions etc.</LI><LI __wid="ZO1nFPx0">Add proper material icons to console, similar to DevTools console (e.g., '>' before console input or error icon for errors)</LI><UL __wid="Ahax6hE6"><LI __wid="4aP9sryQ">Example (screenshot from Chrome Dev Tools)<IMG src="Screen Shot 2017-02-14 at 00.10.21.png" __wid="WzdCh6Oi"/></LI></UL><LI __wid="1neaAaRz">Add links to jump to executed line of code (see screenshot above)</LI><LI __wid="TjxW63B9"><STRIKE __wid="UDXRmXBg">Add user thumbnails to see who's viewing/editing the Active Essay.</STRIKE></LI><LI __wid="XDS3jJNj"><STRIKE __wid="T6-TtCCa">Save HTML in content paragraph editor when ctrl+s or cmd+s is pressed (like in<A href="https://webstrates.cs.au.dk/Bk7eYrNKx/" target="_blank" style="color: orange;" __wid="rRACUeG1">https://webstrates.cs.au.dk/Bk7eYrNKx/</A>)</STRIKE></LI><LI __wid="cCmNSwa5">Hover text on menu items (what's this running man do? "Run on load.", oh ok).</LI><LI __wid="uqFTOCsk">Hide paragraph (like Bugs & Features) button in the top menu... Maybe</LI></UL></DIV></DIV></DIV><DIV name="Introduction to Codestrates" class="section section-hidden" __wid="_m9UT9ed"><DIV class="paragraph body-paragraph" name="Welcome" __wid="5g_MnH2y"><DIV data-type="content" contenteditable="true" codemirror="true" id="welcome" class="drawable" __wid="wQK1cHnS"><H1 __wid="c7MtIExk">Welcome to Codestrate</H1>Start writing<B __wid="mKg7VWXu">your</B> own Codestrate now!
<DIV __wid="u1aOHh5Z">
  <H2 __wid="-sHvxh1K">Images or other Media</H2>
  <DIV __wid="LAAR_Vko">Drag and drop images to the <I __wid="F6fIsAgz">content</I> paragraph. Dropped images will be added at the cursor position. The image below is style.</DIV>
  <DIV __wid="Sn-wzQ9w"><BR __wid="skatLARk"/></DIV>
  <DIV __wid="LkRPZv61">
    <DIV __wid="PyBfSevh">
      <IMG width="200px" class="cow-image" src="baby-cow.jpg" alt="Baby Cow" __wid="9IouRl7a"/>
      <DIV __wid="GfXO9G27">What a nice baby cow! Kristian will like it :)</DIV>
    </DIV>

    <H2 __wid="M8V_zCs7">Custom Formatting</H2>
    <UL id="test-list" __wid="7tWEPhjx">
      <LI __wid="kuFgjbPP">A Bullet</LI>
      <LI __wid="EosHoswG">Point</LI>
      <LI __wid="92BemmW8">List</LI>
      <UL __wid="PhXPcHp7">
        <LI __wid="kZwLxM71">With Indent</LI>
      </UL>
    </UL>
  </DIV>

  <!-- <iframe class="allow-fullscreen" src="/ByE7GI_tg/" contenteditable="false"></iframe> -->

  <H2 __wid="Sx7cup6Z">Annotations</H2>
  <DIV __wid="9zKCbOxD">Annotate the image below using a mouse (ctrl + mousedown/move) or the Apple Pen. Annotations stick to the image. You can also annotate the whole <I __wid="nKXJiLQq">content</I> paragraph by adding the <I __wid="djEmzufx">.drawable</I> class to it.</DIV>
  <DIV __wid="9w_1_Io7"><BR __wid="Jl8Vx43M"/></DIV>
  <DIV class="drawable allow-fullscreen" __wid="5XXE72L0">
		<IMG src="Screen Shot 2017-02-14 at 00.10.21.png" class="darkroom-image-3y2n5YmY canvas-img darkroom-image-vYayGoUF darkroom-image-wbl93kjW" __wid="y0UoWpOC"/>
	</DIV>
</DIV></DIV></DIV><DIV class="paragraph style-paragraph" name="Cow Style" draggable="false" __wid="7qX7Ufa3"><STYLE data-type="content" type="text/css" codemirror="true" contenteditable="true" id="cow-style" __wid="kxG1vzqL">a {
	color: orange;
	text-decoration: none;
	cursor: pointer;
}

.cow-image {
	border: 1px solid deeppink;
	box-shadow: 0 0 10px deeppink;
	border-radius: 2px;
	margin: 20px 0 20px 5px;
}</STYLE></DIV><DIV class="paragraph code-paragraph" last-execution-state="success" name="Event Handling" __wid="cRlZVWOz"><PRE data-type="content" type="text/javascript" contenteditable="true" __wid="c4pnLWaC">const welcome = document.getElementById("welcome");

let clickCount = 0;

welcome.addEventListener("click", function() {
	console.log(`You clicked the #welcome element ${++clickCount} times. Awesome!`);
	
	// Alternative solution with require data + templates using string literals
	// like ${clickCount}
	const data = require('#data', { clickCount: clickCount });
	
	console.log(data.message);
	
	console.log(`Lorem ipsum text: ${data.example.loremIpsum}`);
	
	const radius = 10;
	const circleArea = data.example.PI * Math.pow(radius, 2);
	console.log(`The area of a circle with a radius of ${radius} is ${circleArea}`);
});</PRE></DIV><DIV class="paragraph data-paragraph" name="Data Paragraph" __wid="ox5iTLjK"><PRE data-type="content" type="application/json" contenteditable="true" id="data" __wid="VFkS8IVb">{
	"message": "A way to use data paragraphs with templating for click count: ${clickCount}.",
	"example": {
		"loremIpsum": "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Suspendisse non justo condimentum, ornare risus vel, tempus ex. Vestibulum volutpat dui ac ante auctor, tempor mattis nunc laoreet. Cras vel mollis neque...",
		"PI": 3.14159265359
	}
}</PRE></DIV></DIV>


<DIV class="section" __wid="gb85VsBe"></DIV></BODY></html>